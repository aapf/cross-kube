// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.14.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import ExtensionsV1beta1Deployment from '../models/ExtensionsV1beta1Deployment'
import ExtensionsV1beta1DeploymentList from '../models/ExtensionsV1beta1DeploymentList'
import ExtensionsV1beta1DeploymentRollback from '../models/ExtensionsV1beta1DeploymentRollback'
import ExtensionsV1beta1Ingress from '../models/ExtensionsV1beta1Ingress'
import ExtensionsV1beta1IngressList from '../models/ExtensionsV1beta1IngressList'
import ExtensionsV1beta1PodSecurityPolicy from '../models/ExtensionsV1beta1PodSecurityPolicy'
import ExtensionsV1beta1PodSecurityPolicyList from '../models/ExtensionsV1beta1PodSecurityPolicyList'
import ExtensionsV1beta1Scale from '../models/ExtensionsV1beta1Scale'
import V1APIResourceList from '../models/V1APIResourceList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Status from '../models/V1Status'
import V1beta1DaemonSet from '../models/V1beta1DaemonSet'
import V1beta1DaemonSetList from '../models/V1beta1DaemonSetList'
import V1beta1NetworkPolicy from '../models/V1beta1NetworkPolicy'
import V1beta1NetworkPolicyList from '../models/V1beta1NetworkPolicyList'
import V1beta1ReplicaSet from '../models/V1beta1ReplicaSet'
import V1beta1ReplicaSetList from '../models/V1beta1ReplicaSetList'

interface CreateNamespacedDaemonSetRequest {
  namespace: string
  body: V1beta1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDeploymentRequest {
  namespace: string
  body: ExtensionsV1beta1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDeploymentRollbackRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1DeploymentRollback
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedIngressRequest {
  namespace: string
  body: ExtensionsV1beta1Ingress
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedNetworkPolicyRequest {
  namespace: string
  body: V1beta1NetworkPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedReplicaSetRequest {
  namespace: string
  body: V1beta1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreatePodSecurityPolicyRequest {
  body: ExtensionsV1beta1PodSecurityPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface DeleteCollectionNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedIngressRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedNetworkPolicyRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionPodSecurityPolicyRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedIngressRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeletePodSecurityPolicyRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface ListDaemonSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListDeploymentForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListIngressForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedIngressRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedNetworkPolicyRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNetworkPolicyForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPodSecurityPolicyRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListReplicaSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface PatchNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedIngressRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedIngressStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerDummyScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchPodSecurityPolicyRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface ReadNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedIngressRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedIngressStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicationControllerDummyScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadPodSecurityPolicyRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReplaceNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: V1beta1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: V1beta1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedIngressRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Ingress
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedIngressStatusRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Ingress
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  body: V1beta1NetworkPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: V1beta1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: V1beta1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerDummyScaleRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplacePodSecurityPolicyRequest {
  name: string
  body: ExtensionsV1beta1PodSecurityPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

/**
 *
 */
export default class ExtensionsV1beta1Api extends runtime.BaseAPI {
  /**
   * create a DaemonSet
   */
  async createNamespacedDaemonSetRaw(
    requestParameters: CreateNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSet>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDaemonSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a DaemonSet
   */
  async createNamespacedDaemonSet(
    requestParameters: CreateNamespacedDaemonSetRequest
  ): Promise<V1beta1DaemonSet> {
    const response = await this.createNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Deployment
   */
  async createNamespacedDeploymentRaw(
    requestParameters: CreateNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Deployment>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDeployment.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Deployment
   */
  async createNamespacedDeployment(
    requestParameters: CreateNamespacedDeploymentRequest
  ): Promise<ExtensionsV1beta1Deployment> {
    const response = await this.createNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * create rollback of a Deployment
   */
  async createNamespacedDeploymentRollbackRaw(
    requestParameters: CreateNamespacedDeploymentRollbackRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling createNamespacedDeploymentRollback.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDeploymentRollback.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedDeploymentRollback.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create rollback of a Deployment
   */
  async createNamespacedDeploymentRollback(
    requestParameters: CreateNamespacedDeploymentRollbackRequest
  ): Promise<V1Status> {
    const response = await this.createNamespacedDeploymentRollbackRaw(requestParameters)
    return await response.value()
  }

  /**
   * create an Ingress
   */
  async createNamespacedIngressRaw(
    requestParameters: CreateNamespacedIngressRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Ingress>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedIngress.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create an Ingress
   */
  async createNamespacedIngress(
    requestParameters: CreateNamespacedIngressRequest
  ): Promise<ExtensionsV1beta1Ingress> {
    const response = await this.createNamespacedIngressRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a NetworkPolicy
   */
  async createNamespacedNetworkPolicyRaw(
    requestParameters: CreateNamespacedNetworkPolicyRequest
  ): Promise<runtime.ApiResponse<V1beta1NetworkPolicy>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedNetworkPolicy.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a NetworkPolicy
   */
  async createNamespacedNetworkPolicy(
    requestParameters: CreateNamespacedNetworkPolicyRequest
  ): Promise<V1beta1NetworkPolicy> {
    const response = await this.createNamespacedNetworkPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a ReplicaSet
   */
  async createNamespacedReplicaSetRaw(
    requestParameters: CreateNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSet>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedReplicaSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a ReplicaSet
   */
  async createNamespacedReplicaSet(
    requestParameters: CreateNamespacedReplicaSetRequest
  ): Promise<V1beta1ReplicaSet> {
    const response = await this.createNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a PodSecurityPolicy
   */
  async createPodSecurityPolicyRaw(
    requestParameters: CreatePodSecurityPolicyRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createPodSecurityPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/podsecuritypolicies`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a PodSecurityPolicy
   */
  async createPodSecurityPolicy(
    requestParameters: CreatePodSecurityPolicyRequest
  ): Promise<ExtensionsV1beta1PodSecurityPolicy> {
    const response = await this.createPodSecurityPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of DaemonSet
   */
  async deleteCollectionNamespacedDaemonSetRaw(
    requestParameters: DeleteCollectionNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of DaemonSet
   */
  async deleteCollectionNamespacedDaemonSet(
    requestParameters: DeleteCollectionNamespacedDaemonSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of Deployment
   */
  async deleteCollectionNamespacedDeploymentRaw(
    requestParameters: DeleteCollectionNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Deployment
   */
  async deleteCollectionNamespacedDeployment(
    requestParameters: DeleteCollectionNamespacedDeploymentRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of Ingress
   */
  async deleteCollectionNamespacedIngressRaw(
    requestParameters: DeleteCollectionNamespacedIngressRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Ingress
   */
  async deleteCollectionNamespacedIngress(
    requestParameters: DeleteCollectionNamespacedIngressRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedIngressRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of NetworkPolicy
   */
  async deleteCollectionNamespacedNetworkPolicyRaw(
    requestParameters: DeleteCollectionNamespacedNetworkPolicyRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of NetworkPolicy
   */
  async deleteCollectionNamespacedNetworkPolicy(
    requestParameters: DeleteCollectionNamespacedNetworkPolicyRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedNetworkPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of ReplicaSet
   */
  async deleteCollectionNamespacedReplicaSetRaw(
    requestParameters: DeleteCollectionNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of ReplicaSet
   */
  async deleteCollectionNamespacedReplicaSet(
    requestParameters: DeleteCollectionNamespacedReplicaSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of PodSecurityPolicy
   */
  async deleteCollectionPodSecurityPolicyRaw(
    requestParameters: DeleteCollectionPodSecurityPolicyRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/podsecuritypolicies`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of PodSecurityPolicy
   */
  async deleteCollectionPodSecurityPolicy(
    requestParameters: DeleteCollectionPodSecurityPolicyRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionPodSecurityPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a DaemonSet
   */
  async deleteNamespacedDaemonSetRaw(
    requestParameters: DeleteNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a DaemonSet
   */
  async deleteNamespacedDaemonSet(
    requestParameters: DeleteNamespacedDaemonSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a Deployment
   */
  async deleteNamespacedDeploymentRaw(
    requestParameters: DeleteNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a Deployment
   */
  async deleteNamespacedDeployment(
    requestParameters: DeleteNamespacedDeploymentRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete an Ingress
   */
  async deleteNamespacedIngressRaw(
    requestParameters: DeleteNamespacedIngressRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedIngress.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete an Ingress
   */
  async deleteNamespacedIngress(
    requestParameters: DeleteNamespacedIngressRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedIngressRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a NetworkPolicy
   */
  async deleteNamespacedNetworkPolicyRaw(
    requestParameters: DeleteNamespacedNetworkPolicyRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedNetworkPolicy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a NetworkPolicy
   */
  async deleteNamespacedNetworkPolicy(
    requestParameters: DeleteNamespacedNetworkPolicyRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedNetworkPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a ReplicaSet
   */
  async deleteNamespacedReplicaSetRaw(
    requestParameters: DeleteNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a ReplicaSet
   */
  async deleteNamespacedReplicaSet(
    requestParameters: DeleteNamespacedReplicaSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a PodSecurityPolicy
   */
  async deletePodSecurityPolicyRaw(
    requestParameters: DeletePodSecurityPolicyRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deletePodSecurityPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a PodSecurityPolicy
   */
  async deletePodSecurityPolicy(
    requestParameters: DeletePodSecurityPolicyRequest
  ): Promise<V1Status> {
    const response = await this.deletePodSecurityPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * get available resources
   */
  async getAPIResourcesRaw(): Promise<runtime.ApiResponse<V1APIResourceList>> {
    const queryParameters: runtime.HTTPQuery = {}
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * get available resources
   */
  async getAPIResources(): Promise<V1APIResourceList> {
    const response = await this.getAPIResourcesRaw()
    return await response.value()
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async watchListDaemonSetForAllNamespaces(
    requestParameters: ListDaemonSetForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta1DaemonSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta1DaemonSetList>>(
      {
        path: `/apis/extensions/v1beta1/daemonsets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listDaemonSetForAllNamespacesRaw(
    requestParameters: ListDaemonSetForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSetList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/daemonsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listDaemonSetForAllNamespaces(
    requestParameters: ListDaemonSetForAllNamespacesRequest
  ): Promise<V1beta1DaemonSetList> {
    const response = await this.listDaemonSetForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Deployment
   */
  async watchListDeploymentForAllNamespaces(
    requestParameters: ListDeploymentForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<ExtensionsV1beta1DeploymentList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<ExtensionsV1beta1DeploymentList>>(
      {
        path: `/apis/extensions/v1beta1/deployments`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listDeploymentForAllNamespacesRaw(
    requestParameters: ListDeploymentForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1DeploymentList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/deployments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listDeploymentForAllNamespaces(
    requestParameters: ListDeploymentForAllNamespacesRequest
  ): Promise<ExtensionsV1beta1DeploymentList> {
    const response = await this.listDeploymentForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Ingress
   */
  async watchListIngressForAllNamespaces(
    requestParameters: ListIngressForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<ExtensionsV1beta1IngressList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<ExtensionsV1beta1IngressList>>(
      {
        path: `/apis/extensions/v1beta1/ingresses`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Ingress
   */
  async listIngressForAllNamespacesRaw(
    requestParameters: ListIngressForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1IngressList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/ingresses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Ingress
   */
  async listIngressForAllNamespaces(
    requestParameters: ListIngressForAllNamespacesRequest
  ): Promise<ExtensionsV1beta1IngressList> {
    const response = await this.listIngressForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async watchListNamespacedDaemonSet(
    requestParameters: ListNamespacedDaemonSetRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta1DaemonSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta1DaemonSetList>>(
      {
        path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listNamespacedDaemonSetRaw(
    requestParameters: ListNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSetList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listNamespacedDaemonSet(
    requestParameters: ListNamespacedDaemonSetRequest
  ): Promise<V1beta1DaemonSetList> {
    const response = await this.listNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Deployment
   */
  async watchListNamespacedDeployment(
    requestParameters: ListNamespacedDeploymentRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<ExtensionsV1beta1DeploymentList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<ExtensionsV1beta1DeploymentList>>(
      {
        path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listNamespacedDeploymentRaw(
    requestParameters: ListNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1DeploymentList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listNamespacedDeployment(
    requestParameters: ListNamespacedDeploymentRequest
  ): Promise<ExtensionsV1beta1DeploymentList> {
    const response = await this.listNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Ingress
   */
  async watchListNamespacedIngress(
    requestParameters: ListNamespacedIngressRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<ExtensionsV1beta1IngressList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<ExtensionsV1beta1IngressList>>(
      {
        path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Ingress
   */
  async listNamespacedIngressRaw(
    requestParameters: ListNamespacedIngressRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1IngressList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Ingress
   */
  async listNamespacedIngress(
    requestParameters: ListNamespacedIngressRequest
  ): Promise<ExtensionsV1beta1IngressList> {
    const response = await this.listNamespacedIngressRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind NetworkPolicy
   */
  async watchListNamespacedNetworkPolicy(
    requestParameters: ListNamespacedNetworkPolicyRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta1NetworkPolicyList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta1NetworkPolicyList>>(
      {
        path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind NetworkPolicy
   */
  async listNamespacedNetworkPolicyRaw(
    requestParameters: ListNamespacedNetworkPolicyRequest
  ): Promise<runtime.ApiResponse<V1beta1NetworkPolicyList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind NetworkPolicy
   */
  async listNamespacedNetworkPolicy(
    requestParameters: ListNamespacedNetworkPolicyRequest
  ): Promise<V1beta1NetworkPolicyList> {
    const response = await this.listNamespacedNetworkPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async watchListNamespacedReplicaSet(
    requestParameters: ListNamespacedReplicaSetRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta1ReplicaSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta1ReplicaSetList>>(
      {
        path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listNamespacedReplicaSetRaw(
    requestParameters: ListNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSetList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listNamespacedReplicaSet(
    requestParameters: ListNamespacedReplicaSetRequest
  ): Promise<V1beta1ReplicaSetList> {
    const response = await this.listNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind NetworkPolicy
   */
  async watchListNetworkPolicyForAllNamespaces(
    requestParameters: ListNetworkPolicyForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta1NetworkPolicyList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta1NetworkPolicyList>>(
      {
        path: `/apis/extensions/v1beta1/networkpolicies`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind NetworkPolicy
   */
  async listNetworkPolicyForAllNamespacesRaw(
    requestParameters: ListNetworkPolicyForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta1NetworkPolicyList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/networkpolicies`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind NetworkPolicy
   */
  async listNetworkPolicyForAllNamespaces(
    requestParameters: ListNetworkPolicyForAllNamespacesRequest
  ): Promise<V1beta1NetworkPolicyList> {
    const response = await this.listNetworkPolicyForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind PodSecurityPolicy
   */
  async watchListPodSecurityPolicy(
    requestParameters: ListPodSecurityPolicyRequest,
    callback: (
      event: runtime.KubeEvent<runtime.ItemType<ExtensionsV1beta1PodSecurityPolicyList>>
    ) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<ExtensionsV1beta1PodSecurityPolicyList>>(
      {
        path: `/apis/extensions/v1beta1/podsecuritypolicies`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind PodSecurityPolicy
   */
  async listPodSecurityPolicyRaw(
    requestParameters: ListPodSecurityPolicyRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1PodSecurityPolicyList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/podsecuritypolicies`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind PodSecurityPolicy
   */
  async listPodSecurityPolicy(
    requestParameters: ListPodSecurityPolicyRequest
  ): Promise<ExtensionsV1beta1PodSecurityPolicyList> {
    const response = await this.listPodSecurityPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async watchListReplicaSetForAllNamespaces(
    requestParameters: ListReplicaSetForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta1ReplicaSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta1ReplicaSetList>>(
      {
        path: `/apis/extensions/v1beta1/replicasets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listReplicaSetForAllNamespacesRaw(
    requestParameters: ListReplicaSetForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSetList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/replicasets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listReplicaSetForAllNamespaces(
    requestParameters: ListReplicaSetForAllNamespacesRequest
  ): Promise<V1beta1ReplicaSetList> {
    const response = await this.listReplicaSetForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified DaemonSet
   */
  async patchNamespacedDaemonSetRaw(
    requestParameters: PatchNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified DaemonSet
   */
  async patchNamespacedDaemonSet(
    requestParameters: PatchNamespacedDaemonSetRequest
  ): Promise<V1beta1DaemonSet> {
    const response = await this.patchNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified DaemonSet
   */
  async patchNamespacedDaemonSetStatusRaw(
    requestParameters: PatchNamespacedDaemonSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified DaemonSet
   */
  async patchNamespacedDaemonSetStatus(
    requestParameters: PatchNamespacedDaemonSetStatusRequest
  ): Promise<V1beta1DaemonSet> {
    const response = await this.patchNamespacedDaemonSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Deployment
   */
  async patchNamespacedDeploymentRaw(
    requestParameters: PatchNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeployment.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Deployment
   */
  async patchNamespacedDeployment(
    requestParameters: PatchNamespacedDeploymentRequest
  ): Promise<ExtensionsV1beta1Deployment> {
    const response = await this.patchNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update scale of the specified Deployment
   */
  async patchNamespacedDeploymentScaleRaw(
    requestParameters: PatchNamespacedDeploymentScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update scale of the specified Deployment
   */
  async patchNamespacedDeploymentScale(
    requestParameters: PatchNamespacedDeploymentScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.patchNamespacedDeploymentScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified Deployment
   */
  async patchNamespacedDeploymentStatusRaw(
    requestParameters: PatchNamespacedDeploymentStatusRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified Deployment
   */
  async patchNamespacedDeploymentStatus(
    requestParameters: PatchNamespacedDeploymentStatusRequest
  ): Promise<ExtensionsV1beta1Deployment> {
    const response = await this.patchNamespacedDeploymentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Ingress
   */
  async patchNamespacedIngressRaw(
    requestParameters: PatchNamespacedIngressRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Ingress>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedIngress.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedIngress.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Ingress
   */
  async patchNamespacedIngress(
    requestParameters: PatchNamespacedIngressRequest
  ): Promise<ExtensionsV1beta1Ingress> {
    const response = await this.patchNamespacedIngressRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified Ingress
   */
  async patchNamespacedIngressStatusRaw(
    requestParameters: PatchNamespacedIngressStatusRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Ingress>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedIngressStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedIngressStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedIngressStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified Ingress
   */
  async patchNamespacedIngressStatus(
    requestParameters: PatchNamespacedIngressStatusRequest
  ): Promise<ExtensionsV1beta1Ingress> {
    const response = await this.patchNamespacedIngressStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified NetworkPolicy
   */
  async patchNamespacedNetworkPolicyRaw(
    requestParameters: PatchNamespacedNetworkPolicyRequest
  ): Promise<runtime.ApiResponse<V1beta1NetworkPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedNetworkPolicy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedNetworkPolicy.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified NetworkPolicy
   */
  async patchNamespacedNetworkPolicy(
    requestParameters: PatchNamespacedNetworkPolicyRequest
  ): Promise<V1beta1NetworkPolicy> {
    const response = await this.patchNamespacedNetworkPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified ReplicaSet
   */
  async patchNamespacedReplicaSetRaw(
    requestParameters: PatchNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified ReplicaSet
   */
  async patchNamespacedReplicaSet(
    requestParameters: PatchNamespacedReplicaSetRequest
  ): Promise<V1beta1ReplicaSet> {
    const response = await this.patchNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update scale of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetScaleRaw(
    requestParameters: PatchNamespacedReplicaSetScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update scale of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetScale(
    requestParameters: PatchNamespacedReplicaSetScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.patchNamespacedReplicaSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetStatusRaw(
    requestParameters: PatchNamespacedReplicaSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetStatus(
    requestParameters: PatchNamespacedReplicaSetStatusRequest
  ): Promise<V1beta1ReplicaSet> {
    const response = await this.patchNamespacedReplicaSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update scale of the specified ReplicationControllerDummy
   */
  async patchNamespacedReplicationControllerDummyScaleRaw(
    requestParameters: PatchNamespacedReplicationControllerDummyScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerDummyScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerDummyScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerDummyScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update scale of the specified ReplicationControllerDummy
   */
  async patchNamespacedReplicationControllerDummyScale(
    requestParameters: PatchNamespacedReplicationControllerDummyScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.patchNamespacedReplicationControllerDummyScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified PodSecurityPolicy
   */
  async patchPodSecurityPolicyRaw(
    requestParameters: PatchPodSecurityPolicyRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchPodSecurityPolicy.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchPodSecurityPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified PodSecurityPolicy
   */
  async patchPodSecurityPolicy(
    requestParameters: PatchPodSecurityPolicyRequest
  ): Promise<ExtensionsV1beta1PodSecurityPolicy> {
    const response = await this.patchPodSecurityPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified DaemonSet
   */
  async readNamespacedDaemonSetRaw(
    requestParameters: ReadNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified DaemonSet
   */
  async readNamespacedDaemonSet(
    requestParameters: ReadNamespacedDaemonSetRequest
  ): Promise<V1beta1DaemonSet> {
    const response = await this.readNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified DaemonSet
   */
  async readNamespacedDaemonSetStatusRaw(
    requestParameters: ReadNamespacedDaemonSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified DaemonSet
   */
  async readNamespacedDaemonSetStatus(
    requestParameters: ReadNamespacedDaemonSetStatusRequest
  ): Promise<V1beta1DaemonSet> {
    const response = await this.readNamespacedDaemonSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Deployment
   */
  async readNamespacedDeploymentRaw(
    requestParameters: ReadNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Deployment
   */
  async readNamespacedDeployment(
    requestParameters: ReadNamespacedDeploymentRequest
  ): Promise<ExtensionsV1beta1Deployment> {
    const response = await this.readNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * read scale of the specified Deployment
   */
  async readNamespacedDeploymentScaleRaw(
    requestParameters: ReadNamespacedDeploymentScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read scale of the specified Deployment
   */
  async readNamespacedDeploymentScale(
    requestParameters: ReadNamespacedDeploymentScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.readNamespacedDeploymentScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified Deployment
   */
  async readNamespacedDeploymentStatusRaw(
    requestParameters: ReadNamespacedDeploymentStatusRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified Deployment
   */
  async readNamespacedDeploymentStatus(
    requestParameters: ReadNamespacedDeploymentStatusRequest
  ): Promise<ExtensionsV1beta1Deployment> {
    const response = await this.readNamespacedDeploymentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Ingress
   */
  async readNamespacedIngressRaw(
    requestParameters: ReadNamespacedIngressRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Ingress>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedIngress.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Ingress
   */
  async readNamespacedIngress(
    requestParameters: ReadNamespacedIngressRequest
  ): Promise<ExtensionsV1beta1Ingress> {
    const response = await this.readNamespacedIngressRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified Ingress
   */
  async readNamespacedIngressStatusRaw(
    requestParameters: ReadNamespacedIngressStatusRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Ingress>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedIngressStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedIngressStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified Ingress
   */
  async readNamespacedIngressStatus(
    requestParameters: ReadNamespacedIngressStatusRequest
  ): Promise<ExtensionsV1beta1Ingress> {
    const response = await this.readNamespacedIngressStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified NetworkPolicy
   */
  async readNamespacedNetworkPolicyRaw(
    requestParameters: ReadNamespacedNetworkPolicyRequest
  ): Promise<runtime.ApiResponse<V1beta1NetworkPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedNetworkPolicy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified NetworkPolicy
   */
  async readNamespacedNetworkPolicy(
    requestParameters: ReadNamespacedNetworkPolicyRequest
  ): Promise<V1beta1NetworkPolicy> {
    const response = await this.readNamespacedNetworkPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ReplicaSet
   */
  async readNamespacedReplicaSetRaw(
    requestParameters: ReadNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ReplicaSet
   */
  async readNamespacedReplicaSet(
    requestParameters: ReadNamespacedReplicaSetRequest
  ): Promise<V1beta1ReplicaSet> {
    const response = await this.readNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * read scale of the specified ReplicaSet
   */
  async readNamespacedReplicaSetScaleRaw(
    requestParameters: ReadNamespacedReplicaSetScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read scale of the specified ReplicaSet
   */
  async readNamespacedReplicaSetScale(
    requestParameters: ReadNamespacedReplicaSetScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.readNamespacedReplicaSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified ReplicaSet
   */
  async readNamespacedReplicaSetStatusRaw(
    requestParameters: ReadNamespacedReplicaSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified ReplicaSet
   */
  async readNamespacedReplicaSetStatus(
    requestParameters: ReadNamespacedReplicaSetStatusRequest
  ): Promise<V1beta1ReplicaSet> {
    const response = await this.readNamespacedReplicaSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read scale of the specified ReplicationControllerDummy
   */
  async readNamespacedReplicationControllerDummyScaleRaw(
    requestParameters: ReadNamespacedReplicationControllerDummyScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerDummyScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerDummyScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read scale of the specified ReplicationControllerDummy
   */
  async readNamespacedReplicationControllerDummyScale(
    requestParameters: ReadNamespacedReplicationControllerDummyScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.readNamespacedReplicationControllerDummyScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified PodSecurityPolicy
   */
  async readPodSecurityPolicyRaw(
    requestParameters: ReadPodSecurityPolicyRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readPodSecurityPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified PodSecurityPolicy
   */
  async readPodSecurityPolicy(
    requestParameters: ReadPodSecurityPolicyRequest
  ): Promise<ExtensionsV1beta1PodSecurityPolicy> {
    const response = await this.readPodSecurityPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified DaemonSet
   */
  async replaceNamespacedDaemonSetRaw(
    requestParameters: ReplaceNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified DaemonSet
   */
  async replaceNamespacedDaemonSet(
    requestParameters: ReplaceNamespacedDaemonSetRequest
  ): Promise<V1beta1DaemonSet> {
    const response = await this.replaceNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified DaemonSet
   */
  async replaceNamespacedDaemonSetStatusRaw(
    requestParameters: ReplaceNamespacedDaemonSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta1DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified DaemonSet
   */
  async replaceNamespacedDaemonSetStatus(
    requestParameters: ReplaceNamespacedDaemonSetStatusRequest
  ): Promise<V1beta1DaemonSet> {
    const response = await this.replaceNamespacedDaemonSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Deployment
   */
  async replaceNamespacedDeploymentRaw(
    requestParameters: ReplaceNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeployment.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Deployment
   */
  async replaceNamespacedDeployment(
    requestParameters: ReplaceNamespacedDeploymentRequest
  ): Promise<ExtensionsV1beta1Deployment> {
    const response = await this.replaceNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace scale of the specified Deployment
   */
  async replaceNamespacedDeploymentScaleRaw(
    requestParameters: ReplaceNamespacedDeploymentScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace scale of the specified Deployment
   */
  async replaceNamespacedDeploymentScale(
    requestParameters: ReplaceNamespacedDeploymentScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.replaceNamespacedDeploymentScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified Deployment
   */
  async replaceNamespacedDeploymentStatusRaw(
    requestParameters: ReplaceNamespacedDeploymentStatusRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified Deployment
   */
  async replaceNamespacedDeploymentStatus(
    requestParameters: ReplaceNamespacedDeploymentStatusRequest
  ): Promise<ExtensionsV1beta1Deployment> {
    const response = await this.replaceNamespacedDeploymentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Ingress
   */
  async replaceNamespacedIngressRaw(
    requestParameters: ReplaceNamespacedIngressRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Ingress>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedIngress.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedIngress.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedIngress.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Ingress
   */
  async replaceNamespacedIngress(
    requestParameters: ReplaceNamespacedIngressRequest
  ): Promise<ExtensionsV1beta1Ingress> {
    const response = await this.replaceNamespacedIngressRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified Ingress
   */
  async replaceNamespacedIngressStatusRaw(
    requestParameters: ReplaceNamespacedIngressStatusRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Ingress>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedIngressStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedIngressStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedIngressStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified Ingress
   */
  async replaceNamespacedIngressStatus(
    requestParameters: ReplaceNamespacedIngressStatusRequest
  ): Promise<ExtensionsV1beta1Ingress> {
    const response = await this.replaceNamespacedIngressStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified NetworkPolicy
   */
  async replaceNamespacedNetworkPolicyRaw(
    requestParameters: ReplaceNamespacedNetworkPolicyRequest
  ): Promise<runtime.ApiResponse<V1beta1NetworkPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedNetworkPolicy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedNetworkPolicy.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedNetworkPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified NetworkPolicy
   */
  async replaceNamespacedNetworkPolicy(
    requestParameters: ReplaceNamespacedNetworkPolicyRequest
  ): Promise<V1beta1NetworkPolicy> {
    const response = await this.replaceNamespacedNetworkPolicyRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetRaw(
    requestParameters: ReplaceNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified ReplicaSet
   */
  async replaceNamespacedReplicaSet(
    requestParameters: ReplaceNamespacedReplicaSetRequest
  ): Promise<V1beta1ReplicaSet> {
    const response = await this.replaceNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace scale of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetScaleRaw(
    requestParameters: ReplaceNamespacedReplicaSetScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace scale of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetScale(
    requestParameters: ReplaceNamespacedReplicaSetScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.replaceNamespacedReplicaSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetStatusRaw(
    requestParameters: ReplaceNamespacedReplicaSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta1ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetStatus(
    requestParameters: ReplaceNamespacedReplicaSetStatusRequest
  ): Promise<V1beta1ReplicaSet> {
    const response = await this.replaceNamespacedReplicaSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace scale of the specified ReplicationControllerDummy
   */
  async replaceNamespacedReplicationControllerDummyScaleRaw(
    requestParameters: ReplaceNamespacedReplicationControllerDummyScaleRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace scale of the specified ReplicationControllerDummy
   */
  async replaceNamespacedReplicationControllerDummyScale(
    requestParameters: ReplaceNamespacedReplicationControllerDummyScaleRequest
  ): Promise<ExtensionsV1beta1Scale> {
    const response = await this.replaceNamespacedReplicationControllerDummyScaleRaw(
      requestParameters
    )
    return await response.value()
  }

  /**
   * replace the specified PodSecurityPolicy
   */
  async replacePodSecurityPolicyRaw(
    requestParameters: ReplacePodSecurityPolicyRequest
  ): Promise<runtime.ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replacePodSecurityPolicy.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replacePodSecurityPolicy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified PodSecurityPolicy
   */
  async replacePodSecurityPolicy(
    requestParameters: ReplacePodSecurityPolicyRequest
  ): Promise<ExtensionsV1beta1PodSecurityPolicy> {
    const response = await this.replacePodSecurityPolicyRaw(requestParameters)
    return await response.value()
  }
}
