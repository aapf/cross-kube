/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: release-1.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  RequestOpts,
  HTTPHeaders,
  HTTPQuery,
  ApiResponse,
  StringApiResponse,
  JSONApiResponse,
  ItemType,
  KubeEvent,
  request,
  requestStream
} from '../runtime'
import ExtensionsV1beta1Ingress from '../models/ExtensionsV1beta1Ingress'
import ExtensionsV1beta1IngressList from '../models/ExtensionsV1beta1IngressList'
import V1APIResourceList from '../models/V1APIResourceList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Status from '../models/V1Status'

interface CreateNamespacedIngressRequest {
  namespace: string

  body: ExtensionsV1beta1Ingress

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface DeleteCollectionNamespacedIngressRequest {
  namespace: string

  pretty?: string

  _continue?: string

  dryRun?: string

  fieldSelector?: string

  gracePeriodSeconds?: number

  labelSelector?: string

  limit?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number

  body?: V1DeleteOptions
}

interface DeleteNamespacedIngressRequest {
  name: string

  namespace: string

  pretty?: string

  dryRun?: string

  gracePeriodSeconds?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  body?: V1DeleteOptions
}

interface ListIngressForAllNamespacesRequest {
  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  pretty?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface ListNamespacedIngressRequest {
  namespace: string

  pretty?: string

  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface PatchNamespacedIngressRequest {
  name: string

  namespace: string

  body: object

  pretty?: string

  dryRun?: string

  fieldManager?: string

  force?: boolean
}

interface PatchNamespacedIngressStatusRequest {
  name: string

  namespace: string

  body: object

  pretty?: string

  dryRun?: string

  fieldManager?: string

  force?: boolean
}

interface ReadNamespacedIngressRequest {
  name: string

  namespace: string

  pretty?: string

  exact?: boolean

  _export?: boolean
}

interface ReadNamespacedIngressStatusRequest {
  name: string

  namespace: string

  pretty?: string
}

interface ReplaceNamespacedIngressRequest {
  name: string

  namespace: string

  body: ExtensionsV1beta1Ingress

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface ReplaceNamespacedIngressStatusRequest {
  name: string

  namespace: string

  body: ExtensionsV1beta1Ingress

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

/**
 * create an Ingress
 */
export async function createNamespacedIngressRaw(
  requestParameters: CreateNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedIngress.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create an Ingress
 */
export async function createNamespacedIngress(
  requestParameters: CreateNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await createNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of Ingress
 */
export async function deleteCollectionNamespacedIngressRaw(
  requestParameters: DeleteCollectionNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Ingress
 */
export async function deleteCollectionNamespacedIngress(
  requestParameters: DeleteCollectionNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedIngressRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete an Ingress
 */
export async function deleteNamespacedIngressRaw(
  requestParameters: DeleteNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete an Ingress
 */
export async function deleteNamespacedIngress(
  requestParameters: DeleteNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * get available resources
 */
export async function getAPIResourcesRaw(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1APIResourceList>> {
  const queryParameters: HTTPQuery = {}
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * get available resources
 */
export async function getAPIResources(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1APIResourceList> {
  const response = await getAPIResourcesRaw(...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Ingress
 */
export async function watchListIngressForAllNamespaces(
  requestParameters: ListIngressForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<ExtensionsV1beta1IngressList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<ExtensionsV1beta1IngressList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/ingresses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Ingress
 */
export async function listIngressForAllNamespacesRaw(
  requestParameters: ListIngressForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1IngressList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/ingresses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Ingress
 */
export async function listIngressForAllNamespaces(
  requestParameters: ListIngressForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1IngressList> {
  const response = await listIngressForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Ingress
 */
export async function watchListNamespacedIngress(
  requestParameters: ListNamespacedIngressRequest,
  callback: (event: KubeEvent<ItemType<ExtensionsV1beta1IngressList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<ExtensionsV1beta1IngressList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Ingress
 */
export async function listNamespacedIngressRaw(
  requestParameters: ListNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1IngressList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Ingress
 */
export async function listNamespacedIngress(
  requestParameters: ListNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1IngressList> {
  const response = await listNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Ingress
 */
export async function patchNamespacedIngressRaw(
  requestParameters: PatchNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedIngress.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Ingress
 */
export async function patchNamespacedIngress(
  requestParameters: PatchNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await patchNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Ingress
 */
export async function patchNamespacedIngressStatusRaw(
  requestParameters: PatchNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedIngressStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedIngressStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedIngressStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Ingress
 */
export async function patchNamespacedIngressStatus(
  requestParameters: PatchNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await patchNamespacedIngressStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Ingress
 */
export async function readNamespacedIngressRaw(
  requestParameters: ReadNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Ingress
 */
export async function readNamespacedIngress(
  requestParameters: ReadNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await readNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Ingress
 */
export async function readNamespacedIngressStatusRaw(
  requestParameters: ReadNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedIngressStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedIngressStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Ingress
 */
export async function readNamespacedIngressStatus(
  requestParameters: ReadNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await readNamespacedIngressStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Ingress
 */
export async function replaceNamespacedIngressRaw(
  requestParameters: ReplaceNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedIngress.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Ingress
 */
export async function replaceNamespacedIngress(
  requestParameters: ReplaceNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await replaceNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Ingress
 */
export async function replaceNamespacedIngressStatusRaw(
  requestParameters: ReplaceNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedIngressStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedIngressStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedIngressStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Ingress
 */
export async function replaceNamespacedIngressStatus(
  requestParameters: ReplaceNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await replaceNamespacedIngressStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}
