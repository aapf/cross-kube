// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.14.11
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  RequestOpts,
  HTTPHeaders,
  HTTPQuery,
  ApiResponse,
  StringApiResponse,
  JSONApiResponse,
  ItemType,
  KubeEvent,
  request,
  requestStream
} from '../runtime'
import ExtensionsV1beta1Deployment from '../models/ExtensionsV1beta1Deployment'
import ExtensionsV1beta1DeploymentList from '../models/ExtensionsV1beta1DeploymentList'
import ExtensionsV1beta1DeploymentRollback from '../models/ExtensionsV1beta1DeploymentRollback'
import ExtensionsV1beta1Ingress from '../models/ExtensionsV1beta1Ingress'
import ExtensionsV1beta1IngressList from '../models/ExtensionsV1beta1IngressList'
import ExtensionsV1beta1PodSecurityPolicy from '../models/ExtensionsV1beta1PodSecurityPolicy'
import ExtensionsV1beta1PodSecurityPolicyList from '../models/ExtensionsV1beta1PodSecurityPolicyList'
import ExtensionsV1beta1Scale from '../models/ExtensionsV1beta1Scale'
import V1APIResourceList from '../models/V1APIResourceList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Status from '../models/V1Status'
import V1beta1DaemonSet from '../models/V1beta1DaemonSet'
import V1beta1DaemonSetList from '../models/V1beta1DaemonSetList'
import V1beta1NetworkPolicy from '../models/V1beta1NetworkPolicy'
import V1beta1NetworkPolicyList from '../models/V1beta1NetworkPolicyList'
import V1beta1ReplicaSet from '../models/V1beta1ReplicaSet'
import V1beta1ReplicaSetList from '../models/V1beta1ReplicaSetList'

interface CreateNamespacedDaemonSetRequest {
  namespace: string
  body: V1beta1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDeploymentRequest {
  namespace: string
  body: ExtensionsV1beta1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDeploymentRollbackRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1DeploymentRollback
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedIngressRequest {
  namespace: string
  body: ExtensionsV1beta1Ingress
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedNetworkPolicyRequest {
  namespace: string
  body: V1beta1NetworkPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedReplicaSetRequest {
  namespace: string
  body: V1beta1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreatePodSecurityPolicyRequest {
  body: ExtensionsV1beta1PodSecurityPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface DeleteCollectionNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedIngressRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedNetworkPolicyRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionPodSecurityPolicyRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedIngressRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeletePodSecurityPolicyRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface ListDaemonSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListDeploymentForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListIngressForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedIngressRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedNetworkPolicyRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNetworkPolicyForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPodSecurityPolicyRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListReplicaSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface PatchNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedIngressRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedIngressStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerDummyScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchPodSecurityPolicyRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface ReadNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedIngressRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedIngressStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicationControllerDummyScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadPodSecurityPolicyRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReplaceNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: V1beta1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: V1beta1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedIngressRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Ingress
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedIngressStatusRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Ingress
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedNetworkPolicyRequest {
  name: string
  namespace: string
  body: V1beta1NetworkPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: V1beta1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: V1beta1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerDummyScaleRequest {
  name: string
  namespace: string
  body: ExtensionsV1beta1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplacePodSecurityPolicyRequest {
  name: string
  body: ExtensionsV1beta1PodSecurityPolicy
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

/**
 * create a DaemonSet
 */
export async function createNamespacedDaemonSetRaw(
  requestParameters: CreateNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSet>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDaemonSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a DaemonSet
 */
export async function createNamespacedDaemonSet(
  requestParameters: CreateNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSet> {
  const response = await createNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Deployment
 */
export async function createNamespacedDeploymentRaw(
  requestParameters: CreateNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Deployment>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDeployment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Deployment
 */
export async function createNamespacedDeployment(
  requestParameters: CreateNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Deployment> {
  const response = await createNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create rollback of a Deployment
 */
export async function createNamespacedDeploymentRollbackRaw(
  requestParameters: CreateNamespacedDeploymentRollbackRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling createNamespacedDeploymentRollback.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDeploymentRollback.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedDeploymentRollback.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create rollback of a Deployment
 */
export async function createNamespacedDeploymentRollback(
  requestParameters: CreateNamespacedDeploymentRollbackRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await createNamespacedDeploymentRollbackRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * create an Ingress
 */
export async function createNamespacedIngressRaw(
  requestParameters: CreateNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedIngress.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create an Ingress
 */
export async function createNamespacedIngress(
  requestParameters: CreateNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await createNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a NetworkPolicy
 */
export async function createNamespacedNetworkPolicyRaw(
  requestParameters: CreateNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1NetworkPolicy>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedNetworkPolicy.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a NetworkPolicy
 */
export async function createNamespacedNetworkPolicy(
  requestParameters: CreateNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1NetworkPolicy> {
  const response = await createNamespacedNetworkPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a ReplicaSet
 */
export async function createNamespacedReplicaSetRaw(
  requestParameters: CreateNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSet>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedReplicaSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ReplicaSet
 */
export async function createNamespacedReplicaSet(
  requestParameters: CreateNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSet> {
  const response = await createNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a PodSecurityPolicy
 */
export async function createPodSecurityPolicyRaw(
  requestParameters: CreatePodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createPodSecurityPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a PodSecurityPolicy
 */
export async function createPodSecurityPolicy(
  requestParameters: CreatePodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1PodSecurityPolicy> {
  const response = await createPodSecurityPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of DaemonSet
 */
export async function deleteCollectionNamespacedDaemonSetRaw(
  requestParameters: DeleteCollectionNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of DaemonSet
 */
export async function deleteCollectionNamespacedDaemonSet(
  requestParameters: DeleteCollectionNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedDaemonSetRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Deployment
 */
export async function deleteCollectionNamespacedDeploymentRaw(
  requestParameters: DeleteCollectionNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Deployment
 */
export async function deleteCollectionNamespacedDeployment(
  requestParameters: DeleteCollectionNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedDeploymentRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Ingress
 */
export async function deleteCollectionNamespacedIngressRaw(
  requestParameters: DeleteCollectionNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Ingress
 */
export async function deleteCollectionNamespacedIngress(
  requestParameters: DeleteCollectionNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedIngressRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of NetworkPolicy
 */
export async function deleteCollectionNamespacedNetworkPolicyRaw(
  requestParameters: DeleteCollectionNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of NetworkPolicy
 */
export async function deleteCollectionNamespacedNetworkPolicy(
  requestParameters: DeleteCollectionNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedNetworkPolicyRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of ReplicaSet
 */
export async function deleteCollectionNamespacedReplicaSetRaw(
  requestParameters: DeleteCollectionNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ReplicaSet
 */
export async function deleteCollectionNamespacedReplicaSet(
  requestParameters: DeleteCollectionNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedReplicaSetRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of PodSecurityPolicy
 */
export async function deleteCollectionPodSecurityPolicyRaw(
  requestParameters: DeleteCollectionPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of PodSecurityPolicy
 */
export async function deleteCollectionPodSecurityPolicy(
  requestParameters: DeleteCollectionPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionPodSecurityPolicyRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete a DaemonSet
 */
export async function deleteNamespacedDaemonSetRaw(
  requestParameters: DeleteNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a DaemonSet
 */
export async function deleteNamespacedDaemonSet(
  requestParameters: DeleteNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a Deployment
 */
export async function deleteNamespacedDeploymentRaw(
  requestParameters: DeleteNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Deployment
 */
export async function deleteNamespacedDeployment(
  requestParameters: DeleteNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete an Ingress
 */
export async function deleteNamespacedIngressRaw(
  requestParameters: DeleteNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete an Ingress
 */
export async function deleteNamespacedIngress(
  requestParameters: DeleteNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a NetworkPolicy
 */
export async function deleteNamespacedNetworkPolicyRaw(
  requestParameters: DeleteNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedNetworkPolicy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a NetworkPolicy
 */
export async function deleteNamespacedNetworkPolicy(
  requestParameters: DeleteNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedNetworkPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a ReplicaSet
 */
export async function deleteNamespacedReplicaSetRaw(
  requestParameters: DeleteNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ReplicaSet
 */
export async function deleteNamespacedReplicaSet(
  requestParameters: DeleteNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a PodSecurityPolicy
 */
export async function deletePodSecurityPolicyRaw(
  requestParameters: DeletePodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deletePodSecurityPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a PodSecurityPolicy
 */
export async function deletePodSecurityPolicy(
  requestParameters: DeletePodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deletePodSecurityPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * get available resources
 */
export async function getAPIResourcesRaw(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1APIResourceList>> {
  const queryParameters: HTTPQuery = {}
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * get available resources
 */
export async function getAPIResources(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1APIResourceList> {
  const response = await getAPIResourcesRaw(...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function watchListDaemonSetForAllNamespaces(
  requestParameters: ListDaemonSetForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1beta1DaemonSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1DaemonSetList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/daemonsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listDaemonSetForAllNamespacesRaw(
  requestParameters: ListDaemonSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSetList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/daemonsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listDaemonSetForAllNamespaces(
  requestParameters: ListDaemonSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSetList> {
  const response = await listDaemonSetForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Deployment
 */
export async function watchListDeploymentForAllNamespaces(
  requestParameters: ListDeploymentForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<ExtensionsV1beta1DeploymentList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<ExtensionsV1beta1DeploymentList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/deployments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Deployment
 */
export async function listDeploymentForAllNamespacesRaw(
  requestParameters: ListDeploymentForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1DeploymentList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/deployments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Deployment
 */
export async function listDeploymentForAllNamespaces(
  requestParameters: ListDeploymentForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1DeploymentList> {
  const response = await listDeploymentForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Ingress
 */
export async function watchListIngressForAllNamespaces(
  requestParameters: ListIngressForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<ExtensionsV1beta1IngressList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<ExtensionsV1beta1IngressList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/ingresses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Ingress
 */
export async function listIngressForAllNamespacesRaw(
  requestParameters: ListIngressForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1IngressList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/ingresses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Ingress
 */
export async function listIngressForAllNamespaces(
  requestParameters: ListIngressForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1IngressList> {
  const response = await listIngressForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function watchListNamespacedDaemonSet(
  requestParameters: ListNamespacedDaemonSetRequest,
  callback: (event: KubeEvent<ItemType<V1beta1DaemonSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1DaemonSetList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listNamespacedDaemonSetRaw(
  requestParameters: ListNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSetList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listNamespacedDaemonSet(
  requestParameters: ListNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSetList> {
  const response = await listNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Deployment
 */
export async function watchListNamespacedDeployment(
  requestParameters: ListNamespacedDeploymentRequest,
  callback: (event: KubeEvent<ItemType<ExtensionsV1beta1DeploymentList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<ExtensionsV1beta1DeploymentList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Deployment
 */
export async function listNamespacedDeploymentRaw(
  requestParameters: ListNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1DeploymentList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Deployment
 */
export async function listNamespacedDeployment(
  requestParameters: ListNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1DeploymentList> {
  const response = await listNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Ingress
 */
export async function watchListNamespacedIngress(
  requestParameters: ListNamespacedIngressRequest,
  callback: (event: KubeEvent<ItemType<ExtensionsV1beta1IngressList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<ExtensionsV1beta1IngressList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Ingress
 */
export async function listNamespacedIngressRaw(
  requestParameters: ListNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1IngressList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Ingress
 */
export async function listNamespacedIngress(
  requestParameters: ListNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1IngressList> {
  const response = await listNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind NetworkPolicy
 */
export async function watchListNamespacedNetworkPolicy(
  requestParameters: ListNamespacedNetworkPolicyRequest,
  callback: (event: KubeEvent<ItemType<V1beta1NetworkPolicyList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1NetworkPolicyList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind NetworkPolicy
 */
export async function listNamespacedNetworkPolicyRaw(
  requestParameters: ListNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1NetworkPolicyList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind NetworkPolicy
 */
export async function listNamespacedNetworkPolicy(
  requestParameters: ListNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1NetworkPolicyList> {
  const response = await listNamespacedNetworkPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function watchListNamespacedReplicaSet(
  requestParameters: ListNamespacedReplicaSetRequest,
  callback: (event: KubeEvent<ItemType<V1beta1ReplicaSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1ReplicaSetList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listNamespacedReplicaSetRaw(
  requestParameters: ListNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSetList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listNamespacedReplicaSet(
  requestParameters: ListNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSetList> {
  const response = await listNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind NetworkPolicy
 */
export async function watchListNetworkPolicyForAllNamespaces(
  requestParameters: ListNetworkPolicyForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1beta1NetworkPolicyList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1NetworkPolicyList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/networkpolicies`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind NetworkPolicy
 */
export async function listNetworkPolicyForAllNamespacesRaw(
  requestParameters: ListNetworkPolicyForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1NetworkPolicyList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/networkpolicies`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind NetworkPolicy
 */
export async function listNetworkPolicyForAllNamespaces(
  requestParameters: ListNetworkPolicyForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1NetworkPolicyList> {
  const response = await listNetworkPolicyForAllNamespacesRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind PodSecurityPolicy
 */
export async function watchListPodSecurityPolicy(
  requestParameters: ListPodSecurityPolicyRequest,
  callback: (event: KubeEvent<ItemType<ExtensionsV1beta1PodSecurityPolicyList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<ExtensionsV1beta1PodSecurityPolicyList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind PodSecurityPolicy
 */
export async function listPodSecurityPolicyRaw(
  requestParameters: ListPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1PodSecurityPolicyList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind PodSecurityPolicy
 */
export async function listPodSecurityPolicy(
  requestParameters: ListPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1PodSecurityPolicyList> {
  const response = await listPodSecurityPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function watchListReplicaSetForAllNamespaces(
  requestParameters: ListReplicaSetForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1beta1ReplicaSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1ReplicaSetList>>(
    callback,
    {
      path: `/apis/extensions/v1beta1/replicasets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listReplicaSetForAllNamespacesRaw(
  requestParameters: ListReplicaSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSetList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/replicasets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listReplicaSetForAllNamespaces(
  requestParameters: ListReplicaSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSetList> {
  const response = await listReplicaSetForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified DaemonSet
 */
export async function patchNamespacedDaemonSetRaw(
  requestParameters: PatchNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified DaemonSet
 */
export async function patchNamespacedDaemonSet(
  requestParameters: PatchNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSet> {
  const response = await patchNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified DaemonSet
 */
export async function patchNamespacedDaemonSetStatusRaw(
  requestParameters: PatchNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified DaemonSet
 */
export async function patchNamespacedDaemonSetStatus(
  requestParameters: PatchNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSet> {
  const response = await patchNamespacedDaemonSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Deployment
 */
export async function patchNamespacedDeploymentRaw(
  requestParameters: PatchNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeployment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Deployment
 */
export async function patchNamespacedDeployment(
  requestParameters: PatchNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Deployment> {
  const response = await patchNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update scale of the specified Deployment
 */
export async function patchNamespacedDeploymentScaleRaw(
  requestParameters: PatchNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update scale of the specified Deployment
 */
export async function patchNamespacedDeploymentScale(
  requestParameters: PatchNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await patchNamespacedDeploymentScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Deployment
 */
export async function patchNamespacedDeploymentStatusRaw(
  requestParameters: PatchNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Deployment
 */
export async function patchNamespacedDeploymentStatus(
  requestParameters: PatchNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Deployment> {
  const response = await patchNamespacedDeploymentStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Ingress
 */
export async function patchNamespacedIngressRaw(
  requestParameters: PatchNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedIngress.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Ingress
 */
export async function patchNamespacedIngress(
  requestParameters: PatchNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await patchNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Ingress
 */
export async function patchNamespacedIngressStatusRaw(
  requestParameters: PatchNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedIngressStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedIngressStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedIngressStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Ingress
 */
export async function patchNamespacedIngressStatus(
  requestParameters: PatchNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await patchNamespacedIngressStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified NetworkPolicy
 */
export async function patchNamespacedNetworkPolicyRaw(
  requestParameters: PatchNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1NetworkPolicy>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedNetworkPolicy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedNetworkPolicy.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified NetworkPolicy
 */
export async function patchNamespacedNetworkPolicy(
  requestParameters: PatchNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1NetworkPolicy> {
  const response = await patchNamespacedNetworkPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetRaw(
  requestParameters: PatchNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ReplicaSet
 */
export async function patchNamespacedReplicaSet(
  requestParameters: PatchNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSet> {
  const response = await patchNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update scale of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetScaleRaw(
  requestParameters: PatchNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update scale of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetScale(
  requestParameters: PatchNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await patchNamespacedReplicaSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetStatusRaw(
  requestParameters: PatchNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetStatus(
  requestParameters: PatchNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSet> {
  const response = await patchNamespacedReplicaSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update scale of the specified ReplicationControllerDummy
 */
export async function patchNamespacedReplicationControllerDummyScaleRaw(
  requestParameters: PatchNamespacedReplicationControllerDummyScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerDummyScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerDummyScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerDummyScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update scale of the specified ReplicationControllerDummy
 */
export async function patchNamespacedReplicationControllerDummyScale(
  requestParameters: PatchNamespacedReplicationControllerDummyScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await patchNamespacedReplicationControllerDummyScaleRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update the specified PodSecurityPolicy
 */
export async function patchPodSecurityPolicyRaw(
  requestParameters: PatchPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchPodSecurityPolicy.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchPodSecurityPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified PodSecurityPolicy
 */
export async function patchPodSecurityPolicy(
  requestParameters: PatchPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1PodSecurityPolicy> {
  const response = await patchPodSecurityPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified DaemonSet
 */
export async function readNamespacedDaemonSetRaw(
  requestParameters: ReadNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified DaemonSet
 */
export async function readNamespacedDaemonSet(
  requestParameters: ReadNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSet> {
  const response = await readNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified DaemonSet
 */
export async function readNamespacedDaemonSetStatusRaw(
  requestParameters: ReadNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified DaemonSet
 */
export async function readNamespacedDaemonSetStatus(
  requestParameters: ReadNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSet> {
  const response = await readNamespacedDaemonSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Deployment
 */
export async function readNamespacedDeploymentRaw(
  requestParameters: ReadNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Deployment
 */
export async function readNamespacedDeployment(
  requestParameters: ReadNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Deployment> {
  const response = await readNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read scale of the specified Deployment
 */
export async function readNamespacedDeploymentScaleRaw(
  requestParameters: ReadNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read scale of the specified Deployment
 */
export async function readNamespacedDeploymentScale(
  requestParameters: ReadNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await readNamespacedDeploymentScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Deployment
 */
export async function readNamespacedDeploymentStatusRaw(
  requestParameters: ReadNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Deployment
 */
export async function readNamespacedDeploymentStatus(
  requestParameters: ReadNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Deployment> {
  const response = await readNamespacedDeploymentStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Ingress
 */
export async function readNamespacedIngressRaw(
  requestParameters: ReadNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Ingress
 */
export async function readNamespacedIngress(
  requestParameters: ReadNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await readNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Ingress
 */
export async function readNamespacedIngressStatusRaw(
  requestParameters: ReadNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedIngressStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedIngressStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Ingress
 */
export async function readNamespacedIngressStatus(
  requestParameters: ReadNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await readNamespacedIngressStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified NetworkPolicy
 */
export async function readNamespacedNetworkPolicyRaw(
  requestParameters: ReadNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1NetworkPolicy>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedNetworkPolicy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified NetworkPolicy
 */
export async function readNamespacedNetworkPolicy(
  requestParameters: ReadNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1NetworkPolicy> {
  const response = await readNamespacedNetworkPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ReplicaSet
 */
export async function readNamespacedReplicaSetRaw(
  requestParameters: ReadNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ReplicaSet
 */
export async function readNamespacedReplicaSet(
  requestParameters: ReadNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSet> {
  const response = await readNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read scale of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetScaleRaw(
  requestParameters: ReadNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read scale of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetScale(
  requestParameters: ReadNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await readNamespacedReplicaSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetStatusRaw(
  requestParameters: ReadNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetStatus(
  requestParameters: ReadNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSet> {
  const response = await readNamespacedReplicaSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read scale of the specified ReplicationControllerDummy
 */
export async function readNamespacedReplicationControllerDummyScaleRaw(
  requestParameters: ReadNamespacedReplicationControllerDummyScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerDummyScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerDummyScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read scale of the specified ReplicationControllerDummy
 */
export async function readNamespacedReplicationControllerDummyScale(
  requestParameters: ReadNamespacedReplicationControllerDummyScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await readNamespacedReplicationControllerDummyScaleRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * read the specified PodSecurityPolicy
 */
export async function readPodSecurityPolicyRaw(
  requestParameters: ReadPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readPodSecurityPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified PodSecurityPolicy
 */
export async function readPodSecurityPolicy(
  requestParameters: ReadPodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1PodSecurityPolicy> {
  const response = await readPodSecurityPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified DaemonSet
 */
export async function replaceNamespacedDaemonSetRaw(
  requestParameters: ReplaceNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified DaemonSet
 */
export async function replaceNamespacedDaemonSet(
  requestParameters: ReplaceNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSet> {
  const response = await replaceNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified DaemonSet
 */
export async function replaceNamespacedDaemonSetStatusRaw(
  requestParameters: ReplaceNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified DaemonSet
 */
export async function replaceNamespacedDaemonSetStatus(
  requestParameters: ReplaceNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1DaemonSet> {
  const response = await replaceNamespacedDaemonSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Deployment
 */
export async function replaceNamespacedDeploymentRaw(
  requestParameters: ReplaceNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeployment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Deployment
 */
export async function replaceNamespacedDeployment(
  requestParameters: ReplaceNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Deployment> {
  const response = await replaceNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace scale of the specified Deployment
 */
export async function replaceNamespacedDeploymentScaleRaw(
  requestParameters: ReplaceNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace scale of the specified Deployment
 */
export async function replaceNamespacedDeploymentScale(
  requestParameters: ReplaceNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await replaceNamespacedDeploymentScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Deployment
 */
export async function replaceNamespacedDeploymentStatusRaw(
  requestParameters: ReplaceNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Deployment
 */
export async function replaceNamespacedDeploymentStatus(
  requestParameters: ReplaceNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Deployment> {
  const response = await replaceNamespacedDeploymentStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified Ingress
 */
export async function replaceNamespacedIngressRaw(
  requestParameters: ReplaceNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedIngress.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedIngress.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedIngress.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Ingress
 */
export async function replaceNamespacedIngress(
  requestParameters: ReplaceNamespacedIngressRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await replaceNamespacedIngressRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Ingress
 */
export async function replaceNamespacedIngressStatusRaw(
  requestParameters: ReplaceNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Ingress>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedIngressStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedIngressStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedIngressStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Ingress
 */
export async function replaceNamespacedIngressStatus(
  requestParameters: ReplaceNamespacedIngressStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Ingress> {
  const response = await replaceNamespacedIngressStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified NetworkPolicy
 */
export async function replaceNamespacedNetworkPolicyRaw(
  requestParameters: ReplaceNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1NetworkPolicy>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedNetworkPolicy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedNetworkPolicy.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedNetworkPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified NetworkPolicy
 */
export async function replaceNamespacedNetworkPolicy(
  requestParameters: ReplaceNamespacedNetworkPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1NetworkPolicy> {
  const response = await replaceNamespacedNetworkPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetRaw(
  requestParameters: ReplaceNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSet(
  requestParameters: ReplaceNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSet> {
  const response = await replaceNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace scale of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetScaleRaw(
  requestParameters: ReplaceNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace scale of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetScale(
  requestParameters: ReplaceNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await replaceNamespacedReplicaSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetStatusRaw(
  requestParameters: ReplaceNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetStatus(
  requestParameters: ReplaceNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1ReplicaSet> {
  const response = await replaceNamespacedReplicaSetStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace scale of the specified ReplicationControllerDummy
 */
export async function replaceNamespacedReplicationControllerDummyScaleRaw(
  requestParameters: ReplaceNamespacedReplicationControllerDummyScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace scale of the specified ReplicationControllerDummy
 */
export async function replaceNamespacedReplicationControllerDummyScale(
  requestParameters: ReplaceNamespacedReplicationControllerDummyScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1Scale> {
  const response = await replaceNamespacedReplicationControllerDummyScaleRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified PodSecurityPolicy
 */
export async function replacePodSecurityPolicyRaw(
  requestParameters: ReplacePodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<ExtensionsV1beta1PodSecurityPolicy>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replacePodSecurityPolicy.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replacePodSecurityPolicy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/extensions/v1beta1/podsecuritypolicies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified PodSecurityPolicy
 */
export async function replacePodSecurityPolicy(
  requestParameters: ReplacePodSecurityPolicyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ExtensionsV1beta1PodSecurityPolicy> {
  const response = await replacePodSecurityPolicyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}
