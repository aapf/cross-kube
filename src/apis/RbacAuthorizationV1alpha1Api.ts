/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: release-1.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  RequestOpts,
  HTTPHeaders,
  HTTPQuery,
  ApiResponse,
  StringApiResponse,
  JSONApiResponse,
  ItemType,
  KubeEvent,
  request,
  requestStream
} from '../runtime'
import V1APIResourceList from '../models/V1APIResourceList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Status from '../models/V1Status'
import V1alpha1ClusterRole from '../models/V1alpha1ClusterRole'
import V1alpha1ClusterRoleBinding from '../models/V1alpha1ClusterRoleBinding'
import V1alpha1ClusterRoleBindingList from '../models/V1alpha1ClusterRoleBindingList'
import V1alpha1ClusterRoleList from '../models/V1alpha1ClusterRoleList'
import V1alpha1Role from '../models/V1alpha1Role'
import V1alpha1RoleBinding from '../models/V1alpha1RoleBinding'
import V1alpha1RoleBindingList from '../models/V1alpha1RoleBindingList'
import V1alpha1RoleList from '../models/V1alpha1RoleList'

interface CreateClusterRoleRequest {
  body: V1alpha1ClusterRole

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface CreateClusterRoleBindingRequest {
  body: V1alpha1ClusterRoleBinding

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface CreateNamespacedRoleRequest {
  namespace: string

  body: V1alpha1Role

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface CreateNamespacedRoleBindingRequest {
  namespace: string

  body: V1alpha1RoleBinding

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface DeleteClusterRoleRequest {
  name: string

  pretty?: string

  dryRun?: string

  gracePeriodSeconds?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  body?: V1DeleteOptions
}

interface DeleteClusterRoleBindingRequest {
  name: string

  pretty?: string

  dryRun?: string

  gracePeriodSeconds?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  body?: V1DeleteOptions
}

interface DeleteCollectionClusterRoleRequest {
  pretty?: string

  _continue?: string

  dryRun?: string

  fieldSelector?: string

  gracePeriodSeconds?: number

  labelSelector?: string

  limit?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number

  body?: V1DeleteOptions
}

interface DeleteCollectionClusterRoleBindingRequest {
  pretty?: string

  _continue?: string

  dryRun?: string

  fieldSelector?: string

  gracePeriodSeconds?: number

  labelSelector?: string

  limit?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number

  body?: V1DeleteOptions
}

interface DeleteCollectionNamespacedRoleRequest {
  namespace: string

  pretty?: string

  _continue?: string

  dryRun?: string

  fieldSelector?: string

  gracePeriodSeconds?: number

  labelSelector?: string

  limit?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number

  body?: V1DeleteOptions
}

interface DeleteCollectionNamespacedRoleBindingRequest {
  namespace: string

  pretty?: string

  _continue?: string

  dryRun?: string

  fieldSelector?: string

  gracePeriodSeconds?: number

  labelSelector?: string

  limit?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number

  body?: V1DeleteOptions
}

interface DeleteNamespacedRoleRequest {
  name: string

  namespace: string

  pretty?: string

  dryRun?: string

  gracePeriodSeconds?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  body?: V1DeleteOptions
}

interface DeleteNamespacedRoleBindingRequest {
  name: string

  namespace: string

  pretty?: string

  dryRun?: string

  gracePeriodSeconds?: number

  orphanDependents?: boolean

  propagationPolicy?: string

  body?: V1DeleteOptions
}

interface ListClusterRoleRequest {
  pretty?: string

  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface ListClusterRoleBindingRequest {
  pretty?: string

  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface ListNamespacedRoleRequest {
  namespace: string

  pretty?: string

  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface ListNamespacedRoleBindingRequest {
  namespace: string

  pretty?: string

  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface ListRoleBindingForAllNamespacesRequest {
  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  pretty?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface ListRoleForAllNamespacesRequest {
  allowWatchBookmarks?: boolean

  _continue?: string

  fieldSelector?: string

  labelSelector?: string

  limit?: number

  pretty?: string

  resourceVersion?: string

  resourceVersionMatch?: string

  timeoutSeconds?: number
}

interface PatchClusterRoleRequest {
  name: string

  body: object

  pretty?: string

  dryRun?: string

  fieldManager?: string

  force?: boolean
}

interface PatchClusterRoleBindingRequest {
  name: string

  body: object

  pretty?: string

  dryRun?: string

  fieldManager?: string

  force?: boolean
}

interface PatchNamespacedRoleRequest {
  name: string

  namespace: string

  body: object

  pretty?: string

  dryRun?: string

  fieldManager?: string

  force?: boolean
}

interface PatchNamespacedRoleBindingRequest {
  name: string

  namespace: string

  body: object

  pretty?: string

  dryRun?: string

  fieldManager?: string

  force?: boolean
}

interface ReadClusterRoleRequest {
  name: string

  pretty?: string
}

interface ReadClusterRoleBindingRequest {
  name: string

  pretty?: string
}

interface ReadNamespacedRoleRequest {
  name: string

  namespace: string

  pretty?: string
}

interface ReadNamespacedRoleBindingRequest {
  name: string

  namespace: string

  pretty?: string
}

interface ReplaceClusterRoleRequest {
  name: string

  body: V1alpha1ClusterRole

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface ReplaceClusterRoleBindingRequest {
  name: string

  body: V1alpha1ClusterRoleBinding

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface ReplaceNamespacedRoleRequest {
  name: string

  namespace: string

  body: V1alpha1Role

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

interface ReplaceNamespacedRoleBindingRequest {
  name: string

  namespace: string

  body: V1alpha1RoleBinding

  pretty?: string

  dryRun?: string

  fieldManager?: string
}

/**
 * create a ClusterRole
 */
export async function createClusterRoleRaw(
  requestParameters: CreateClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRole>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createClusterRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ClusterRole
 */
export async function createClusterRole(
  requestParameters: CreateClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRole> {
  const response = await createClusterRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a ClusterRoleBinding
 */
export async function createClusterRoleBindingRaw(
  requestParameters: CreateClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRoleBinding>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createClusterRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ClusterRoleBinding
 */
export async function createClusterRoleBinding(
  requestParameters: CreateClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRoleBinding> {
  const response = await createClusterRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Role
 */
export async function createNamespacedRoleRaw(
  requestParameters: CreateNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1Role>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedRole.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Role
 */
export async function createNamespacedRole(
  requestParameters: CreateNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1Role> {
  const response = await createNamespacedRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a RoleBinding
 */
export async function createNamespacedRoleBindingRaw(
  requestParameters: CreateNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleBinding>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedRoleBinding.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a RoleBinding
 */
export async function createNamespacedRoleBinding(
  requestParameters: CreateNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleBinding> {
  const response = await createNamespacedRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a ClusterRole
 */
export async function deleteClusterRoleRaw(
  requestParameters: DeleteClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteClusterRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ClusterRole
 */
export async function deleteClusterRole(
  requestParameters: DeleteClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteClusterRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a ClusterRoleBinding
 */
export async function deleteClusterRoleBindingRaw(
  requestParameters: DeleteClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteClusterRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ClusterRoleBinding
 */
export async function deleteClusterRoleBinding(
  requestParameters: DeleteClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteClusterRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of ClusterRole
 */
export async function deleteCollectionClusterRoleRaw(
  requestParameters: DeleteCollectionClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ClusterRole
 */
export async function deleteCollectionClusterRole(
  requestParameters: DeleteCollectionClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionClusterRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of ClusterRoleBinding
 */
export async function deleteCollectionClusterRoleBindingRaw(
  requestParameters: DeleteCollectionClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ClusterRoleBinding
 */
export async function deleteCollectionClusterRoleBinding(
  requestParameters: DeleteCollectionClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionClusterRoleBindingRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Role
 */
export async function deleteCollectionNamespacedRoleRaw(
  requestParameters: DeleteCollectionNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Role
 */
export async function deleteCollectionNamespacedRole(
  requestParameters: DeleteCollectionNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of RoleBinding
 */
export async function deleteCollectionNamespacedRoleBindingRaw(
  requestParameters: DeleteCollectionNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of RoleBinding
 */
export async function deleteCollectionNamespacedRoleBinding(
  requestParameters: DeleteCollectionNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedRoleBindingRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete a Role
 */
export async function deleteNamespacedRoleRaw(
  requestParameters: DeleteNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedRole.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Role
 */
export async function deleteNamespacedRole(
  requestParameters: DeleteNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a RoleBinding
 */
export async function deleteNamespacedRoleBindingRaw(
  requestParameters: DeleteNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedRoleBinding.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a RoleBinding
 */
export async function deleteNamespacedRoleBinding(
  requestParameters: DeleteNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * get available resources
 */
export async function getAPIResourcesRaw(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1APIResourceList>> {
  const queryParameters: HTTPQuery = {}
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * get available resources
 */
export async function getAPIResources(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1APIResourceList> {
  const response = await getAPIResourcesRaw(...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ClusterRole
 */
export async function watchListClusterRole(
  requestParameters: ListClusterRoleRequest,
  callback: (event: KubeEvent<ItemType<V1alpha1ClusterRoleList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1alpha1ClusterRoleList>>(
    callback,
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ClusterRole
 */
export async function listClusterRoleRaw(
  requestParameters: ListClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRoleList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ClusterRole
 */
export async function listClusterRole(
  requestParameters: ListClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRoleList> {
  const response = await listClusterRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ClusterRoleBinding
 */
export async function watchListClusterRoleBinding(
  requestParameters: ListClusterRoleBindingRequest,
  callback: (event: KubeEvent<ItemType<V1alpha1ClusterRoleBindingList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1alpha1ClusterRoleBindingList>>(
    callback,
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ClusterRoleBinding
 */
export async function listClusterRoleBindingRaw(
  requestParameters: ListClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRoleBindingList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ClusterRoleBinding
 */
export async function listClusterRoleBinding(
  requestParameters: ListClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRoleBindingList> {
  const response = await listClusterRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Role
 */
export async function watchListNamespacedRole(
  requestParameters: ListNamespacedRoleRequest,
  callback: (event: KubeEvent<ItemType<V1alpha1RoleList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1alpha1RoleList>>(
    callback,
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Role
 */
export async function listNamespacedRoleRaw(
  requestParameters: ListNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Role
 */
export async function listNamespacedRole(
  requestParameters: ListNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleList> {
  const response = await listNamespacedRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind RoleBinding
 */
export async function watchListNamespacedRoleBinding(
  requestParameters: ListNamespacedRoleBindingRequest,
  callback: (event: KubeEvent<ItemType<V1alpha1RoleBindingList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1alpha1RoleBindingList>>(
    callback,
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind RoleBinding
 */
export async function listNamespacedRoleBindingRaw(
  requestParameters: ListNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleBindingList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind RoleBinding
 */
export async function listNamespacedRoleBinding(
  requestParameters: ListNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleBindingList> {
  const response = await listNamespacedRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind RoleBinding
 */
export async function watchListRoleBindingForAllNamespaces(
  requestParameters: ListRoleBindingForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1alpha1RoleBindingList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1alpha1RoleBindingList>>(
    callback,
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind RoleBinding
 */
export async function listRoleBindingForAllNamespacesRaw(
  requestParameters: ListRoleBindingForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleBindingList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind RoleBinding
 */
export async function listRoleBindingForAllNamespaces(
  requestParameters: ListRoleBindingForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleBindingList> {
  const response = await listRoleBindingForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Role
 */
export async function watchListRoleForAllNamespaces(
  requestParameters: ListRoleForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1alpha1RoleList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1alpha1RoleList>>(
    callback,
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/roles`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Role
 */
export async function listRoleForAllNamespacesRaw(
  requestParameters: ListRoleForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.allowWatchBookmarks !== undefined) {
    queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.resourceVersionMatch !== undefined) {
    queryParameters['resourceVersionMatch'] = requestParameters.resourceVersionMatch
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/roles`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Role
 */
export async function listRoleForAllNamespaces(
  requestParameters: ListRoleForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleList> {
  const response = await listRoleForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ClusterRole
 */
export async function patchClusterRoleRaw(
  requestParameters: PatchClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRole>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchClusterRole.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchClusterRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ClusterRole
 */
export async function patchClusterRole(
  requestParameters: PatchClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRole> {
  const response = await patchClusterRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ClusterRoleBinding
 */
export async function patchClusterRoleBindingRaw(
  requestParameters: PatchClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRoleBinding>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchClusterRoleBinding.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchClusterRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ClusterRoleBinding
 */
export async function patchClusterRoleBinding(
  requestParameters: PatchClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRoleBinding> {
  const response = await patchClusterRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Role
 */
export async function patchNamespacedRoleRaw(
  requestParameters: PatchNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1Role>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedRole.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedRole.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Role
 */
export async function patchNamespacedRole(
  requestParameters: PatchNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1Role> {
  const response = await patchNamespacedRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified RoleBinding
 */
export async function patchNamespacedRoleBindingRaw(
  requestParameters: PatchNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleBinding>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedRoleBinding.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedRoleBinding.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified RoleBinding
 */
export async function patchNamespacedRoleBinding(
  requestParameters: PatchNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleBinding> {
  const response = await patchNamespacedRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ClusterRole
 */
export async function readClusterRoleRaw(
  requestParameters: ReadClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRole>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readClusterRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ClusterRole
 */
export async function readClusterRole(
  requestParameters: ReadClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRole> {
  const response = await readClusterRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ClusterRoleBinding
 */
export async function readClusterRoleBindingRaw(
  requestParameters: ReadClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRoleBinding>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readClusterRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ClusterRoleBinding
 */
export async function readClusterRoleBinding(
  requestParameters: ReadClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRoleBinding> {
  const response = await readClusterRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Role
 */
export async function readNamespacedRoleRaw(
  requestParameters: ReadNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1Role>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedRole.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Role
 */
export async function readNamespacedRole(
  requestParameters: ReadNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1Role> {
  const response = await readNamespacedRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified RoleBinding
 */
export async function readNamespacedRoleBindingRaw(
  requestParameters: ReadNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleBinding>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedRoleBinding.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified RoleBinding
 */
export async function readNamespacedRoleBinding(
  requestParameters: ReadNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleBinding> {
  const response = await readNamespacedRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified ClusterRole
 */
export async function replaceClusterRoleRaw(
  requestParameters: ReplaceClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRole>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceClusterRole.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceClusterRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ClusterRole
 */
export async function replaceClusterRole(
  requestParameters: ReplaceClusterRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRole> {
  const response = await replaceClusterRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified ClusterRoleBinding
 */
export async function replaceClusterRoleBindingRaw(
  requestParameters: ReplaceClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1ClusterRoleBinding>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceClusterRoleBinding.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceClusterRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ClusterRoleBinding
 */
export async function replaceClusterRoleBinding(
  requestParameters: ReplaceClusterRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1ClusterRoleBinding> {
  const response = await replaceClusterRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Role
 */
export async function replaceNamespacedRoleRaw(
  requestParameters: ReplaceNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1Role>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedRole.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedRole.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedRole.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Role
 */
export async function replaceNamespacedRole(
  requestParameters: ReplaceNamespacedRoleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1Role> {
  const response = await replaceNamespacedRoleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified RoleBinding
 */
export async function replaceNamespacedRoleBindingRaw(
  requestParameters: ReplaceNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1alpha1RoleBinding>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedRoleBinding.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedRoleBinding.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedRoleBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified RoleBinding
 */
export async function replaceNamespacedRoleBinding(
  requestParameters: ReplaceNamespacedRoleBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1alpha1RoleBinding> {
  const response = await replaceNamespacedRoleBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}
