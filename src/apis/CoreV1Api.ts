// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.14.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import V1APIResourceList from '../models/V1APIResourceList'
import V1Binding from '../models/V1Binding'
import V1ComponentStatus from '../models/V1ComponentStatus'
import V1ComponentStatusList from '../models/V1ComponentStatusList'
import V1ConfigMap from '../models/V1ConfigMap'
import V1ConfigMapList from '../models/V1ConfigMapList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Endpoints from '../models/V1Endpoints'
import V1EndpointsList from '../models/V1EndpointsList'
import V1Event from '../models/V1Event'
import V1EventList from '../models/V1EventList'
import V1LimitRange from '../models/V1LimitRange'
import V1LimitRangeList from '../models/V1LimitRangeList'
import V1Namespace from '../models/V1Namespace'
import V1NamespaceList from '../models/V1NamespaceList'
import V1Node from '../models/V1Node'
import V1NodeList from '../models/V1NodeList'
import V1PersistentVolume from '../models/V1PersistentVolume'
import V1PersistentVolumeClaim from '../models/V1PersistentVolumeClaim'
import V1PersistentVolumeClaimList from '../models/V1PersistentVolumeClaimList'
import V1PersistentVolumeList from '../models/V1PersistentVolumeList'
import V1Pod from '../models/V1Pod'
import V1PodList from '../models/V1PodList'
import V1PodTemplate from '../models/V1PodTemplate'
import V1PodTemplateList from '../models/V1PodTemplateList'
import V1ReplicationController from '../models/V1ReplicationController'
import V1ReplicationControllerList from '../models/V1ReplicationControllerList'
import V1ResourceQuota from '../models/V1ResourceQuota'
import V1ResourceQuotaList from '../models/V1ResourceQuotaList'
import V1Scale from '../models/V1Scale'
import V1Secret from '../models/V1Secret'
import V1SecretList from '../models/V1SecretList'
import V1Service from '../models/V1Service'
import V1ServiceAccount from '../models/V1ServiceAccount'
import V1ServiceAccountList from '../models/V1ServiceAccountList'
import V1ServiceList from '../models/V1ServiceList'
import V1Status from '../models/V1Status'
import V1beta1Eviction from '../models/V1beta1Eviction'

interface ConnectDeleteNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectDeleteNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectDeleteNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectDeleteNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectDeleteNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectDeleteNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectGetNamespacedPodAttachRequest {
  name: string
  namespace: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectGetNamespacedPodExecRequest {
  name: string
  namespace: string
  command?: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectGetNamespacedPodPortforwardRequest {
  name: string
  namespace: string
  ports?: number
}

interface ConnectGetNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectGetNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectGetNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectGetNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectGetNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectGetNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectHeadNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectHeadNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectHeadNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectHeadNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectHeadNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectHeadNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectOptionsNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectOptionsNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectOptionsNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectOptionsNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectOptionsNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectOptionsNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectPatchNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPatchNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPatchNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPatchNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPatchNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectPatchNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectPostNamespacedPodAttachRequest {
  name: string
  namespace: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectPostNamespacedPodExecRequest {
  name: string
  namespace: string
  command?: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectPostNamespacedPodPortforwardRequest {
  name: string
  namespace: string
  ports?: number
}

interface ConnectPostNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPostNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPostNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPostNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPostNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectPostNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectPutNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPutNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPutNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPutNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPutNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectPutNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface CreateNamespaceRequest {
  body: V1Namespace
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedBindingRequest {
  namespace: string
  body: V1Binding
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedConfigMapRequest {
  namespace: string
  body: V1ConfigMap
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedEndpointsRequest {
  namespace: string
  body: V1Endpoints
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedEventRequest {
  namespace: string
  body: V1Event
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedLimitRangeRequest {
  namespace: string
  body: V1LimitRange
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedPersistentVolumeClaimRequest {
  namespace: string
  body: V1PersistentVolumeClaim
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedPodRequest {
  namespace: string
  body: V1Pod
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedPodBindingRequest {
  name: string
  namespace: string
  body: V1Binding
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedPodEvictionRequest {
  name: string
  namespace: string
  body: V1beta1Eviction
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedPodTemplateRequest {
  namespace: string
  body: V1PodTemplate
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedReplicationControllerRequest {
  namespace: string
  body: V1ReplicationController
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedResourceQuotaRequest {
  namespace: string
  body: V1ResourceQuota
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedSecretRequest {
  namespace: string
  body: V1Secret
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedServiceRequest {
  namespace: string
  body: V1Service
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedServiceAccountRequest {
  namespace: string
  body: V1ServiceAccount
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNodeRequest {
  body: V1Node
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreatePersistentVolumeRequest {
  body: V1PersistentVolume
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface DeleteCollectionNamespacedConfigMapRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedEndpointsRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedEventRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedLimitRangeRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedPersistentVolumeClaimRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedPodRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedPodTemplateRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedReplicationControllerRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedResourceQuotaRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedSecretRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedServiceAccountRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNodeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionPersistentVolumeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteNamespaceRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedConfigMapRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedEndpointsRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedEventRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedLimitRangeRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedPodRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedPodTemplateRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedSecretRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedServiceRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedServiceAccountRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNodeRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeletePersistentVolumeRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface ListComponentStatusRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListConfigMapForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListEndpointsForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListEventForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListLimitRangeForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespaceRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedConfigMapRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedEndpointsRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedEventRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedLimitRangeRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedPersistentVolumeClaimRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedPodRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedPodTemplateRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedReplicationControllerRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedResourceQuotaRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedSecretRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedServiceRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedServiceAccountRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNodeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPersistentVolumeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPersistentVolumeClaimForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPodForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPodTemplateForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListReplicationControllerForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListResourceQuotaForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListSecretForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListServiceAccountForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListServiceForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface PatchNamespaceRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespaceStatusRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedConfigMapRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedEndpointsRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedEventRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedLimitRangeRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPersistentVolumeClaimStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPodRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPodStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPodTemplateRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedResourceQuotaStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedSecretRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedServiceRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedServiceAccountRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedServiceStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNodeRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNodeStatusRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchPersistentVolumeRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchPersistentVolumeStatusRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface ReadComponentStatusRequest {
  name: string
  pretty?: string
}

interface ReadNamespaceRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespaceStatusRequest {
  name: string
  pretty?: string
}

interface ReadNamespacedConfigMapRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedEndpointsRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedEventRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedLimitRangeRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedPersistentVolumeClaimStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedPodRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedPodLogRequest {
  name: string
  namespace: string
  container?: string
  follow?: boolean
  limitBytes?: number
  pretty?: string
  previous?: boolean
  sinceSeconds?: number
  tailLines?: number
  timestamps?: boolean
}

interface ReadNamespacedPodStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedPodTemplateRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicationControllerScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicationControllerStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedResourceQuotaStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedSecretRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedServiceRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedServiceAccountRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedServiceStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNodeRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNodeStatusRequest {
  name: string
  pretty?: string
}

interface ReadPersistentVolumeRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadPersistentVolumeStatusRequest {
  name: string
  pretty?: string
}

interface ReplaceNamespaceRequest {
  name: string
  body: V1Namespace
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespaceFinalizeRequest {
  name: string
  body: V1Namespace
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface ReplaceNamespaceStatusRequest {
  name: string
  body: V1Namespace
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedConfigMapRequest {
  name: string
  namespace: string
  body: V1ConfigMap
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedEndpointsRequest {
  name: string
  namespace: string
  body: V1Endpoints
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedEventRequest {
  name: string
  namespace: string
  body: V1Event
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedLimitRangeRequest {
  name: string
  namespace: string
  body: V1LimitRange
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  body: V1PersistentVolumeClaim
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPersistentVolumeClaimStatusRequest {
  name: string
  namespace: string
  body: V1PersistentVolumeClaim
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPodRequest {
  name: string
  namespace: string
  body: V1Pod
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPodStatusRequest {
  name: string
  namespace: string
  body: V1Pod
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPodTemplateRequest {
  name: string
  namespace: string
  body: V1PodTemplate
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  body: V1ReplicationController
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerScaleRequest {
  name: string
  namespace: string
  body: V1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerStatusRequest {
  name: string
  namespace: string
  body: V1ReplicationController
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  body: V1ResourceQuota
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedResourceQuotaStatusRequest {
  name: string
  namespace: string
  body: V1ResourceQuota
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedSecretRequest {
  name: string
  namespace: string
  body: V1Secret
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedServiceRequest {
  name: string
  namespace: string
  body: V1Service
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedServiceAccountRequest {
  name: string
  namespace: string
  body: V1ServiceAccount
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedServiceStatusRequest {
  name: string
  namespace: string
  body: V1Service
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNodeRequest {
  name: string
  body: V1Node
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNodeStatusRequest {
  name: string
  body: V1Node
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplacePersistentVolumeRequest {
  name: string
  body: V1PersistentVolume
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplacePersistentVolumeStatusRequest {
  name: string
  body: V1PersistentVolume
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

/**
 *
 */
export default class CoreV1Api extends runtime.BaseAPI {
  /**
   * connect DELETE requests to proxy of Pod
   */
  async connectDeleteNamespacedPodProxyRaw(
    requestParameters: ConnectDeleteNamespacedPodProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedPodProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedPodProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect DELETE requests to proxy of Pod
   */
  async connectDeleteNamespacedPodProxy(
    requestParameters: ConnectDeleteNamespacedPodProxyRequest
  ): Promise<string> {
    const response = await this.connectDeleteNamespacedPodProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect DELETE requests to proxy of Pod
   */
  async connectDeleteNamespacedPodProxyWithPathRaw(
    requestParameters: ConnectDeleteNamespacedPodProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect DELETE requests to proxy of Pod
   */
  async connectDeleteNamespacedPodProxyWithPath(
    requestParameters: ConnectDeleteNamespacedPodProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectDeleteNamespacedPodProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect DELETE requests to proxy of Service
   */
  async connectDeleteNamespacedServiceProxyRaw(
    requestParameters: ConnectDeleteNamespacedServiceProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedServiceProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedServiceProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect DELETE requests to proxy of Service
   */
  async connectDeleteNamespacedServiceProxy(
    requestParameters: ConnectDeleteNamespacedServiceProxyRequest
  ): Promise<string> {
    const response = await this.connectDeleteNamespacedServiceProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect DELETE requests to proxy of Service
   */
  async connectDeleteNamespacedServiceProxyWithPathRaw(
    requestParameters: ConnectDeleteNamespacedServiceProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect DELETE requests to proxy of Service
   */
  async connectDeleteNamespacedServiceProxyWithPath(
    requestParameters: ConnectDeleteNamespacedServiceProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectDeleteNamespacedServiceProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect DELETE requests to proxy of Node
   */
  async connectDeleteNodeProxyRaw(
    requestParameters: ConnectDeleteNodeProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectDeleteNodeProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect DELETE requests to proxy of Node
   */
  async connectDeleteNodeProxy(requestParameters: ConnectDeleteNodeProxyRequest): Promise<string> {
    const response = await this.connectDeleteNodeProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect DELETE requests to proxy of Node
   */
  async connectDeleteNodeProxyWithPathRaw(
    requestParameters: ConnectDeleteNodeProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectDeleteNodeProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectDeleteNodeProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect DELETE requests to proxy of Node
   */
  async connectDeleteNodeProxyWithPath(
    requestParameters: ConnectDeleteNodeProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectDeleteNodeProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to attach of Pod
   */
  async connectGetNamespacedPodAttachRaw(
    requestParameters: ConnectGetNamespacedPodAttachRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodAttach.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodAttach.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.container !== undefined) {
      queryParameters['container'] = requestParameters.container
    }
    if (requestParameters.stderr !== undefined) {
      queryParameters['stderr'] = requestParameters.stderr
    }
    if (requestParameters.stdin !== undefined) {
      queryParameters['stdin'] = requestParameters.stdin
    }
    if (requestParameters.stdout !== undefined) {
      queryParameters['stdout'] = requestParameters.stdout
    }
    if (requestParameters.tty !== undefined) {
      queryParameters['tty'] = requestParameters.tty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to attach of Pod
   */
  async connectGetNamespacedPodAttach(
    requestParameters: ConnectGetNamespacedPodAttachRequest
  ): Promise<string> {
    const response = await this.connectGetNamespacedPodAttachRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to exec of Pod
   */
  async connectGetNamespacedPodExecRaw(
    requestParameters: ConnectGetNamespacedPodExecRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodExec.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodExec.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.command !== undefined) {
      queryParameters['command'] = requestParameters.command
    }
    if (requestParameters.container !== undefined) {
      queryParameters['container'] = requestParameters.container
    }
    if (requestParameters.stderr !== undefined) {
      queryParameters['stderr'] = requestParameters.stderr
    }
    if (requestParameters.stdin !== undefined) {
      queryParameters['stdin'] = requestParameters.stdin
    }
    if (requestParameters.stdout !== undefined) {
      queryParameters['stdout'] = requestParameters.stdout
    }
    if (requestParameters.tty !== undefined) {
      queryParameters['tty'] = requestParameters.tty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to exec of Pod
   */
  async connectGetNamespacedPodExec(
    requestParameters: ConnectGetNamespacedPodExecRequest
  ): Promise<string> {
    const response = await this.connectGetNamespacedPodExecRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to portforward of Pod
   */
  async connectGetNamespacedPodPortforwardRaw(
    requestParameters: ConnectGetNamespacedPodPortforwardRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodPortforward.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodPortforward.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.ports !== undefined) {
      queryParameters['ports'] = requestParameters.ports
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to portforward of Pod
   */
  async connectGetNamespacedPodPortforward(
    requestParameters: ConnectGetNamespacedPodPortforwardRequest
  ): Promise<string> {
    const response = await this.connectGetNamespacedPodPortforwardRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to proxy of Pod
   */
  async connectGetNamespacedPodProxyRaw(
    requestParameters: ConnectGetNamespacedPodProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to proxy of Pod
   */
  async connectGetNamespacedPodProxy(
    requestParameters: ConnectGetNamespacedPodProxyRequest
  ): Promise<string> {
    const response = await this.connectGetNamespacedPodProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to proxy of Pod
   */
  async connectGetNamespacedPodProxyWithPathRaw(
    requestParameters: ConnectGetNamespacedPodProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectGetNamespacedPodProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to proxy of Pod
   */
  async connectGetNamespacedPodProxyWithPath(
    requestParameters: ConnectGetNamespacedPodProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectGetNamespacedPodProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to proxy of Service
   */
  async connectGetNamespacedServiceProxyRaw(
    requestParameters: ConnectGetNamespacedServiceProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedServiceProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedServiceProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to proxy of Service
   */
  async connectGetNamespacedServiceProxy(
    requestParameters: ConnectGetNamespacedServiceProxyRequest
  ): Promise<string> {
    const response = await this.connectGetNamespacedServiceProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to proxy of Service
   */
  async connectGetNamespacedServiceProxyWithPathRaw(
    requestParameters: ConnectGetNamespacedServiceProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectGetNamespacedServiceProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to proxy of Service
   */
  async connectGetNamespacedServiceProxyWithPath(
    requestParameters: ConnectGetNamespacedServiceProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectGetNamespacedServiceProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to proxy of Node
   */
  async connectGetNodeProxyRaw(
    requestParameters: ConnectGetNodeProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNodeProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to proxy of Node
   */
  async connectGetNodeProxy(requestParameters: ConnectGetNodeProxyRequest): Promise<string> {
    const response = await this.connectGetNodeProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect GET requests to proxy of Node
   */
  async connectGetNodeProxyWithPathRaw(
    requestParameters: ConnectGetNodeProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectGetNodeProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectGetNodeProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect GET requests to proxy of Node
   */
  async connectGetNodeProxyWithPath(
    requestParameters: ConnectGetNodeProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectGetNodeProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect HEAD requests to proxy of Pod
   */
  async connectHeadNamespacedPodProxyRaw(
    requestParameters: ConnectHeadNamespacedPodProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedPodProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedPodProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect HEAD requests to proxy of Pod
   */
  async connectHeadNamespacedPodProxy(
    requestParameters: ConnectHeadNamespacedPodProxyRequest
  ): Promise<string> {
    const response = await this.connectHeadNamespacedPodProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect HEAD requests to proxy of Pod
   */
  async connectHeadNamespacedPodProxyWithPathRaw(
    requestParameters: ConnectHeadNamespacedPodProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectHeadNamespacedPodProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect HEAD requests to proxy of Pod
   */
  async connectHeadNamespacedPodProxyWithPath(
    requestParameters: ConnectHeadNamespacedPodProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectHeadNamespacedPodProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect HEAD requests to proxy of Service
   */
  async connectHeadNamespacedServiceProxyRaw(
    requestParameters: ConnectHeadNamespacedServiceProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedServiceProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedServiceProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect HEAD requests to proxy of Service
   */
  async connectHeadNamespacedServiceProxy(
    requestParameters: ConnectHeadNamespacedServiceProxyRequest
  ): Promise<string> {
    const response = await this.connectHeadNamespacedServiceProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect HEAD requests to proxy of Service
   */
  async connectHeadNamespacedServiceProxyWithPathRaw(
    requestParameters: ConnectHeadNamespacedServiceProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect HEAD requests to proxy of Service
   */
  async connectHeadNamespacedServiceProxyWithPath(
    requestParameters: ConnectHeadNamespacedServiceProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectHeadNamespacedServiceProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect HEAD requests to proxy of Node
   */
  async connectHeadNodeProxyRaw(
    requestParameters: ConnectHeadNodeProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectHeadNodeProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect HEAD requests to proxy of Node
   */
  async connectHeadNodeProxy(requestParameters: ConnectHeadNodeProxyRequest): Promise<string> {
    const response = await this.connectHeadNodeProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect HEAD requests to proxy of Node
   */
  async connectHeadNodeProxyWithPathRaw(
    requestParameters: ConnectHeadNodeProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectHeadNodeProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectHeadNodeProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect HEAD requests to proxy of Node
   */
  async connectHeadNodeProxyWithPath(
    requestParameters: ConnectHeadNodeProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectHeadNodeProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect OPTIONS requests to proxy of Pod
   */
  async connectOptionsNamespacedPodProxyRaw(
    requestParameters: ConnectOptionsNamespacedPodProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedPodProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedPodProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect OPTIONS requests to proxy of Pod
   */
  async connectOptionsNamespacedPodProxy(
    requestParameters: ConnectOptionsNamespacedPodProxyRequest
  ): Promise<string> {
    const response = await this.connectOptionsNamespacedPodProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect OPTIONS requests to proxy of Pod
   */
  async connectOptionsNamespacedPodProxyWithPathRaw(
    requestParameters: ConnectOptionsNamespacedPodProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect OPTIONS requests to proxy of Pod
   */
  async connectOptionsNamespacedPodProxyWithPath(
    requestParameters: ConnectOptionsNamespacedPodProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectOptionsNamespacedPodProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect OPTIONS requests to proxy of Service
   */
  async connectOptionsNamespacedServiceProxyRaw(
    requestParameters: ConnectOptionsNamespacedServiceProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedServiceProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedServiceProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect OPTIONS requests to proxy of Service
   */
  async connectOptionsNamespacedServiceProxy(
    requestParameters: ConnectOptionsNamespacedServiceProxyRequest
  ): Promise<string> {
    const response = await this.connectOptionsNamespacedServiceProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect OPTIONS requests to proxy of Service
   */
  async connectOptionsNamespacedServiceProxyWithPathRaw(
    requestParameters: ConnectOptionsNamespacedServiceProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect OPTIONS requests to proxy of Service
   */
  async connectOptionsNamespacedServiceProxyWithPath(
    requestParameters: ConnectOptionsNamespacedServiceProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectOptionsNamespacedServiceProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect OPTIONS requests to proxy of Node
   */
  async connectOptionsNodeProxyRaw(
    requestParameters: ConnectOptionsNodeProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectOptionsNodeProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect OPTIONS requests to proxy of Node
   */
  async connectOptionsNodeProxy(
    requestParameters: ConnectOptionsNodeProxyRequest
  ): Promise<string> {
    const response = await this.connectOptionsNodeProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect OPTIONS requests to proxy of Node
   */
  async connectOptionsNodeProxyWithPathRaw(
    requestParameters: ConnectOptionsNodeProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectOptionsNodeProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectOptionsNodeProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect OPTIONS requests to proxy of Node
   */
  async connectOptionsNodeProxyWithPath(
    requestParameters: ConnectOptionsNodeProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectOptionsNodeProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PATCH requests to proxy of Pod
   */
  async connectPatchNamespacedPodProxyRaw(
    requestParameters: ConnectPatchNamespacedPodProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedPodProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedPodProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PATCH requests to proxy of Pod
   */
  async connectPatchNamespacedPodProxy(
    requestParameters: ConnectPatchNamespacedPodProxyRequest
  ): Promise<string> {
    const response = await this.connectPatchNamespacedPodProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PATCH requests to proxy of Pod
   */
  async connectPatchNamespacedPodProxyWithPathRaw(
    requestParameters: ConnectPatchNamespacedPodProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPatchNamespacedPodProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PATCH requests to proxy of Pod
   */
  async connectPatchNamespacedPodProxyWithPath(
    requestParameters: ConnectPatchNamespacedPodProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPatchNamespacedPodProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PATCH requests to proxy of Service
   */
  async connectPatchNamespacedServiceProxyRaw(
    requestParameters: ConnectPatchNamespacedServiceProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedServiceProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedServiceProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PATCH requests to proxy of Service
   */
  async connectPatchNamespacedServiceProxy(
    requestParameters: ConnectPatchNamespacedServiceProxyRequest
  ): Promise<string> {
    const response = await this.connectPatchNamespacedServiceProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PATCH requests to proxy of Service
   */
  async connectPatchNamespacedServiceProxyWithPathRaw(
    requestParameters: ConnectPatchNamespacedServiceProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PATCH requests to proxy of Service
   */
  async connectPatchNamespacedServiceProxyWithPath(
    requestParameters: ConnectPatchNamespacedServiceProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPatchNamespacedServiceProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PATCH requests to proxy of Node
   */
  async connectPatchNodeProxyRaw(
    requestParameters: ConnectPatchNodeProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPatchNodeProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PATCH requests to proxy of Node
   */
  async connectPatchNodeProxy(requestParameters: ConnectPatchNodeProxyRequest): Promise<string> {
    const response = await this.connectPatchNodeProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PATCH requests to proxy of Node
   */
  async connectPatchNodeProxyWithPathRaw(
    requestParameters: ConnectPatchNodeProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPatchNodeProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPatchNodeProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PATCH requests to proxy of Node
   */
  async connectPatchNodeProxyWithPath(
    requestParameters: ConnectPatchNodeProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPatchNodeProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to attach of Pod
   */
  async connectPostNamespacedPodAttachRaw(
    requestParameters: ConnectPostNamespacedPodAttachRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodAttach.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodAttach.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.container !== undefined) {
      queryParameters['container'] = requestParameters.container
    }
    if (requestParameters.stderr !== undefined) {
      queryParameters['stderr'] = requestParameters.stderr
    }
    if (requestParameters.stdin !== undefined) {
      queryParameters['stdin'] = requestParameters.stdin
    }
    if (requestParameters.stdout !== undefined) {
      queryParameters['stdout'] = requestParameters.stdout
    }
    if (requestParameters.tty !== undefined) {
      queryParameters['tty'] = requestParameters.tty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to attach of Pod
   */
  async connectPostNamespacedPodAttach(
    requestParameters: ConnectPostNamespacedPodAttachRequest
  ): Promise<string> {
    const response = await this.connectPostNamespacedPodAttachRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to exec of Pod
   */
  async connectPostNamespacedPodExecRaw(
    requestParameters: ConnectPostNamespacedPodExecRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodExec.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodExec.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.command !== undefined) {
      queryParameters['command'] = requestParameters.command
    }
    if (requestParameters.container !== undefined) {
      queryParameters['container'] = requestParameters.container
    }
    if (requestParameters.stderr !== undefined) {
      queryParameters['stderr'] = requestParameters.stderr
    }
    if (requestParameters.stdin !== undefined) {
      queryParameters['stdin'] = requestParameters.stdin
    }
    if (requestParameters.stdout !== undefined) {
      queryParameters['stdout'] = requestParameters.stdout
    }
    if (requestParameters.tty !== undefined) {
      queryParameters['tty'] = requestParameters.tty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to exec of Pod
   */
  async connectPostNamespacedPodExec(
    requestParameters: ConnectPostNamespacedPodExecRequest
  ): Promise<string> {
    const response = await this.connectPostNamespacedPodExecRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to portforward of Pod
   */
  async connectPostNamespacedPodPortforwardRaw(
    requestParameters: ConnectPostNamespacedPodPortforwardRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodPortforward.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodPortforward.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.ports !== undefined) {
      queryParameters['ports'] = requestParameters.ports
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to portforward of Pod
   */
  async connectPostNamespacedPodPortforward(
    requestParameters: ConnectPostNamespacedPodPortforwardRequest
  ): Promise<string> {
    const response = await this.connectPostNamespacedPodPortforwardRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to proxy of Pod
   */
  async connectPostNamespacedPodProxyRaw(
    requestParameters: ConnectPostNamespacedPodProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to proxy of Pod
   */
  async connectPostNamespacedPodProxy(
    requestParameters: ConnectPostNamespacedPodProxyRequest
  ): Promise<string> {
    const response = await this.connectPostNamespacedPodProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to proxy of Pod
   */
  async connectPostNamespacedPodProxyWithPathRaw(
    requestParameters: ConnectPostNamespacedPodProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPostNamespacedPodProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to proxy of Pod
   */
  async connectPostNamespacedPodProxyWithPath(
    requestParameters: ConnectPostNamespacedPodProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPostNamespacedPodProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to proxy of Service
   */
  async connectPostNamespacedServiceProxyRaw(
    requestParameters: ConnectPostNamespacedServiceProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedServiceProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedServiceProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to proxy of Service
   */
  async connectPostNamespacedServiceProxy(
    requestParameters: ConnectPostNamespacedServiceProxyRequest
  ): Promise<string> {
    const response = await this.connectPostNamespacedServiceProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to proxy of Service
   */
  async connectPostNamespacedServiceProxyWithPathRaw(
    requestParameters: ConnectPostNamespacedServiceProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPostNamespacedServiceProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to proxy of Service
   */
  async connectPostNamespacedServiceProxyWithPath(
    requestParameters: ConnectPostNamespacedServiceProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPostNamespacedServiceProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to proxy of Node
   */
  async connectPostNodeProxyRaw(
    requestParameters: ConnectPostNodeProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNodeProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to proxy of Node
   */
  async connectPostNodeProxy(requestParameters: ConnectPostNodeProxyRequest): Promise<string> {
    const response = await this.connectPostNodeProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect POST requests to proxy of Node
   */
  async connectPostNodeProxyWithPathRaw(
    requestParameters: ConnectPostNodeProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPostNodeProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPostNodeProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect POST requests to proxy of Node
   */
  async connectPostNodeProxyWithPath(
    requestParameters: ConnectPostNodeProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPostNodeProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PUT requests to proxy of Pod
   */
  async connectPutNamespacedPodProxyRaw(
    requestParameters: ConnectPutNamespacedPodProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedPodProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedPodProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PUT requests to proxy of Pod
   */
  async connectPutNamespacedPodProxy(
    requestParameters: ConnectPutNamespacedPodProxyRequest
  ): Promise<string> {
    const response = await this.connectPutNamespacedPodProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PUT requests to proxy of Pod
   */
  async connectPutNamespacedPodProxyWithPathRaw(
    requestParameters: ConnectPutNamespacedPodProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedPodProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPutNamespacedPodProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PUT requests to proxy of Pod
   */
  async connectPutNamespacedPodProxyWithPath(
    requestParameters: ConnectPutNamespacedPodProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPutNamespacedPodProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PUT requests to proxy of Service
   */
  async connectPutNamespacedServiceProxyRaw(
    requestParameters: ConnectPutNamespacedServiceProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedServiceProxy.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedServiceProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PUT requests to proxy of Service
   */
  async connectPutNamespacedServiceProxy(
    requestParameters: ConnectPutNamespacedServiceProxyRequest
  ): Promise<string> {
    const response = await this.connectPutNamespacedServiceProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PUT requests to proxy of Service
   */
  async connectPutNamespacedServiceProxyWithPathRaw(
    requestParameters: ConnectPutNamespacedServiceProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedServiceProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPutNamespacedServiceProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PUT requests to proxy of Service
   */
  async connectPutNamespacedServiceProxyWithPath(
    requestParameters: ConnectPutNamespacedServiceProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPutNamespacedServiceProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PUT requests to proxy of Node
   */
  async connectPutNodeProxyRaw(
    requestParameters: ConnectPutNodeProxyRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPutNodeProxy.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path !== undefined) {
      queryParameters['path'] = requestParameters.path
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PUT requests to proxy of Node
   */
  async connectPutNodeProxy(requestParameters: ConnectPutNodeProxyRequest): Promise<string> {
    const response = await this.connectPutNodeProxyRaw(requestParameters)
    return await response.value()
  }

  /**
   * connect PUT requests to proxy of Node
   */
  async connectPutNodeProxyWithPathRaw(
    requestParameters: ConnectPutNodeProxyWithPathRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling connectPutNodeProxyWithPath.'
      )
    }
    if (requestParameters.path === null || requestParameters.path === undefined) {
      throw new Error(
        'Required parameter requestParameters.path was null or undefined when calling connectPutNodeProxyWithPath.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.path2 !== undefined) {
      queryParameters['path'] = requestParameters.path2
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * connect PUT requests to proxy of Node
   */
  async connectPutNodeProxyWithPath(
    requestParameters: ConnectPutNodeProxyWithPathRequest
  ): Promise<string> {
    const response = await this.connectPutNodeProxyWithPathRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Namespace
   */
  async createNamespaceRaw(
    requestParameters: CreateNamespaceRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespace.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Namespace
   */
  async createNamespace(requestParameters: CreateNamespaceRequest): Promise<V1Namespace> {
    const response = await this.createNamespaceRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Binding
   */
  async createNamespacedBindingRaw(
    requestParameters: CreateNamespacedBindingRequest
  ): Promise<runtime.ApiResponse<V1Binding>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedBinding.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedBinding.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/bindings`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Binding
   */
  async createNamespacedBinding(
    requestParameters: CreateNamespacedBindingRequest
  ): Promise<V1Binding> {
    const response = await this.createNamespacedBindingRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a ConfigMap
   */
  async createNamespacedConfigMapRaw(
    requestParameters: CreateNamespacedConfigMapRequest
  ): Promise<runtime.ApiResponse<V1ConfigMap>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedConfigMap.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a ConfigMap
   */
  async createNamespacedConfigMap(
    requestParameters: CreateNamespacedConfigMapRequest
  ): Promise<V1ConfigMap> {
    const response = await this.createNamespacedConfigMapRaw(requestParameters)
    return await response.value()
  }

  /**
   * create Endpoints
   */
  async createNamespacedEndpointsRaw(
    requestParameters: CreateNamespacedEndpointsRequest
  ): Promise<runtime.ApiResponse<V1Endpoints>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedEndpoints.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create Endpoints
   */
  async createNamespacedEndpoints(
    requestParameters: CreateNamespacedEndpointsRequest
  ): Promise<V1Endpoints> {
    const response = await this.createNamespacedEndpointsRaw(requestParameters)
    return await response.value()
  }

  /**
   * create an Event
   */
  async createNamespacedEventRaw(
    requestParameters: CreateNamespacedEventRequest
  ): Promise<runtime.ApiResponse<V1Event>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedEvent.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/events`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create an Event
   */
  async createNamespacedEvent(requestParameters: CreateNamespacedEventRequest): Promise<V1Event> {
    const response = await this.createNamespacedEventRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a LimitRange
   */
  async createNamespacedLimitRangeRaw(
    requestParameters: CreateNamespacedLimitRangeRequest
  ): Promise<runtime.ApiResponse<V1LimitRange>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedLimitRange.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a LimitRange
   */
  async createNamespacedLimitRange(
    requestParameters: CreateNamespacedLimitRangeRequest
  ): Promise<V1LimitRange> {
    const response = await this.createNamespacedLimitRangeRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a PersistentVolumeClaim
   */
  async createNamespacedPersistentVolumeClaimRaw(
    requestParameters: CreateNamespacedPersistentVolumeClaimRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPersistentVolumeClaim.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a PersistentVolumeClaim
   */
  async createNamespacedPersistentVolumeClaim(
    requestParameters: CreateNamespacedPersistentVolumeClaimRequest
  ): Promise<V1PersistentVolumeClaim> {
    const response = await this.createNamespacedPersistentVolumeClaimRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Pod
   */
  async createNamespacedPodRaw(
    requestParameters: CreateNamespacedPodRequest
  ): Promise<runtime.ApiResponse<V1Pod>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPod.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Pod
   */
  async createNamespacedPod(requestParameters: CreateNamespacedPodRequest): Promise<V1Pod> {
    const response = await this.createNamespacedPodRaw(requestParameters)
    return await response.value()
  }

  /**
   * create binding of a Pod
   */
  async createNamespacedPodBindingRaw(
    requestParameters: CreateNamespacedPodBindingRequest
  ): Promise<runtime.ApiResponse<V1Binding>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling createNamespacedPodBinding.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodBinding.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedPodBinding.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/binding`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create binding of a Pod
   */
  async createNamespacedPodBinding(
    requestParameters: CreateNamespacedPodBindingRequest
  ): Promise<V1Binding> {
    const response = await this.createNamespacedPodBindingRaw(requestParameters)
    return await response.value()
  }

  /**
   * create eviction of a Pod
   */
  async createNamespacedPodEvictionRaw(
    requestParameters: CreateNamespacedPodEvictionRequest
  ): Promise<runtime.ApiResponse<V1beta1Eviction>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling createNamespacedPodEviction.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodEviction.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedPodEviction.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/eviction`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create eviction of a Pod
   */
  async createNamespacedPodEviction(
    requestParameters: CreateNamespacedPodEvictionRequest
  ): Promise<V1beta1Eviction> {
    const response = await this.createNamespacedPodEvictionRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a PodTemplate
   */
  async createNamespacedPodTemplateRaw(
    requestParameters: CreateNamespacedPodTemplateRequest
  ): Promise<runtime.ApiResponse<V1PodTemplate>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodTemplate.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a PodTemplate
   */
  async createNamespacedPodTemplate(
    requestParameters: CreateNamespacedPodTemplateRequest
  ): Promise<V1PodTemplate> {
    const response = await this.createNamespacedPodTemplateRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a ReplicationController
   */
  async createNamespacedReplicationControllerRaw(
    requestParameters: CreateNamespacedReplicationControllerRequest
  ): Promise<runtime.ApiResponse<V1ReplicationController>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedReplicationController.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a ReplicationController
   */
  async createNamespacedReplicationController(
    requestParameters: CreateNamespacedReplicationControllerRequest
  ): Promise<V1ReplicationController> {
    const response = await this.createNamespacedReplicationControllerRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a ResourceQuota
   */
  async createNamespacedResourceQuotaRaw(
    requestParameters: CreateNamespacedResourceQuotaRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuota>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedResourceQuota.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a ResourceQuota
   */
  async createNamespacedResourceQuota(
    requestParameters: CreateNamespacedResourceQuotaRequest
  ): Promise<V1ResourceQuota> {
    const response = await this.createNamespacedResourceQuotaRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Secret
   */
  async createNamespacedSecretRaw(
    requestParameters: CreateNamespacedSecretRequest
  ): Promise<runtime.ApiResponse<V1Secret>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedSecret.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/secrets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Secret
   */
  async createNamespacedSecret(
    requestParameters: CreateNamespacedSecretRequest
  ): Promise<V1Secret> {
    const response = await this.createNamespacedSecretRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Service
   */
  async createNamespacedServiceRaw(
    requestParameters: CreateNamespacedServiceRequest
  ): Promise<runtime.ApiResponse<V1Service>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedService.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedService.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Service
   */
  async createNamespacedService(
    requestParameters: CreateNamespacedServiceRequest
  ): Promise<V1Service> {
    const response = await this.createNamespacedServiceRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a ServiceAccount
   */
  async createNamespacedServiceAccountRaw(
    requestParameters: CreateNamespacedServiceAccountRequest
  ): Promise<runtime.ApiResponse<V1ServiceAccount>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedServiceAccount.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a ServiceAccount
   */
  async createNamespacedServiceAccount(
    requestParameters: CreateNamespacedServiceAccountRequest
  ): Promise<V1ServiceAccount> {
    const response = await this.createNamespacedServiceAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Node
   */
  async createNodeRaw(requestParameters: CreateNodeRequest): Promise<runtime.ApiResponse<V1Node>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNode.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Node
   */
  async createNode(requestParameters: CreateNodeRequest): Promise<V1Node> {
    const response = await this.createNodeRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a PersistentVolume
   */
  async createPersistentVolumeRaw(
    requestParameters: CreatePersistentVolumeRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolume>> {
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createPersistentVolume.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a PersistentVolume
   */
  async createPersistentVolume(
    requestParameters: CreatePersistentVolumeRequest
  ): Promise<V1PersistentVolume> {
    const response = await this.createPersistentVolumeRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of ConfigMap
   */
  async deleteCollectionNamespacedConfigMapRaw(
    requestParameters: DeleteCollectionNamespacedConfigMapRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of ConfigMap
   */
  async deleteCollectionNamespacedConfigMap(
    requestParameters: DeleteCollectionNamespacedConfigMapRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedConfigMapRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of Endpoints
   */
  async deleteCollectionNamespacedEndpointsRaw(
    requestParameters: DeleteCollectionNamespacedEndpointsRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Endpoints
   */
  async deleteCollectionNamespacedEndpoints(
    requestParameters: DeleteCollectionNamespacedEndpointsRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedEndpointsRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of Event
   */
  async deleteCollectionNamespacedEventRaw(
    requestParameters: DeleteCollectionNamespacedEventRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/events`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Event
   */
  async deleteCollectionNamespacedEvent(
    requestParameters: DeleteCollectionNamespacedEventRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedEventRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of LimitRange
   */
  async deleteCollectionNamespacedLimitRangeRaw(
    requestParameters: DeleteCollectionNamespacedLimitRangeRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of LimitRange
   */
  async deleteCollectionNamespacedLimitRange(
    requestParameters: DeleteCollectionNamespacedLimitRangeRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedLimitRangeRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of PersistentVolumeClaim
   */
  async deleteCollectionNamespacedPersistentVolumeClaimRaw(
    requestParameters: DeleteCollectionNamespacedPersistentVolumeClaimRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of PersistentVolumeClaim
   */
  async deleteCollectionNamespacedPersistentVolumeClaim(
    requestParameters: DeleteCollectionNamespacedPersistentVolumeClaimRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedPersistentVolumeClaimRaw(
      requestParameters
    )
    return await response.value()
  }

  /**
   * delete collection of Pod
   */
  async deleteCollectionNamespacedPodRaw(
    requestParameters: DeleteCollectionNamespacedPodRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Pod
   */
  async deleteCollectionNamespacedPod(
    requestParameters: DeleteCollectionNamespacedPodRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedPodRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of PodTemplate
   */
  async deleteCollectionNamespacedPodTemplateRaw(
    requestParameters: DeleteCollectionNamespacedPodTemplateRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of PodTemplate
   */
  async deleteCollectionNamespacedPodTemplate(
    requestParameters: DeleteCollectionNamespacedPodTemplateRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedPodTemplateRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of ReplicationController
   */
  async deleteCollectionNamespacedReplicationControllerRaw(
    requestParameters: DeleteCollectionNamespacedReplicationControllerRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of ReplicationController
   */
  async deleteCollectionNamespacedReplicationController(
    requestParameters: DeleteCollectionNamespacedReplicationControllerRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedReplicationControllerRaw(
      requestParameters
    )
    return await response.value()
  }

  /**
   * delete collection of ResourceQuota
   */
  async deleteCollectionNamespacedResourceQuotaRaw(
    requestParameters: DeleteCollectionNamespacedResourceQuotaRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of ResourceQuota
   */
  async deleteCollectionNamespacedResourceQuota(
    requestParameters: DeleteCollectionNamespacedResourceQuotaRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedResourceQuotaRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of Secret
   */
  async deleteCollectionNamespacedSecretRaw(
    requestParameters: DeleteCollectionNamespacedSecretRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/secrets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Secret
   */
  async deleteCollectionNamespacedSecret(
    requestParameters: DeleteCollectionNamespacedSecretRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedSecretRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of ServiceAccount
   */
  async deleteCollectionNamespacedServiceAccountRaw(
    requestParameters: DeleteCollectionNamespacedServiceAccountRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of ServiceAccount
   */
  async deleteCollectionNamespacedServiceAccount(
    requestParameters: DeleteCollectionNamespacedServiceAccountRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedServiceAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of Node
   */
  async deleteCollectionNodeRaw(
    requestParameters: DeleteCollectionNodeRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Node
   */
  async deleteCollectionNode(requestParameters: DeleteCollectionNodeRequest): Promise<V1Status> {
    const response = await this.deleteCollectionNodeRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of PersistentVolume
   */
  async deleteCollectionPersistentVolumeRaw(
    requestParameters: DeleteCollectionPersistentVolumeRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of PersistentVolume
   */
  async deleteCollectionPersistentVolume(
    requestParameters: DeleteCollectionPersistentVolumeRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionPersistentVolumeRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a Namespace
   */
  async deleteNamespaceRaw(
    requestParameters: DeleteNamespaceRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespace.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a Namespace
   */
  async deleteNamespace(requestParameters: DeleteNamespaceRequest): Promise<V1Status> {
    const response = await this.deleteNamespaceRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a ConfigMap
   */
  async deleteNamespacedConfigMapRaw(
    requestParameters: DeleteNamespacedConfigMapRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedConfigMap.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a ConfigMap
   */
  async deleteNamespacedConfigMap(
    requestParameters: DeleteNamespacedConfigMapRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedConfigMapRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete Endpoints
   */
  async deleteNamespacedEndpointsRaw(
    requestParameters: DeleteNamespacedEndpointsRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedEndpoints.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete Endpoints
   */
  async deleteNamespacedEndpoints(
    requestParameters: DeleteNamespacedEndpointsRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedEndpointsRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete an Event
   */
  async deleteNamespacedEventRaw(
    requestParameters: DeleteNamespacedEventRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedEvent.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete an Event
   */
  async deleteNamespacedEvent(requestParameters: DeleteNamespacedEventRequest): Promise<V1Status> {
    const response = await this.deleteNamespacedEventRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a LimitRange
   */
  async deleteNamespacedLimitRangeRaw(
    requestParameters: DeleteNamespacedLimitRangeRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedLimitRange.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a LimitRange
   */
  async deleteNamespacedLimitRange(
    requestParameters: DeleteNamespacedLimitRangeRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedLimitRangeRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a PersistentVolumeClaim
   */
  async deleteNamespacedPersistentVolumeClaimRaw(
    requestParameters: DeleteNamespacedPersistentVolumeClaimRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPersistentVolumeClaim.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a PersistentVolumeClaim
   */
  async deleteNamespacedPersistentVolumeClaim(
    requestParameters: DeleteNamespacedPersistentVolumeClaimRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedPersistentVolumeClaimRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a Pod
   */
  async deleteNamespacedPodRaw(
    requestParameters: DeleteNamespacedPodRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPod.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a Pod
   */
  async deleteNamespacedPod(requestParameters: DeleteNamespacedPodRequest): Promise<V1Status> {
    const response = await this.deleteNamespacedPodRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a PodTemplate
   */
  async deleteNamespacedPodTemplateRaw(
    requestParameters: DeleteNamespacedPodTemplateRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPodTemplate.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a PodTemplate
   */
  async deleteNamespacedPodTemplate(
    requestParameters: DeleteNamespacedPodTemplateRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedPodTemplateRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a ReplicationController
   */
  async deleteNamespacedReplicationControllerRaw(
    requestParameters: DeleteNamespacedReplicationControllerRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedReplicationController.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a ReplicationController
   */
  async deleteNamespacedReplicationController(
    requestParameters: DeleteNamespacedReplicationControllerRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedReplicationControllerRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a ResourceQuota
   */
  async deleteNamespacedResourceQuotaRaw(
    requestParameters: DeleteNamespacedResourceQuotaRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedResourceQuota.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a ResourceQuota
   */
  async deleteNamespacedResourceQuota(
    requestParameters: DeleteNamespacedResourceQuotaRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedResourceQuotaRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a Secret
   */
  async deleteNamespacedSecretRaw(
    requestParameters: DeleteNamespacedSecretRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedSecret.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a Secret
   */
  async deleteNamespacedSecret(
    requestParameters: DeleteNamespacedSecretRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedSecretRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a Service
   */
  async deleteNamespacedServiceRaw(
    requestParameters: DeleteNamespacedServiceRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedService.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedService.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a Service
   */
  async deleteNamespacedService(
    requestParameters: DeleteNamespacedServiceRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedServiceRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a ServiceAccount
   */
  async deleteNamespacedServiceAccountRaw(
    requestParameters: DeleteNamespacedServiceAccountRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedServiceAccount.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a ServiceAccount
   */
  async deleteNamespacedServiceAccount(
    requestParameters: DeleteNamespacedServiceAccountRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedServiceAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a Node
   */
  async deleteNodeRaw(
    requestParameters: DeleteNodeRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNode.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a Node
   */
  async deleteNode(requestParameters: DeleteNodeRequest): Promise<V1Status> {
    const response = await this.deleteNodeRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a PersistentVolume
   */
  async deletePersistentVolumeRaw(
    requestParameters: DeletePersistentVolumeRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deletePersistentVolume.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a PersistentVolume
   */
  async deletePersistentVolume(
    requestParameters: DeletePersistentVolumeRequest
  ): Promise<V1Status> {
    const response = await this.deletePersistentVolumeRaw(requestParameters)
    return await response.value()
  }

  /**
   * get available resources
   */
  async getAPIResourcesRaw(): Promise<runtime.ApiResponse<V1APIResourceList>> {
    const queryParameters: runtime.HTTPQuery = {}
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * get available resources
   */
  async getAPIResources(): Promise<V1APIResourceList> {
    const response = await this.getAPIResourcesRaw()
    return await response.value()
  }

  /**
   * list objects of kind ComponentStatus
   */
  async watchListComponentStatus(
    requestParameters: ListComponentStatusRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ComponentStatusList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ComponentStatusList>>(
      {
        path: `/api/v1/componentstatuses`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list objects of kind ComponentStatus
   */
  async listComponentStatusRaw(
    requestParameters: ListComponentStatusRequest
  ): Promise<runtime.ApiResponse<V1ComponentStatusList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/componentstatuses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list objects of kind ComponentStatus
   */
  async listComponentStatus(
    requestParameters: ListComponentStatusRequest
  ): Promise<V1ComponentStatusList> {
    const response = await this.listComponentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ConfigMap
   */
  async watchListConfigMapForAllNamespaces(
    requestParameters: ListConfigMapForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ConfigMapList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ConfigMapList>>(
      {
        path: `/api/v1/configmaps`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ConfigMap
   */
  async listConfigMapForAllNamespacesRaw(
    requestParameters: ListConfigMapForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1ConfigMapList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/configmaps`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ConfigMap
   */
  async listConfigMapForAllNamespaces(
    requestParameters: ListConfigMapForAllNamespacesRequest
  ): Promise<V1ConfigMapList> {
    const response = await this.listConfigMapForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Endpoints
   */
  async watchListEndpointsForAllNamespaces(
    requestParameters: ListEndpointsForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1EndpointsList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1EndpointsList>>(
      {
        path: `/api/v1/endpoints`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Endpoints
   */
  async listEndpointsForAllNamespacesRaw(
    requestParameters: ListEndpointsForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1EndpointsList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/endpoints`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Endpoints
   */
  async listEndpointsForAllNamespaces(
    requestParameters: ListEndpointsForAllNamespacesRequest
  ): Promise<V1EndpointsList> {
    const response = await this.listEndpointsForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Event
   */
  async watchListEventForAllNamespaces(
    requestParameters: ListEventForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1EventList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1EventList>>(
      {
        path: `/api/v1/events`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Event
   */
  async listEventForAllNamespacesRaw(
    requestParameters: ListEventForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1EventList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/events`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Event
   */
  async listEventForAllNamespaces(
    requestParameters: ListEventForAllNamespacesRequest
  ): Promise<V1EventList> {
    const response = await this.listEventForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind LimitRange
   */
  async watchListLimitRangeForAllNamespaces(
    requestParameters: ListLimitRangeForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1LimitRangeList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1LimitRangeList>>(
      {
        path: `/api/v1/limitranges`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind LimitRange
   */
  async listLimitRangeForAllNamespacesRaw(
    requestParameters: ListLimitRangeForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1LimitRangeList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/limitranges`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind LimitRange
   */
  async listLimitRangeForAllNamespaces(
    requestParameters: ListLimitRangeForAllNamespacesRequest
  ): Promise<V1LimitRangeList> {
    const response = await this.listLimitRangeForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Namespace
   */
  async watchListNamespace(
    requestParameters: ListNamespaceRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1NamespaceList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1NamespaceList>>(
      {
        path: `/api/v1/namespaces`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Namespace
   */
  async listNamespaceRaw(
    requestParameters: ListNamespaceRequest
  ): Promise<runtime.ApiResponse<V1NamespaceList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Namespace
   */
  async listNamespace(requestParameters: ListNamespaceRequest): Promise<V1NamespaceList> {
    const response = await this.listNamespaceRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ConfigMap
   */
  async watchListNamespacedConfigMap(
    requestParameters: ListNamespacedConfigMapRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ConfigMapList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ConfigMapList>>(
      {
        path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ConfigMap
   */
  async listNamespacedConfigMapRaw(
    requestParameters: ListNamespacedConfigMapRequest
  ): Promise<runtime.ApiResponse<V1ConfigMapList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ConfigMap
   */
  async listNamespacedConfigMap(
    requestParameters: ListNamespacedConfigMapRequest
  ): Promise<V1ConfigMapList> {
    const response = await this.listNamespacedConfigMapRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Endpoints
   */
  async watchListNamespacedEndpoints(
    requestParameters: ListNamespacedEndpointsRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1EndpointsList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1EndpointsList>>(
      {
        path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Endpoints
   */
  async listNamespacedEndpointsRaw(
    requestParameters: ListNamespacedEndpointsRequest
  ): Promise<runtime.ApiResponse<V1EndpointsList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Endpoints
   */
  async listNamespacedEndpoints(
    requestParameters: ListNamespacedEndpointsRequest
  ): Promise<V1EndpointsList> {
    const response = await this.listNamespacedEndpointsRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Event
   */
  async watchListNamespacedEvent(
    requestParameters: ListNamespacedEventRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1EventList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1EventList>>(
      {
        path: `/api/v1/namespaces/{namespace}/events`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Event
   */
  async listNamespacedEventRaw(
    requestParameters: ListNamespacedEventRequest
  ): Promise<runtime.ApiResponse<V1EventList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/events`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Event
   */
  async listNamespacedEvent(requestParameters: ListNamespacedEventRequest): Promise<V1EventList> {
    const response = await this.listNamespacedEventRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind LimitRange
   */
  async watchListNamespacedLimitRange(
    requestParameters: ListNamespacedLimitRangeRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1LimitRangeList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1LimitRangeList>>(
      {
        path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind LimitRange
   */
  async listNamespacedLimitRangeRaw(
    requestParameters: ListNamespacedLimitRangeRequest
  ): Promise<runtime.ApiResponse<V1LimitRangeList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind LimitRange
   */
  async listNamespacedLimitRange(
    requestParameters: ListNamespacedLimitRangeRequest
  ): Promise<V1LimitRangeList> {
    const response = await this.listNamespacedLimitRangeRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind PersistentVolumeClaim
   */
  async watchListNamespacedPersistentVolumeClaim(
    requestParameters: ListNamespacedPersistentVolumeClaimRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1PersistentVolumeClaimList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1PersistentVolumeClaimList>>(
      {
        path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind PersistentVolumeClaim
   */
  async listNamespacedPersistentVolumeClaimRaw(
    requestParameters: ListNamespacedPersistentVolumeClaimRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaimList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind PersistentVolumeClaim
   */
  async listNamespacedPersistentVolumeClaim(
    requestParameters: ListNamespacedPersistentVolumeClaimRequest
  ): Promise<V1PersistentVolumeClaimList> {
    const response = await this.listNamespacedPersistentVolumeClaimRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Pod
   */
  async watchListNamespacedPod(
    requestParameters: ListNamespacedPodRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1PodList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1PodList>>(
      {
        path: `/api/v1/namespaces/{namespace}/pods`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Pod
   */
  async listNamespacedPodRaw(
    requestParameters: ListNamespacedPodRequest
  ): Promise<runtime.ApiResponse<V1PodList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Pod
   */
  async listNamespacedPod(requestParameters: ListNamespacedPodRequest): Promise<V1PodList> {
    const response = await this.listNamespacedPodRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind PodTemplate
   */
  async watchListNamespacedPodTemplate(
    requestParameters: ListNamespacedPodTemplateRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1PodTemplateList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1PodTemplateList>>(
      {
        path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind PodTemplate
   */
  async listNamespacedPodTemplateRaw(
    requestParameters: ListNamespacedPodTemplateRequest
  ): Promise<runtime.ApiResponse<V1PodTemplateList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind PodTemplate
   */
  async listNamespacedPodTemplate(
    requestParameters: ListNamespacedPodTemplateRequest
  ): Promise<V1PodTemplateList> {
    const response = await this.listNamespacedPodTemplateRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ReplicationController
   */
  async watchListNamespacedReplicationController(
    requestParameters: ListNamespacedReplicationControllerRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ReplicationControllerList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ReplicationControllerList>>(
      {
        path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ReplicationController
   */
  async listNamespacedReplicationControllerRaw(
    requestParameters: ListNamespacedReplicationControllerRequest
  ): Promise<runtime.ApiResponse<V1ReplicationControllerList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ReplicationController
   */
  async listNamespacedReplicationController(
    requestParameters: ListNamespacedReplicationControllerRequest
  ): Promise<V1ReplicationControllerList> {
    const response = await this.listNamespacedReplicationControllerRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ResourceQuota
   */
  async watchListNamespacedResourceQuota(
    requestParameters: ListNamespacedResourceQuotaRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ResourceQuotaList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ResourceQuotaList>>(
      {
        path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ResourceQuota
   */
  async listNamespacedResourceQuotaRaw(
    requestParameters: ListNamespacedResourceQuotaRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuotaList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ResourceQuota
   */
  async listNamespacedResourceQuota(
    requestParameters: ListNamespacedResourceQuotaRequest
  ): Promise<V1ResourceQuotaList> {
    const response = await this.listNamespacedResourceQuotaRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Secret
   */
  async watchListNamespacedSecret(
    requestParameters: ListNamespacedSecretRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1SecretList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1SecretList>>(
      {
        path: `/api/v1/namespaces/{namespace}/secrets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Secret
   */
  async listNamespacedSecretRaw(
    requestParameters: ListNamespacedSecretRequest
  ): Promise<runtime.ApiResponse<V1SecretList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/secrets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Secret
   */
  async listNamespacedSecret(
    requestParameters: ListNamespacedSecretRequest
  ): Promise<V1SecretList> {
    const response = await this.listNamespacedSecretRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Service
   */
  async watchListNamespacedService(
    requestParameters: ListNamespacedServiceRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ServiceList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedService.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ServiceList>>(
      {
        path: `/api/v1/namespaces/{namespace}/services`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Service
   */
  async listNamespacedServiceRaw(
    requestParameters: ListNamespacedServiceRequest
  ): Promise<runtime.ApiResponse<V1ServiceList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedService.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Service
   */
  async listNamespacedService(
    requestParameters: ListNamespacedServiceRequest
  ): Promise<V1ServiceList> {
    const response = await this.listNamespacedServiceRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ServiceAccount
   */
  async watchListNamespacedServiceAccount(
    requestParameters: ListNamespacedServiceAccountRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ServiceAccountList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ServiceAccountList>>(
      {
        path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ServiceAccount
   */
  async listNamespacedServiceAccountRaw(
    requestParameters: ListNamespacedServiceAccountRequest
  ): Promise<runtime.ApiResponse<V1ServiceAccountList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ServiceAccount
   */
  async listNamespacedServiceAccount(
    requestParameters: ListNamespacedServiceAccountRequest
  ): Promise<V1ServiceAccountList> {
    const response = await this.listNamespacedServiceAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Node
   */
  async watchListNode(
    requestParameters: ListNodeRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1NodeList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1NodeList>>(
      {
        path: `/api/v1/nodes`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Node
   */
  async listNodeRaw(requestParameters: ListNodeRequest): Promise<runtime.ApiResponse<V1NodeList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Node
   */
  async listNode(requestParameters: ListNodeRequest): Promise<V1NodeList> {
    const response = await this.listNodeRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind PersistentVolume
   */
  async watchListPersistentVolume(
    requestParameters: ListPersistentVolumeRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1PersistentVolumeList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1PersistentVolumeList>>(
      {
        path: `/api/v1/persistentvolumes`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind PersistentVolume
   */
  async listPersistentVolumeRaw(
    requestParameters: ListPersistentVolumeRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind PersistentVolume
   */
  async listPersistentVolume(
    requestParameters: ListPersistentVolumeRequest
  ): Promise<V1PersistentVolumeList> {
    const response = await this.listPersistentVolumeRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind PersistentVolumeClaim
   */
  async watchListPersistentVolumeClaimForAllNamespaces(
    requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1PersistentVolumeClaimList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1PersistentVolumeClaimList>>(
      {
        path: `/api/v1/persistentvolumeclaims`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind PersistentVolumeClaim
   */
  async listPersistentVolumeClaimForAllNamespacesRaw(
    requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaimList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumeclaims`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind PersistentVolumeClaim
   */
  async listPersistentVolumeClaimForAllNamespaces(
    requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest
  ): Promise<V1PersistentVolumeClaimList> {
    const response = await this.listPersistentVolumeClaimForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Pod
   */
  async watchListPodForAllNamespaces(
    requestParameters: ListPodForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1PodList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1PodList>>(
      {
        path: `/api/v1/pods`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Pod
   */
  async listPodForAllNamespacesRaw(
    requestParameters: ListPodForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1PodList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/pods`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Pod
   */
  async listPodForAllNamespaces(
    requestParameters: ListPodForAllNamespacesRequest
  ): Promise<V1PodList> {
    const response = await this.listPodForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind PodTemplate
   */
  async watchListPodTemplateForAllNamespaces(
    requestParameters: ListPodTemplateForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1PodTemplateList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1PodTemplateList>>(
      {
        path: `/api/v1/podtemplates`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind PodTemplate
   */
  async listPodTemplateForAllNamespacesRaw(
    requestParameters: ListPodTemplateForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1PodTemplateList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/podtemplates`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind PodTemplate
   */
  async listPodTemplateForAllNamespaces(
    requestParameters: ListPodTemplateForAllNamespacesRequest
  ): Promise<V1PodTemplateList> {
    const response = await this.listPodTemplateForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ReplicationController
   */
  async watchListReplicationControllerForAllNamespaces(
    requestParameters: ListReplicationControllerForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ReplicationControllerList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ReplicationControllerList>>(
      {
        path: `/api/v1/replicationcontrollers`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ReplicationController
   */
  async listReplicationControllerForAllNamespacesRaw(
    requestParameters: ListReplicationControllerForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1ReplicationControllerList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/replicationcontrollers`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ReplicationController
   */
  async listReplicationControllerForAllNamespaces(
    requestParameters: ListReplicationControllerForAllNamespacesRequest
  ): Promise<V1ReplicationControllerList> {
    const response = await this.listReplicationControllerForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ResourceQuota
   */
  async watchListResourceQuotaForAllNamespaces(
    requestParameters: ListResourceQuotaForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ResourceQuotaList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ResourceQuotaList>>(
      {
        path: `/api/v1/resourcequotas`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ResourceQuota
   */
  async listResourceQuotaForAllNamespacesRaw(
    requestParameters: ListResourceQuotaForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuotaList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/resourcequotas`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ResourceQuota
   */
  async listResourceQuotaForAllNamespaces(
    requestParameters: ListResourceQuotaForAllNamespacesRequest
  ): Promise<V1ResourceQuotaList> {
    const response = await this.listResourceQuotaForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Secret
   */
  async watchListSecretForAllNamespaces(
    requestParameters: ListSecretForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1SecretList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1SecretList>>(
      {
        path: `/api/v1/secrets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Secret
   */
  async listSecretForAllNamespacesRaw(
    requestParameters: ListSecretForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1SecretList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/secrets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Secret
   */
  async listSecretForAllNamespaces(
    requestParameters: ListSecretForAllNamespacesRequest
  ): Promise<V1SecretList> {
    const response = await this.listSecretForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ServiceAccount
   */
  async watchListServiceAccountForAllNamespaces(
    requestParameters: ListServiceAccountForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ServiceAccountList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ServiceAccountList>>(
      {
        path: `/api/v1/serviceaccounts`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ServiceAccount
   */
  async listServiceAccountForAllNamespacesRaw(
    requestParameters: ListServiceAccountForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1ServiceAccountList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/serviceaccounts`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ServiceAccount
   */
  async listServiceAccountForAllNamespaces(
    requestParameters: ListServiceAccountForAllNamespacesRequest
  ): Promise<V1ServiceAccountList> {
    const response = await this.listServiceAccountForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Service
   */
  async watchListServiceForAllNamespaces(
    requestParameters: ListServiceForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1ServiceList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1ServiceList>>(
      {
        path: `/api/v1/services`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Service
   */
  async listServiceForAllNamespacesRaw(
    requestParameters: ListServiceForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1ServiceList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/services`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Service
   */
  async listServiceForAllNamespaces(
    requestParameters: ListServiceForAllNamespacesRequest
  ): Promise<V1ServiceList> {
    const response = await this.listServiceForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Namespace
   */
  async patchNamespaceRaw(
    requestParameters: PatchNamespaceRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespace.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespace.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Namespace
   */
  async patchNamespace(requestParameters: PatchNamespaceRequest): Promise<V1Namespace> {
    const response = await this.patchNamespaceRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified Namespace
   */
  async patchNamespaceStatusRaw(
    requestParameters: PatchNamespaceStatusRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespaceStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespaceStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified Namespace
   */
  async patchNamespaceStatus(requestParameters: PatchNamespaceStatusRequest): Promise<V1Namespace> {
    const response = await this.patchNamespaceStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified ConfigMap
   */
  async patchNamespacedConfigMapRaw(
    requestParameters: PatchNamespacedConfigMapRequest
  ): Promise<runtime.ApiResponse<V1ConfigMap>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedConfigMap.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedConfigMap.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified ConfigMap
   */
  async patchNamespacedConfigMap(
    requestParameters: PatchNamespacedConfigMapRequest
  ): Promise<V1ConfigMap> {
    const response = await this.patchNamespacedConfigMapRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Endpoints
   */
  async patchNamespacedEndpointsRaw(
    requestParameters: PatchNamespacedEndpointsRequest
  ): Promise<runtime.ApiResponse<V1Endpoints>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedEndpoints.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedEndpoints.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Endpoints
   */
  async patchNamespacedEndpoints(
    requestParameters: PatchNamespacedEndpointsRequest
  ): Promise<V1Endpoints> {
    const response = await this.patchNamespacedEndpointsRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Event
   */
  async patchNamespacedEventRaw(
    requestParameters: PatchNamespacedEventRequest
  ): Promise<runtime.ApiResponse<V1Event>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedEvent.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedEvent.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Event
   */
  async patchNamespacedEvent(requestParameters: PatchNamespacedEventRequest): Promise<V1Event> {
    const response = await this.patchNamespacedEventRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified LimitRange
   */
  async patchNamespacedLimitRangeRaw(
    requestParameters: PatchNamespacedLimitRangeRequest
  ): Promise<runtime.ApiResponse<V1LimitRange>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedLimitRange.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedLimitRange.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified LimitRange
   */
  async patchNamespacedLimitRange(
    requestParameters: PatchNamespacedLimitRangeRequest
  ): Promise<V1LimitRange> {
    const response = await this.patchNamespacedLimitRangeRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified PersistentVolumeClaim
   */
  async patchNamespacedPersistentVolumeClaimRaw(
    requestParameters: PatchNamespacedPersistentVolumeClaimRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPersistentVolumeClaim.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPersistentVolumeClaim.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified PersistentVolumeClaim
   */
  async patchNamespacedPersistentVolumeClaim(
    requestParameters: PatchNamespacedPersistentVolumeClaimRequest
  ): Promise<V1PersistentVolumeClaim> {
    const response = await this.patchNamespacedPersistentVolumeClaimRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified PersistentVolumeClaim
   */
  async patchNamespacedPersistentVolumeClaimStatusRaw(
    requestParameters: PatchNamespacedPersistentVolumeClaimStatusRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified PersistentVolumeClaim
   */
  async patchNamespacedPersistentVolumeClaimStatus(
    requestParameters: PatchNamespacedPersistentVolumeClaimStatusRequest
  ): Promise<V1PersistentVolumeClaim> {
    const response = await this.patchNamespacedPersistentVolumeClaimStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Pod
   */
  async patchNamespacedPodRaw(
    requestParameters: PatchNamespacedPodRequest
  ): Promise<runtime.ApiResponse<V1Pod>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPod.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPod.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Pod
   */
  async patchNamespacedPod(requestParameters: PatchNamespacedPodRequest): Promise<V1Pod> {
    const response = await this.patchNamespacedPodRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified Pod
   */
  async patchNamespacedPodStatusRaw(
    requestParameters: PatchNamespacedPodStatusRequest
  ): Promise<runtime.ApiResponse<V1Pod>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPodStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPodStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPodStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified Pod
   */
  async patchNamespacedPodStatus(
    requestParameters: PatchNamespacedPodStatusRequest
  ): Promise<V1Pod> {
    const response = await this.patchNamespacedPodStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified PodTemplate
   */
  async patchNamespacedPodTemplateRaw(
    requestParameters: PatchNamespacedPodTemplateRequest
  ): Promise<runtime.ApiResponse<V1PodTemplate>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPodTemplate.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPodTemplate.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified PodTemplate
   */
  async patchNamespacedPodTemplate(
    requestParameters: PatchNamespacedPodTemplateRequest
  ): Promise<V1PodTemplate> {
    const response = await this.patchNamespacedPodTemplateRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified ReplicationController
   */
  async patchNamespacedReplicationControllerRaw(
    requestParameters: PatchNamespacedReplicationControllerRequest
  ): Promise<runtime.ApiResponse<V1ReplicationController>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationController.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationController.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified ReplicationController
   */
  async patchNamespacedReplicationController(
    requestParameters: PatchNamespacedReplicationControllerRequest
  ): Promise<V1ReplicationController> {
    const response = await this.patchNamespacedReplicationControllerRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update scale of the specified ReplicationController
   */
  async patchNamespacedReplicationControllerScaleRaw(
    requestParameters: PatchNamespacedReplicationControllerScaleRequest
  ): Promise<runtime.ApiResponse<V1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update scale of the specified ReplicationController
   */
  async patchNamespacedReplicationControllerScale(
    requestParameters: PatchNamespacedReplicationControllerScaleRequest
  ): Promise<V1Scale> {
    const response = await this.patchNamespacedReplicationControllerScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified ReplicationController
   */
  async patchNamespacedReplicationControllerStatusRaw(
    requestParameters: PatchNamespacedReplicationControllerStatusRequest
  ): Promise<runtime.ApiResponse<V1ReplicationController>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified ReplicationController
   */
  async patchNamespacedReplicationControllerStatus(
    requestParameters: PatchNamespacedReplicationControllerStatusRequest
  ): Promise<V1ReplicationController> {
    const response = await this.patchNamespacedReplicationControllerStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified ResourceQuota
   */
  async patchNamespacedResourceQuotaRaw(
    requestParameters: PatchNamespacedResourceQuotaRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuota>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedResourceQuota.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedResourceQuota.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified ResourceQuota
   */
  async patchNamespacedResourceQuota(
    requestParameters: PatchNamespacedResourceQuotaRequest
  ): Promise<V1ResourceQuota> {
    const response = await this.patchNamespacedResourceQuotaRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified ResourceQuota
   */
  async patchNamespacedResourceQuotaStatusRaw(
    requestParameters: PatchNamespacedResourceQuotaStatusRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuota>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedResourceQuotaStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedResourceQuotaStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedResourceQuotaStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified ResourceQuota
   */
  async patchNamespacedResourceQuotaStatus(
    requestParameters: PatchNamespacedResourceQuotaStatusRequest
  ): Promise<V1ResourceQuota> {
    const response = await this.patchNamespacedResourceQuotaStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Secret
   */
  async patchNamespacedSecretRaw(
    requestParameters: PatchNamespacedSecretRequest
  ): Promise<runtime.ApiResponse<V1Secret>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedSecret.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedSecret.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Secret
   */
  async patchNamespacedSecret(requestParameters: PatchNamespacedSecretRequest): Promise<V1Secret> {
    const response = await this.patchNamespacedSecretRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Service
   */
  async patchNamespacedServiceRaw(
    requestParameters: PatchNamespacedServiceRequest
  ): Promise<runtime.ApiResponse<V1Service>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedService.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedService.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedService.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Service
   */
  async patchNamespacedService(
    requestParameters: PatchNamespacedServiceRequest
  ): Promise<V1Service> {
    const response = await this.patchNamespacedServiceRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified ServiceAccount
   */
  async patchNamespacedServiceAccountRaw(
    requestParameters: PatchNamespacedServiceAccountRequest
  ): Promise<runtime.ApiResponse<V1ServiceAccount>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedServiceAccount.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedServiceAccount.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified ServiceAccount
   */
  async patchNamespacedServiceAccount(
    requestParameters: PatchNamespacedServiceAccountRequest
  ): Promise<V1ServiceAccount> {
    const response = await this.patchNamespacedServiceAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified Service
   */
  async patchNamespacedServiceStatusRaw(
    requestParameters: PatchNamespacedServiceStatusRequest
  ): Promise<runtime.ApiResponse<V1Service>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedServiceStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedServiceStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedServiceStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified Service
   */
  async patchNamespacedServiceStatus(
    requestParameters: PatchNamespacedServiceStatusRequest
  ): Promise<V1Service> {
    const response = await this.patchNamespacedServiceStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Node
   */
  async patchNodeRaw(requestParameters: PatchNodeRequest): Promise<runtime.ApiResponse<V1Node>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNode.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNode.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Node
   */
  async patchNode(requestParameters: PatchNodeRequest): Promise<V1Node> {
    const response = await this.patchNodeRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified Node
   */
  async patchNodeStatusRaw(
    requestParameters: PatchNodeStatusRequest
  ): Promise<runtime.ApiResponse<V1Node>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNodeStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNodeStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified Node
   */
  async patchNodeStatus(requestParameters: PatchNodeStatusRequest): Promise<V1Node> {
    const response = await this.patchNodeStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified PersistentVolume
   */
  async patchPersistentVolumeRaw(
    requestParameters: PatchPersistentVolumeRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolume>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchPersistentVolume.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchPersistentVolume.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified PersistentVolume
   */
  async patchPersistentVolume(
    requestParameters: PatchPersistentVolumeRequest
  ): Promise<V1PersistentVolume> {
    const response = await this.patchPersistentVolumeRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified PersistentVolume
   */
  async patchPersistentVolumeStatusRaw(
    requestParameters: PatchPersistentVolumeStatusRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolume>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchPersistentVolumeStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchPersistentVolumeStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified PersistentVolume
   */
  async patchPersistentVolumeStatus(
    requestParameters: PatchPersistentVolumeStatusRequest
  ): Promise<V1PersistentVolume> {
    const response = await this.patchPersistentVolumeStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ComponentStatus
   */
  async readComponentStatusRaw(
    requestParameters: ReadComponentStatusRequest
  ): Promise<runtime.ApiResponse<V1ComponentStatus>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readComponentStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/componentstatuses/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ComponentStatus
   */
  async readComponentStatus(
    requestParameters: ReadComponentStatusRequest
  ): Promise<V1ComponentStatus> {
    const response = await this.readComponentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Namespace
   */
  async readNamespaceRaw(
    requestParameters: ReadNamespaceRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespace.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Namespace
   */
  async readNamespace(requestParameters: ReadNamespaceRequest): Promise<V1Namespace> {
    const response = await this.readNamespaceRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified Namespace
   */
  async readNamespaceStatusRaw(
    requestParameters: ReadNamespaceStatusRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespaceStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified Namespace
   */
  async readNamespaceStatus(requestParameters: ReadNamespaceStatusRequest): Promise<V1Namespace> {
    const response = await this.readNamespaceStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ConfigMap
   */
  async readNamespacedConfigMapRaw(
    requestParameters: ReadNamespacedConfigMapRequest
  ): Promise<runtime.ApiResponse<V1ConfigMap>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedConfigMap.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ConfigMap
   */
  async readNamespacedConfigMap(
    requestParameters: ReadNamespacedConfigMapRequest
  ): Promise<V1ConfigMap> {
    const response = await this.readNamespacedConfigMapRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Endpoints
   */
  async readNamespacedEndpointsRaw(
    requestParameters: ReadNamespacedEndpointsRequest
  ): Promise<runtime.ApiResponse<V1Endpoints>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedEndpoints.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Endpoints
   */
  async readNamespacedEndpoints(
    requestParameters: ReadNamespacedEndpointsRequest
  ): Promise<V1Endpoints> {
    const response = await this.readNamespacedEndpointsRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Event
   */
  async readNamespacedEventRaw(
    requestParameters: ReadNamespacedEventRequest
  ): Promise<runtime.ApiResponse<V1Event>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedEvent.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Event
   */
  async readNamespacedEvent(requestParameters: ReadNamespacedEventRequest): Promise<V1Event> {
    const response = await this.readNamespacedEventRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified LimitRange
   */
  async readNamespacedLimitRangeRaw(
    requestParameters: ReadNamespacedLimitRangeRequest
  ): Promise<runtime.ApiResponse<V1LimitRange>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedLimitRange.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified LimitRange
   */
  async readNamespacedLimitRange(
    requestParameters: ReadNamespacedLimitRangeRequest
  ): Promise<V1LimitRange> {
    const response = await this.readNamespacedLimitRangeRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified PersistentVolumeClaim
   */
  async readNamespacedPersistentVolumeClaimRaw(
    requestParameters: ReadNamespacedPersistentVolumeClaimRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedPersistentVolumeClaim.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified PersistentVolumeClaim
   */
  async readNamespacedPersistentVolumeClaim(
    requestParameters: ReadNamespacedPersistentVolumeClaimRequest
  ): Promise<V1PersistentVolumeClaim> {
    const response = await this.readNamespacedPersistentVolumeClaimRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified PersistentVolumeClaim
   */
  async readNamespacedPersistentVolumeClaimStatusRaw(
    requestParameters: ReadNamespacedPersistentVolumeClaimStatusRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified PersistentVolumeClaim
   */
  async readNamespacedPersistentVolumeClaimStatus(
    requestParameters: ReadNamespacedPersistentVolumeClaimStatusRequest
  ): Promise<V1PersistentVolumeClaim> {
    const response = await this.readNamespacedPersistentVolumeClaimStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Pod
   */
  async readNamespacedPodRaw(
    requestParameters: ReadNamespacedPodRequest
  ): Promise<runtime.ApiResponse<V1Pod>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedPod.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Pod
   */
  async readNamespacedPod(requestParameters: ReadNamespacedPodRequest): Promise<V1Pod> {
    const response = await this.readNamespacedPodRaw(requestParameters)
    return await response.value()
  }

  /**
   * read log of the specified Pod
   */
  async readNamespacedPodLogRaw(
    requestParameters: ReadNamespacedPodLogRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedPodLog.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodLog.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.container !== undefined) {
      queryParameters['container'] = requestParameters.container
    }
    if (requestParameters.follow !== undefined) {
      queryParameters['follow'] = requestParameters.follow
    }
    if (requestParameters.limitBytes !== undefined) {
      queryParameters['limitBytes'] = requestParameters.limitBytes
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.previous !== undefined) {
      queryParameters['previous'] = requestParameters.previous
    }
    if (requestParameters.sinceSeconds !== undefined) {
      queryParameters['sinceSeconds'] = requestParameters.sinceSeconds
    }
    if (requestParameters.tailLines !== undefined) {
      queryParameters['tailLines'] = requestParameters.tailLines
    }
    if (requestParameters.timestamps !== undefined) {
      queryParameters['timestamps'] = requestParameters.timestamps
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/log`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.StringApiResponse(response)
  }

  /**
   * read log of the specified Pod
   */
  async readNamespacedPodLog(requestParameters: ReadNamespacedPodLogRequest): Promise<string> {
    const response = await this.readNamespacedPodLogRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified Pod
   */
  async readNamespacedPodStatusRaw(
    requestParameters: ReadNamespacedPodStatusRequest
  ): Promise<runtime.ApiResponse<V1Pod>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedPodStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified Pod
   */
  async readNamespacedPodStatus(requestParameters: ReadNamespacedPodStatusRequest): Promise<V1Pod> {
    const response = await this.readNamespacedPodStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified PodTemplate
   */
  async readNamespacedPodTemplateRaw(
    requestParameters: ReadNamespacedPodTemplateRequest
  ): Promise<runtime.ApiResponse<V1PodTemplate>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedPodTemplate.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified PodTemplate
   */
  async readNamespacedPodTemplate(
    requestParameters: ReadNamespacedPodTemplateRequest
  ): Promise<V1PodTemplate> {
    const response = await this.readNamespacedPodTemplateRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ReplicationController
   */
  async readNamespacedReplicationControllerRaw(
    requestParameters: ReadNamespacedReplicationControllerRequest
  ): Promise<runtime.ApiResponse<V1ReplicationController>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationController.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ReplicationController
   */
  async readNamespacedReplicationController(
    requestParameters: ReadNamespacedReplicationControllerRequest
  ): Promise<V1ReplicationController> {
    const response = await this.readNamespacedReplicationControllerRaw(requestParameters)
    return await response.value()
  }

  /**
   * read scale of the specified ReplicationController
   */
  async readNamespacedReplicationControllerScaleRaw(
    requestParameters: ReadNamespacedReplicationControllerScaleRequest
  ): Promise<runtime.ApiResponse<V1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read scale of the specified ReplicationController
   */
  async readNamespacedReplicationControllerScale(
    requestParameters: ReadNamespacedReplicationControllerScaleRequest
  ): Promise<V1Scale> {
    const response = await this.readNamespacedReplicationControllerScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified ReplicationController
   */
  async readNamespacedReplicationControllerStatusRaw(
    requestParameters: ReadNamespacedReplicationControllerStatusRequest
  ): Promise<runtime.ApiResponse<V1ReplicationController>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified ReplicationController
   */
  async readNamespacedReplicationControllerStatus(
    requestParameters: ReadNamespacedReplicationControllerStatusRequest
  ): Promise<V1ReplicationController> {
    const response = await this.readNamespacedReplicationControllerStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ResourceQuota
   */
  async readNamespacedResourceQuotaRaw(
    requestParameters: ReadNamespacedResourceQuotaRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuota>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedResourceQuota.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ResourceQuota
   */
  async readNamespacedResourceQuota(
    requestParameters: ReadNamespacedResourceQuotaRequest
  ): Promise<V1ResourceQuota> {
    const response = await this.readNamespacedResourceQuotaRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified ResourceQuota
   */
  async readNamespacedResourceQuotaStatusRaw(
    requestParameters: ReadNamespacedResourceQuotaStatusRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuota>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedResourceQuotaStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedResourceQuotaStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified ResourceQuota
   */
  async readNamespacedResourceQuotaStatus(
    requestParameters: ReadNamespacedResourceQuotaStatusRequest
  ): Promise<V1ResourceQuota> {
    const response = await this.readNamespacedResourceQuotaStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Secret
   */
  async readNamespacedSecretRaw(
    requestParameters: ReadNamespacedSecretRequest
  ): Promise<runtime.ApiResponse<V1Secret>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedSecret.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Secret
   */
  async readNamespacedSecret(requestParameters: ReadNamespacedSecretRequest): Promise<V1Secret> {
    const response = await this.readNamespacedSecretRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Service
   */
  async readNamespacedServiceRaw(
    requestParameters: ReadNamespacedServiceRequest
  ): Promise<runtime.ApiResponse<V1Service>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedService.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedService.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Service
   */
  async readNamespacedService(requestParameters: ReadNamespacedServiceRequest): Promise<V1Service> {
    const response = await this.readNamespacedServiceRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ServiceAccount
   */
  async readNamespacedServiceAccountRaw(
    requestParameters: ReadNamespacedServiceAccountRequest
  ): Promise<runtime.ApiResponse<V1ServiceAccount>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedServiceAccount.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ServiceAccount
   */
  async readNamespacedServiceAccount(
    requestParameters: ReadNamespacedServiceAccountRequest
  ): Promise<V1ServiceAccount> {
    const response = await this.readNamespacedServiceAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified Service
   */
  async readNamespacedServiceStatusRaw(
    requestParameters: ReadNamespacedServiceStatusRequest
  ): Promise<runtime.ApiResponse<V1Service>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedServiceStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedServiceStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified Service
   */
  async readNamespacedServiceStatus(
    requestParameters: ReadNamespacedServiceStatusRequest
  ): Promise<V1Service> {
    const response = await this.readNamespacedServiceStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Node
   */
  async readNodeRaw(requestParameters: ReadNodeRequest): Promise<runtime.ApiResponse<V1Node>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNode.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Node
   */
  async readNode(requestParameters: ReadNodeRequest): Promise<V1Node> {
    const response = await this.readNodeRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified Node
   */
  async readNodeStatusRaw(
    requestParameters: ReadNodeStatusRequest
  ): Promise<runtime.ApiResponse<V1Node>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNodeStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified Node
   */
  async readNodeStatus(requestParameters: ReadNodeStatusRequest): Promise<V1Node> {
    const response = await this.readNodeStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified PersistentVolume
   */
  async readPersistentVolumeRaw(
    requestParameters: ReadPersistentVolumeRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolume>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readPersistentVolume.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified PersistentVolume
   */
  async readPersistentVolume(
    requestParameters: ReadPersistentVolumeRequest
  ): Promise<V1PersistentVolume> {
    const response = await this.readPersistentVolumeRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified PersistentVolume
   */
  async readPersistentVolumeStatusRaw(
    requestParameters: ReadPersistentVolumeStatusRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolume>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readPersistentVolumeStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified PersistentVolume
   */
  async readPersistentVolumeStatus(
    requestParameters: ReadPersistentVolumeStatusRequest
  ): Promise<V1PersistentVolume> {
    const response = await this.readPersistentVolumeStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Namespace
   */
  async replaceNamespaceRaw(
    requestParameters: ReplaceNamespaceRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespace.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespace.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Namespace
   */
  async replaceNamespace(requestParameters: ReplaceNamespaceRequest): Promise<V1Namespace> {
    const response = await this.replaceNamespaceRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace finalize of the specified Namespace
   */
  async replaceNamespaceFinalizeRaw(
    requestParameters: ReplaceNamespaceFinalizeRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespaceFinalize.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespaceFinalize.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}/finalize`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace finalize of the specified Namespace
   */
  async replaceNamespaceFinalize(
    requestParameters: ReplaceNamespaceFinalizeRequest
  ): Promise<V1Namespace> {
    const response = await this.replaceNamespaceFinalizeRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified Namespace
   */
  async replaceNamespaceStatusRaw(
    requestParameters: ReplaceNamespaceStatusRequest
  ): Promise<runtime.ApiResponse<V1Namespace>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespaceStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespaceStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified Namespace
   */
  async replaceNamespaceStatus(
    requestParameters: ReplaceNamespaceStatusRequest
  ): Promise<V1Namespace> {
    const response = await this.replaceNamespaceStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified ConfigMap
   */
  async replaceNamespacedConfigMapRaw(
    requestParameters: ReplaceNamespacedConfigMapRequest
  ): Promise<runtime.ApiResponse<V1ConfigMap>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedConfigMap.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedConfigMap.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedConfigMap.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified ConfigMap
   */
  async replaceNamespacedConfigMap(
    requestParameters: ReplaceNamespacedConfigMapRequest
  ): Promise<V1ConfigMap> {
    const response = await this.replaceNamespacedConfigMapRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Endpoints
   */
  async replaceNamespacedEndpointsRaw(
    requestParameters: ReplaceNamespacedEndpointsRequest
  ): Promise<runtime.ApiResponse<V1Endpoints>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedEndpoints.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedEndpoints.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedEndpoints.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Endpoints
   */
  async replaceNamespacedEndpoints(
    requestParameters: ReplaceNamespacedEndpointsRequest
  ): Promise<V1Endpoints> {
    const response = await this.replaceNamespacedEndpointsRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Event
   */
  async replaceNamespacedEventRaw(
    requestParameters: ReplaceNamespacedEventRequest
  ): Promise<runtime.ApiResponse<V1Event>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedEvent.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedEvent.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedEvent.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Event
   */
  async replaceNamespacedEvent(requestParameters: ReplaceNamespacedEventRequest): Promise<V1Event> {
    const response = await this.replaceNamespacedEventRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified LimitRange
   */
  async replaceNamespacedLimitRangeRaw(
    requestParameters: ReplaceNamespacedLimitRangeRequest
  ): Promise<runtime.ApiResponse<V1LimitRange>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedLimitRange.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedLimitRange.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedLimitRange.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified LimitRange
   */
  async replaceNamespacedLimitRange(
    requestParameters: ReplaceNamespacedLimitRangeRequest
  ): Promise<V1LimitRange> {
    const response = await this.replaceNamespacedLimitRangeRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified PersistentVolumeClaim
   */
  async replaceNamespacedPersistentVolumeClaimRaw(
    requestParameters: ReplaceNamespacedPersistentVolumeClaimRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPersistentVolumeClaim.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaim.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPersistentVolumeClaim.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified PersistentVolumeClaim
   */
  async replaceNamespacedPersistentVolumeClaim(
    requestParameters: ReplaceNamespacedPersistentVolumeClaimRequest
  ): Promise<V1PersistentVolumeClaim> {
    const response = await this.replaceNamespacedPersistentVolumeClaimRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified PersistentVolumeClaim
   */
  async replaceNamespacedPersistentVolumeClaimStatusRaw(
    requestParameters: ReplaceNamespacedPersistentVolumeClaimStatusRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified PersistentVolumeClaim
   */
  async replaceNamespacedPersistentVolumeClaimStatus(
    requestParameters: ReplaceNamespacedPersistentVolumeClaimStatusRequest
  ): Promise<V1PersistentVolumeClaim> {
    const response = await this.replaceNamespacedPersistentVolumeClaimStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Pod
   */
  async replaceNamespacedPodRaw(
    requestParameters: ReplaceNamespacedPodRequest
  ): Promise<runtime.ApiResponse<V1Pod>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPod.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPod.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPod.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Pod
   */
  async replaceNamespacedPod(requestParameters: ReplaceNamespacedPodRequest): Promise<V1Pod> {
    const response = await this.replaceNamespacedPodRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified Pod
   */
  async replaceNamespacedPodStatusRaw(
    requestParameters: ReplaceNamespacedPodStatusRequest
  ): Promise<runtime.ApiResponse<V1Pod>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPodStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPodStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPodStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/pods/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified Pod
   */
  async replaceNamespacedPodStatus(
    requestParameters: ReplaceNamespacedPodStatusRequest
  ): Promise<V1Pod> {
    const response = await this.replaceNamespacedPodStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified PodTemplate
   */
  async replaceNamespacedPodTemplateRaw(
    requestParameters: ReplaceNamespacedPodTemplateRequest
  ): Promise<runtime.ApiResponse<V1PodTemplate>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPodTemplate.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPodTemplate.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPodTemplate.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified PodTemplate
   */
  async replaceNamespacedPodTemplate(
    requestParameters: ReplaceNamespacedPodTemplateRequest
  ): Promise<V1PodTemplate> {
    const response = await this.replaceNamespacedPodTemplateRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified ReplicationController
   */
  async replaceNamespacedReplicationControllerRaw(
    requestParameters: ReplaceNamespacedReplicationControllerRequest
  ): Promise<runtime.ApiResponse<V1ReplicationController>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationController.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationController.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationController.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified ReplicationController
   */
  async replaceNamespacedReplicationController(
    requestParameters: ReplaceNamespacedReplicationControllerRequest
  ): Promise<V1ReplicationController> {
    const response = await this.replaceNamespacedReplicationControllerRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace scale of the specified ReplicationController
   */
  async replaceNamespacedReplicationControllerScaleRaw(
    requestParameters: ReplaceNamespacedReplicationControllerScaleRequest
  ): Promise<runtime.ApiResponse<V1Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace scale of the specified ReplicationController
   */
  async replaceNamespacedReplicationControllerScale(
    requestParameters: ReplaceNamespacedReplicationControllerScaleRequest
  ): Promise<V1Scale> {
    const response = await this.replaceNamespacedReplicationControllerScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified ReplicationController
   */
  async replaceNamespacedReplicationControllerStatusRaw(
    requestParameters: ReplaceNamespacedReplicationControllerStatusRequest
  ): Promise<runtime.ApiResponse<V1ReplicationController>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified ReplicationController
   */
  async replaceNamespacedReplicationControllerStatus(
    requestParameters: ReplaceNamespacedReplicationControllerStatusRequest
  ): Promise<V1ReplicationController> {
    const response = await this.replaceNamespacedReplicationControllerStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified ResourceQuota
   */
  async replaceNamespacedResourceQuotaRaw(
    requestParameters: ReplaceNamespacedResourceQuotaRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuota>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedResourceQuota.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedResourceQuota.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedResourceQuota.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified ResourceQuota
   */
  async replaceNamespacedResourceQuota(
    requestParameters: ReplaceNamespacedResourceQuotaRequest
  ): Promise<V1ResourceQuota> {
    const response = await this.replaceNamespacedResourceQuotaRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified ResourceQuota
   */
  async replaceNamespacedResourceQuotaStatusRaw(
    requestParameters: ReplaceNamespacedResourceQuotaStatusRequest
  ): Promise<runtime.ApiResponse<V1ResourceQuota>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedResourceQuotaStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedResourceQuotaStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedResourceQuotaStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified ResourceQuota
   */
  async replaceNamespacedResourceQuotaStatus(
    requestParameters: ReplaceNamespacedResourceQuotaStatusRequest
  ): Promise<V1ResourceQuota> {
    const response = await this.replaceNamespacedResourceQuotaStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Secret
   */
  async replaceNamespacedSecretRaw(
    requestParameters: ReplaceNamespacedSecretRequest
  ): Promise<runtime.ApiResponse<V1Secret>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedSecret.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedSecret.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedSecret.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Secret
   */
  async replaceNamespacedSecret(
    requestParameters: ReplaceNamespacedSecretRequest
  ): Promise<V1Secret> {
    const response = await this.replaceNamespacedSecretRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Service
   */
  async replaceNamespacedServiceRaw(
    requestParameters: ReplaceNamespacedServiceRequest
  ): Promise<runtime.ApiResponse<V1Service>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedService.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedService.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedService.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Service
   */
  async replaceNamespacedService(
    requestParameters: ReplaceNamespacedServiceRequest
  ): Promise<V1Service> {
    const response = await this.replaceNamespacedServiceRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified ServiceAccount
   */
  async replaceNamespacedServiceAccountRaw(
    requestParameters: ReplaceNamespacedServiceAccountRequest
  ): Promise<runtime.ApiResponse<V1ServiceAccount>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedServiceAccount.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedServiceAccount.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedServiceAccount.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified ServiceAccount
   */
  async replaceNamespacedServiceAccount(
    requestParameters: ReplaceNamespacedServiceAccountRequest
  ): Promise<V1ServiceAccount> {
    const response = await this.replaceNamespacedServiceAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified Service
   */
  async replaceNamespacedServiceStatusRaw(
    requestParameters: ReplaceNamespacedServiceStatusRequest
  ): Promise<runtime.ApiResponse<V1Service>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedServiceStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedServiceStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedServiceStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/namespaces/{namespace}/services/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified Service
   */
  async replaceNamespacedServiceStatus(
    requestParameters: ReplaceNamespacedServiceStatusRequest
  ): Promise<V1Service> {
    const response = await this.replaceNamespacedServiceStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Node
   */
  async replaceNodeRaw(
    requestParameters: ReplaceNodeRequest
  ): Promise<runtime.ApiResponse<V1Node>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNode.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNode.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Node
   */
  async replaceNode(requestParameters: ReplaceNodeRequest): Promise<V1Node> {
    const response = await this.replaceNodeRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified Node
   */
  async replaceNodeStatusRaw(
    requestParameters: ReplaceNodeStatusRequest
  ): Promise<runtime.ApiResponse<V1Node>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNodeStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNodeStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/nodes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified Node
   */
  async replaceNodeStatus(requestParameters: ReplaceNodeStatusRequest): Promise<V1Node> {
    const response = await this.replaceNodeStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified PersistentVolume
   */
  async replacePersistentVolumeRaw(
    requestParameters: ReplacePersistentVolumeRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolume>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replacePersistentVolume.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replacePersistentVolume.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified PersistentVolume
   */
  async replacePersistentVolume(
    requestParameters: ReplacePersistentVolumeRequest
  ): Promise<V1PersistentVolume> {
    const response = await this.replacePersistentVolumeRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified PersistentVolume
   */
  async replacePersistentVolumeStatusRaw(
    requestParameters: ReplacePersistentVolumeStatusRequest
  ): Promise<runtime.ApiResponse<V1PersistentVolume>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replacePersistentVolumeStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replacePersistentVolumeStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/api/v1/persistentvolumes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified PersistentVolume
   */
  async replacePersistentVolumeStatus(
    requestParameters: ReplacePersistentVolumeStatusRequest
  ): Promise<V1PersistentVolume> {
    const response = await this.replacePersistentVolumeStatusRaw(requestParameters)
    return await response.value()
  }
}
