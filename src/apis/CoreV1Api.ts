// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.14.11
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  RequestOpts,
  HTTPHeaders,
  HTTPQuery,
  ApiResponse,
  StringApiResponse,
  JSONApiResponse,
  ItemType,
  KubeEvent,
  request,
  requestStream
} from '../runtime'
import V1APIResourceList from '../models/V1APIResourceList'
import V1Binding from '../models/V1Binding'
import V1ComponentStatus from '../models/V1ComponentStatus'
import V1ComponentStatusList from '../models/V1ComponentStatusList'
import V1ConfigMap from '../models/V1ConfigMap'
import V1ConfigMapList from '../models/V1ConfigMapList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Endpoints from '../models/V1Endpoints'
import V1EndpointsList from '../models/V1EndpointsList'
import V1Event from '../models/V1Event'
import V1EventList from '../models/V1EventList'
import V1LimitRange from '../models/V1LimitRange'
import V1LimitRangeList from '../models/V1LimitRangeList'
import V1Namespace from '../models/V1Namespace'
import V1NamespaceList from '../models/V1NamespaceList'
import V1Node from '../models/V1Node'
import V1NodeList from '../models/V1NodeList'
import V1PersistentVolume from '../models/V1PersistentVolume'
import V1PersistentVolumeClaim from '../models/V1PersistentVolumeClaim'
import V1PersistentVolumeClaimList from '../models/V1PersistentVolumeClaimList'
import V1PersistentVolumeList from '../models/V1PersistentVolumeList'
import V1Pod from '../models/V1Pod'
import V1PodList from '../models/V1PodList'
import V1PodTemplate from '../models/V1PodTemplate'
import V1PodTemplateList from '../models/V1PodTemplateList'
import V1ReplicationController from '../models/V1ReplicationController'
import V1ReplicationControllerList from '../models/V1ReplicationControllerList'
import V1ResourceQuota from '../models/V1ResourceQuota'
import V1ResourceQuotaList from '../models/V1ResourceQuotaList'
import V1Scale from '../models/V1Scale'
import V1Secret from '../models/V1Secret'
import V1SecretList from '../models/V1SecretList'
import V1Service from '../models/V1Service'
import V1ServiceAccount from '../models/V1ServiceAccount'
import V1ServiceAccountList from '../models/V1ServiceAccountList'
import V1ServiceList from '../models/V1ServiceList'
import V1Status from '../models/V1Status'
import V1beta1Eviction from '../models/V1beta1Eviction'

interface ConnectDeleteNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectDeleteNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectDeleteNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectDeleteNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectDeleteNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectDeleteNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectGetNamespacedPodAttachRequest {
  name: string
  namespace: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectGetNamespacedPodExecRequest {
  name: string
  namespace: string
  command?: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectGetNamespacedPodPortforwardRequest {
  name: string
  namespace: string
  ports?: number
}

interface ConnectGetNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectGetNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectGetNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectGetNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectGetNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectGetNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectHeadNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectHeadNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectHeadNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectHeadNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectHeadNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectHeadNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectOptionsNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectOptionsNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectOptionsNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectOptionsNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectOptionsNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectOptionsNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectPatchNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPatchNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPatchNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPatchNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPatchNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectPatchNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectPostNamespacedPodAttachRequest {
  name: string
  namespace: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectPostNamespacedPodExecRequest {
  name: string
  namespace: string
  command?: string
  container?: string
  stderr?: boolean
  stdin?: boolean
  stdout?: boolean
  tty?: boolean
}

interface ConnectPostNamespacedPodPortforwardRequest {
  name: string
  namespace: string
  ports?: number
}

interface ConnectPostNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPostNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPostNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPostNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPostNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectPostNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface ConnectPutNamespacedPodProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPutNamespacedPodProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPutNamespacedServiceProxyRequest {
  name: string
  namespace: string
  path?: string
}

interface ConnectPutNamespacedServiceProxyWithPathRequest {
  name: string
  namespace: string
  path: string
  path2?: string
}

interface ConnectPutNodeProxyRequest {
  name: string
  path?: string
}

interface ConnectPutNodeProxyWithPathRequest {
  name: string
  path: string
  path2?: string
}

interface CreateNamespaceRequest {
  body: V1Namespace
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedBindingRequest {
  namespace: string
  body: V1Binding
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedConfigMapRequest {
  namespace: string
  body: V1ConfigMap
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedEndpointsRequest {
  namespace: string
  body: V1Endpoints
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedEventRequest {
  namespace: string
  body: V1Event
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedLimitRangeRequest {
  namespace: string
  body: V1LimitRange
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedPersistentVolumeClaimRequest {
  namespace: string
  body: V1PersistentVolumeClaim
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedPodRequest {
  namespace: string
  body: V1Pod
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedPodBindingRequest {
  name: string
  namespace: string
  body: V1Binding
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedPodEvictionRequest {
  name: string
  namespace: string
  body: V1beta1Eviction
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface CreateNamespacedPodTemplateRequest {
  namespace: string
  body: V1PodTemplate
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedReplicationControllerRequest {
  namespace: string
  body: V1ReplicationController
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedResourceQuotaRequest {
  namespace: string
  body: V1ResourceQuota
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedSecretRequest {
  namespace: string
  body: V1Secret
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedServiceRequest {
  namespace: string
  body: V1Service
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedServiceAccountRequest {
  namespace: string
  body: V1ServiceAccount
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNodeRequest {
  body: V1Node
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreatePersistentVolumeRequest {
  body: V1PersistentVolume
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface DeleteCollectionNamespacedConfigMapRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedEndpointsRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedEventRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedLimitRangeRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedPersistentVolumeClaimRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedPodRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedPodTemplateRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedReplicationControllerRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedResourceQuotaRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedSecretRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedServiceAccountRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNodeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionPersistentVolumeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteNamespaceRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedConfigMapRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedEndpointsRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedEventRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedLimitRangeRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedPodRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedPodTemplateRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedSecretRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedServiceRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedServiceAccountRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNodeRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeletePersistentVolumeRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface ListComponentStatusRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListConfigMapForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListEndpointsForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListEventForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListLimitRangeForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespaceRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedConfigMapRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedEndpointsRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedEventRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedLimitRangeRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedPersistentVolumeClaimRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedPodRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedPodTemplateRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedReplicationControllerRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedResourceQuotaRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedSecretRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedServiceRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedServiceAccountRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNodeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPersistentVolumeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPersistentVolumeClaimForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPodForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListPodTemplateForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListReplicationControllerForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListResourceQuotaForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListSecretForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListServiceAccountForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListServiceForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface PatchNamespaceRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespaceStatusRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedConfigMapRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedEndpointsRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedEventRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedLimitRangeRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPersistentVolumeClaimStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPodRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPodStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedPodTemplateRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicationControllerStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedResourceQuotaStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedSecretRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedServiceRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedServiceAccountRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedServiceStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNodeRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNodeStatusRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchPersistentVolumeRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchPersistentVolumeStatusRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface ReadComponentStatusRequest {
  name: string
  pretty?: string
}

interface ReadNamespaceRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespaceStatusRequest {
  name: string
  pretty?: string
}

interface ReadNamespacedConfigMapRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedEndpointsRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedEventRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedLimitRangeRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedPersistentVolumeClaimStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedPodRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedPodLogRequest {
  name: string
  namespace: string
  container?: string
  follow?: boolean
  limitBytes?: number
  pretty?: string
  previous?: boolean
  sinceSeconds?: number
  tailLines?: number
  timestamps?: boolean
}

interface ReadNamespacedPodStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedPodTemplateRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicationControllerScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicationControllerStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedResourceQuotaStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedSecretRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedServiceRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedServiceAccountRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedServiceStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNodeRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNodeStatusRequest {
  name: string
  pretty?: string
}

interface ReadPersistentVolumeRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadPersistentVolumeStatusRequest {
  name: string
  pretty?: string
}

interface ReplaceNamespaceRequest {
  name: string
  body: V1Namespace
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespaceFinalizeRequest {
  name: string
  body: V1Namespace
  dryRun?: string
  fieldManager?: string
  pretty?: string
}

interface ReplaceNamespaceStatusRequest {
  name: string
  body: V1Namespace
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedConfigMapRequest {
  name: string
  namespace: string
  body: V1ConfigMap
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedEndpointsRequest {
  name: string
  namespace: string
  body: V1Endpoints
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedEventRequest {
  name: string
  namespace: string
  body: V1Event
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedLimitRangeRequest {
  name: string
  namespace: string
  body: V1LimitRange
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPersistentVolumeClaimRequest {
  name: string
  namespace: string
  body: V1PersistentVolumeClaim
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPersistentVolumeClaimStatusRequest {
  name: string
  namespace: string
  body: V1PersistentVolumeClaim
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPodRequest {
  name: string
  namespace: string
  body: V1Pod
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPodStatusRequest {
  name: string
  namespace: string
  body: V1Pod
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedPodTemplateRequest {
  name: string
  namespace: string
  body: V1PodTemplate
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerRequest {
  name: string
  namespace: string
  body: V1ReplicationController
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerScaleRequest {
  name: string
  namespace: string
  body: V1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicationControllerStatusRequest {
  name: string
  namespace: string
  body: V1ReplicationController
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedResourceQuotaRequest {
  name: string
  namespace: string
  body: V1ResourceQuota
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedResourceQuotaStatusRequest {
  name: string
  namespace: string
  body: V1ResourceQuota
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedSecretRequest {
  name: string
  namespace: string
  body: V1Secret
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedServiceRequest {
  name: string
  namespace: string
  body: V1Service
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedServiceAccountRequest {
  name: string
  namespace: string
  body: V1ServiceAccount
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedServiceStatusRequest {
  name: string
  namespace: string
  body: V1Service
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNodeRequest {
  name: string
  body: V1Node
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNodeStatusRequest {
  name: string
  body: V1Node
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplacePersistentVolumeRequest {
  name: string
  body: V1PersistentVolume
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplacePersistentVolumeStatusRequest {
  name: string
  body: V1PersistentVolume
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

/**
 * connect DELETE requests to proxy of Pod
 */
export async function connectDeleteNamespacedPodProxyRaw(
  requestParameters: ConnectDeleteNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedPodProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedPodProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect DELETE requests to proxy of Pod
 */
export async function connectDeleteNamespacedPodProxy(
  requestParameters: ConnectDeleteNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectDeleteNamespacedPodProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect DELETE requests to proxy of Pod
 */
export async function connectDeleteNamespacedPodProxyWithPathRaw(
  requestParameters: ConnectDeleteNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect DELETE requests to proxy of Pod
 */
export async function connectDeleteNamespacedPodProxyWithPath(
  requestParameters: ConnectDeleteNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectDeleteNamespacedPodProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect DELETE requests to proxy of Service
 */
export async function connectDeleteNamespacedServiceProxyRaw(
  requestParameters: ConnectDeleteNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedServiceProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedServiceProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect DELETE requests to proxy of Service
 */
export async function connectDeleteNamespacedServiceProxy(
  requestParameters: ConnectDeleteNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectDeleteNamespacedServiceProxyRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect DELETE requests to proxy of Service
 */
export async function connectDeleteNamespacedServiceProxyWithPathRaw(
  requestParameters: ConnectDeleteNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect DELETE requests to proxy of Service
 */
export async function connectDeleteNamespacedServiceProxyWithPath(
  requestParameters: ConnectDeleteNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectDeleteNamespacedServiceProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect DELETE requests to proxy of Node
 */
export async function connectDeleteNodeProxyRaw(
  requestParameters: ConnectDeleteNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectDeleteNodeProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect DELETE requests to proxy of Node
 */
export async function connectDeleteNodeProxy(
  requestParameters: ConnectDeleteNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectDeleteNodeProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect DELETE requests to proxy of Node
 */
export async function connectDeleteNodeProxyWithPathRaw(
  requestParameters: ConnectDeleteNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectDeleteNodeProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectDeleteNodeProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect DELETE requests to proxy of Node
 */
export async function connectDeleteNodeProxyWithPath(
  requestParameters: ConnectDeleteNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectDeleteNodeProxyWithPathRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect GET requests to attach of Pod
 */
export async function connectGetNamespacedPodAttachRaw(
  requestParameters: ConnectGetNamespacedPodAttachRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodAttach.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodAttach.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.container !== undefined) {
    queryParameters['container'] = requestParameters.container
  }
  if (requestParameters.stderr !== undefined) {
    queryParameters['stderr'] = requestParameters.stderr
  }
  if (requestParameters.stdin !== undefined) {
    queryParameters['stdin'] = requestParameters.stdin
  }
  if (requestParameters.stdout !== undefined) {
    queryParameters['stdout'] = requestParameters.stdout
  }
  if (requestParameters.tty !== undefined) {
    queryParameters['tty'] = requestParameters.tty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to attach of Pod
 */
export async function connectGetNamespacedPodAttach(
  requestParameters: ConnectGetNamespacedPodAttachRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNamespacedPodAttachRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect GET requests to exec of Pod
 */
export async function connectGetNamespacedPodExecRaw(
  requestParameters: ConnectGetNamespacedPodExecRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodExec.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodExec.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.command !== undefined) {
    queryParameters['command'] = requestParameters.command
  }
  if (requestParameters.container !== undefined) {
    queryParameters['container'] = requestParameters.container
  }
  if (requestParameters.stderr !== undefined) {
    queryParameters['stderr'] = requestParameters.stderr
  }
  if (requestParameters.stdin !== undefined) {
    queryParameters['stdin'] = requestParameters.stdin
  }
  if (requestParameters.stdout !== undefined) {
    queryParameters['stdout'] = requestParameters.stdout
  }
  if (requestParameters.tty !== undefined) {
    queryParameters['tty'] = requestParameters.tty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to exec of Pod
 */
export async function connectGetNamespacedPodExec(
  requestParameters: ConnectGetNamespacedPodExecRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNamespacedPodExecRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect GET requests to portforward of Pod
 */
export async function connectGetNamespacedPodPortforwardRaw(
  requestParameters: ConnectGetNamespacedPodPortforwardRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodPortforward.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodPortforward.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.ports !== undefined) {
    queryParameters['ports'] = requestParameters.ports
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to portforward of Pod
 */
export async function connectGetNamespacedPodPortforward(
  requestParameters: ConnectGetNamespacedPodPortforwardRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNamespacedPodPortforwardRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect GET requests to proxy of Pod
 */
export async function connectGetNamespacedPodProxyRaw(
  requestParameters: ConnectGetNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to proxy of Pod
 */
export async function connectGetNamespacedPodProxy(
  requestParameters: ConnectGetNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNamespacedPodProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect GET requests to proxy of Pod
 */
export async function connectGetNamespacedPodProxyWithPathRaw(
  requestParameters: ConnectGetNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectGetNamespacedPodProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to proxy of Pod
 */
export async function connectGetNamespacedPodProxyWithPath(
  requestParameters: ConnectGetNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNamespacedPodProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect GET requests to proxy of Service
 */
export async function connectGetNamespacedServiceProxyRaw(
  requestParameters: ConnectGetNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedServiceProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedServiceProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to proxy of Service
 */
export async function connectGetNamespacedServiceProxy(
  requestParameters: ConnectGetNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNamespacedServiceProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect GET requests to proxy of Service
 */
export async function connectGetNamespacedServiceProxyWithPathRaw(
  requestParameters: ConnectGetNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectGetNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectGetNamespacedServiceProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to proxy of Service
 */
export async function connectGetNamespacedServiceProxyWithPath(
  requestParameters: ConnectGetNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNamespacedServiceProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect GET requests to proxy of Node
 */
export async function connectGetNodeProxyRaw(
  requestParameters: ConnectGetNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNodeProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to proxy of Node
 */
export async function connectGetNodeProxy(
  requestParameters: ConnectGetNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNodeProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect GET requests to proxy of Node
 */
export async function connectGetNodeProxyWithPathRaw(
  requestParameters: ConnectGetNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectGetNodeProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectGetNodeProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect GET requests to proxy of Node
 */
export async function connectGetNodeProxyWithPath(
  requestParameters: ConnectGetNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectGetNodeProxyWithPathRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect HEAD requests to proxy of Pod
 */
export async function connectHeadNamespacedPodProxyRaw(
  requestParameters: ConnectHeadNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedPodProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedPodProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect HEAD requests to proxy of Pod
 */
export async function connectHeadNamespacedPodProxy(
  requestParameters: ConnectHeadNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectHeadNamespacedPodProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect HEAD requests to proxy of Pod
 */
export async function connectHeadNamespacedPodProxyWithPathRaw(
  requestParameters: ConnectHeadNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectHeadNamespacedPodProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect HEAD requests to proxy of Pod
 */
export async function connectHeadNamespacedPodProxyWithPath(
  requestParameters: ConnectHeadNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectHeadNamespacedPodProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect HEAD requests to proxy of Service
 */
export async function connectHeadNamespacedServiceProxyRaw(
  requestParameters: ConnectHeadNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedServiceProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedServiceProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect HEAD requests to proxy of Service
 */
export async function connectHeadNamespacedServiceProxy(
  requestParameters: ConnectHeadNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectHeadNamespacedServiceProxyRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect HEAD requests to proxy of Service
 */
export async function connectHeadNamespacedServiceProxyWithPathRaw(
  requestParameters: ConnectHeadNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect HEAD requests to proxy of Service
 */
export async function connectHeadNamespacedServiceProxyWithPath(
  requestParameters: ConnectHeadNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectHeadNamespacedServiceProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect HEAD requests to proxy of Node
 */
export async function connectHeadNodeProxyRaw(
  requestParameters: ConnectHeadNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectHeadNodeProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect HEAD requests to proxy of Node
 */
export async function connectHeadNodeProxy(
  requestParameters: ConnectHeadNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectHeadNodeProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect HEAD requests to proxy of Node
 */
export async function connectHeadNodeProxyWithPathRaw(
  requestParameters: ConnectHeadNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectHeadNodeProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectHeadNodeProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'HEAD',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect HEAD requests to proxy of Node
 */
export async function connectHeadNodeProxyWithPath(
  requestParameters: ConnectHeadNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectHeadNodeProxyWithPathRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect OPTIONS requests to proxy of Pod
 */
export async function connectOptionsNamespacedPodProxyRaw(
  requestParameters: ConnectOptionsNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedPodProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedPodProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect OPTIONS requests to proxy of Pod
 */
export async function connectOptionsNamespacedPodProxy(
  requestParameters: ConnectOptionsNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectOptionsNamespacedPodProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect OPTIONS requests to proxy of Pod
 */
export async function connectOptionsNamespacedPodProxyWithPathRaw(
  requestParameters: ConnectOptionsNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect OPTIONS requests to proxy of Pod
 */
export async function connectOptionsNamespacedPodProxyWithPath(
  requestParameters: ConnectOptionsNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectOptionsNamespacedPodProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect OPTIONS requests to proxy of Service
 */
export async function connectOptionsNamespacedServiceProxyRaw(
  requestParameters: ConnectOptionsNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedServiceProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedServiceProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect OPTIONS requests to proxy of Service
 */
export async function connectOptionsNamespacedServiceProxy(
  requestParameters: ConnectOptionsNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectOptionsNamespacedServiceProxyRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect OPTIONS requests to proxy of Service
 */
export async function connectOptionsNamespacedServiceProxyWithPathRaw(
  requestParameters: ConnectOptionsNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect OPTIONS requests to proxy of Service
 */
export async function connectOptionsNamespacedServiceProxyWithPath(
  requestParameters: ConnectOptionsNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectOptionsNamespacedServiceProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect OPTIONS requests to proxy of Node
 */
export async function connectOptionsNodeProxyRaw(
  requestParameters: ConnectOptionsNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectOptionsNodeProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect OPTIONS requests to proxy of Node
 */
export async function connectOptionsNodeProxy(
  requestParameters: ConnectOptionsNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectOptionsNodeProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect OPTIONS requests to proxy of Node
 */
export async function connectOptionsNodeProxyWithPathRaw(
  requestParameters: ConnectOptionsNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectOptionsNodeProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectOptionsNodeProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'OPTIONS',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect OPTIONS requests to proxy of Node
 */
export async function connectOptionsNodeProxyWithPath(
  requestParameters: ConnectOptionsNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectOptionsNodeProxyWithPathRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect PATCH requests to proxy of Pod
 */
export async function connectPatchNamespacedPodProxyRaw(
  requestParameters: ConnectPatchNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedPodProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedPodProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PATCH requests to proxy of Pod
 */
export async function connectPatchNamespacedPodProxy(
  requestParameters: ConnectPatchNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPatchNamespacedPodProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect PATCH requests to proxy of Pod
 */
export async function connectPatchNamespacedPodProxyWithPathRaw(
  requestParameters: ConnectPatchNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPatchNamespacedPodProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PATCH requests to proxy of Pod
 */
export async function connectPatchNamespacedPodProxyWithPath(
  requestParameters: ConnectPatchNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPatchNamespacedPodProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect PATCH requests to proxy of Service
 */
export async function connectPatchNamespacedServiceProxyRaw(
  requestParameters: ConnectPatchNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedServiceProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedServiceProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PATCH requests to proxy of Service
 */
export async function connectPatchNamespacedServiceProxy(
  requestParameters: ConnectPatchNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPatchNamespacedServiceProxyRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect PATCH requests to proxy of Service
 */
export async function connectPatchNamespacedServiceProxyWithPathRaw(
  requestParameters: ConnectPatchNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PATCH requests to proxy of Service
 */
export async function connectPatchNamespacedServiceProxyWithPath(
  requestParameters: ConnectPatchNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPatchNamespacedServiceProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect PATCH requests to proxy of Node
 */
export async function connectPatchNodeProxyRaw(
  requestParameters: ConnectPatchNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPatchNodeProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PATCH requests to proxy of Node
 */
export async function connectPatchNodeProxy(
  requestParameters: ConnectPatchNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPatchNodeProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect PATCH requests to proxy of Node
 */
export async function connectPatchNodeProxyWithPathRaw(
  requestParameters: ConnectPatchNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPatchNodeProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPatchNodeProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PATCH requests to proxy of Node
 */
export async function connectPatchNodeProxyWithPath(
  requestParameters: ConnectPatchNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPatchNodeProxyWithPathRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect POST requests to attach of Pod
 */
export async function connectPostNamespacedPodAttachRaw(
  requestParameters: ConnectPostNamespacedPodAttachRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodAttach.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodAttach.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.container !== undefined) {
    queryParameters['container'] = requestParameters.container
  }
  if (requestParameters.stderr !== undefined) {
    queryParameters['stderr'] = requestParameters.stderr
  }
  if (requestParameters.stdin !== undefined) {
    queryParameters['stdin'] = requestParameters.stdin
  }
  if (requestParameters.stdout !== undefined) {
    queryParameters['stdout'] = requestParameters.stdout
  }
  if (requestParameters.tty !== undefined) {
    queryParameters['tty'] = requestParameters.tty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to attach of Pod
 */
export async function connectPostNamespacedPodAttach(
  requestParameters: ConnectPostNamespacedPodAttachRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNamespacedPodAttachRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect POST requests to exec of Pod
 */
export async function connectPostNamespacedPodExecRaw(
  requestParameters: ConnectPostNamespacedPodExecRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodExec.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodExec.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.command !== undefined) {
    queryParameters['command'] = requestParameters.command
  }
  if (requestParameters.container !== undefined) {
    queryParameters['container'] = requestParameters.container
  }
  if (requestParameters.stderr !== undefined) {
    queryParameters['stderr'] = requestParameters.stderr
  }
  if (requestParameters.stdin !== undefined) {
    queryParameters['stdin'] = requestParameters.stdin
  }
  if (requestParameters.stdout !== undefined) {
    queryParameters['stdout'] = requestParameters.stdout
  }
  if (requestParameters.tty !== undefined) {
    queryParameters['tty'] = requestParameters.tty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to exec of Pod
 */
export async function connectPostNamespacedPodExec(
  requestParameters: ConnectPostNamespacedPodExecRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNamespacedPodExecRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect POST requests to portforward of Pod
 */
export async function connectPostNamespacedPodPortforwardRaw(
  requestParameters: ConnectPostNamespacedPodPortforwardRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodPortforward.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodPortforward.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.ports !== undefined) {
    queryParameters['ports'] = requestParameters.ports
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to portforward of Pod
 */
export async function connectPostNamespacedPodPortforward(
  requestParameters: ConnectPostNamespacedPodPortforwardRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNamespacedPodPortforwardRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect POST requests to proxy of Pod
 */
export async function connectPostNamespacedPodProxyRaw(
  requestParameters: ConnectPostNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to proxy of Pod
 */
export async function connectPostNamespacedPodProxy(
  requestParameters: ConnectPostNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNamespacedPodProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect POST requests to proxy of Pod
 */
export async function connectPostNamespacedPodProxyWithPathRaw(
  requestParameters: ConnectPostNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPostNamespacedPodProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to proxy of Pod
 */
export async function connectPostNamespacedPodProxyWithPath(
  requestParameters: ConnectPostNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNamespacedPodProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect POST requests to proxy of Service
 */
export async function connectPostNamespacedServiceProxyRaw(
  requestParameters: ConnectPostNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedServiceProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedServiceProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to proxy of Service
 */
export async function connectPostNamespacedServiceProxy(
  requestParameters: ConnectPostNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNamespacedServiceProxyRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect POST requests to proxy of Service
 */
export async function connectPostNamespacedServiceProxyWithPathRaw(
  requestParameters: ConnectPostNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPostNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPostNamespacedServiceProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to proxy of Service
 */
export async function connectPostNamespacedServiceProxyWithPath(
  requestParameters: ConnectPostNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNamespacedServiceProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect POST requests to proxy of Node
 */
export async function connectPostNodeProxyRaw(
  requestParameters: ConnectPostNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNodeProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to proxy of Node
 */
export async function connectPostNodeProxy(
  requestParameters: ConnectPostNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNodeProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect POST requests to proxy of Node
 */
export async function connectPostNodeProxyWithPathRaw(
  requestParameters: ConnectPostNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPostNodeProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPostNodeProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect POST requests to proxy of Node
 */
export async function connectPostNodeProxyWithPath(
  requestParameters: ConnectPostNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPostNodeProxyWithPathRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect PUT requests to proxy of Pod
 */
export async function connectPutNamespacedPodProxyRaw(
  requestParameters: ConnectPutNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedPodProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedPodProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PUT requests to proxy of Pod
 */
export async function connectPutNamespacedPodProxy(
  requestParameters: ConnectPutNamespacedPodProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPutNamespacedPodProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect PUT requests to proxy of Pod
 */
export async function connectPutNamespacedPodProxyWithPathRaw(
  requestParameters: ConnectPutNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedPodProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPutNamespacedPodProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PUT requests to proxy of Pod
 */
export async function connectPutNamespacedPodProxyWithPath(
  requestParameters: ConnectPutNamespacedPodProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPutNamespacedPodProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect PUT requests to proxy of Service
 */
export async function connectPutNamespacedServiceProxyRaw(
  requestParameters: ConnectPutNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedServiceProxy.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedServiceProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PUT requests to proxy of Service
 */
export async function connectPutNamespacedServiceProxy(
  requestParameters: ConnectPutNamespacedServiceProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPutNamespacedServiceProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect PUT requests to proxy of Service
 */
export async function connectPutNamespacedServiceProxyWithPathRaw(
  requestParameters: ConnectPutNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPutNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling connectPutNamespacedServiceProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPutNamespacedServiceProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PUT requests to proxy of Service
 */
export async function connectPutNamespacedServiceProxyWithPath(
  requestParameters: ConnectPutNamespacedServiceProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPutNamespacedServiceProxyWithPathRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * connect PUT requests to proxy of Node
 */
export async function connectPutNodeProxyRaw(
  requestParameters: ConnectPutNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPutNodeProxy.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path !== undefined) {
    queryParameters['path'] = requestParameters.path
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PUT requests to proxy of Node
 */
export async function connectPutNodeProxy(
  requestParameters: ConnectPutNodeProxyRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPutNodeProxyRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * connect PUT requests to proxy of Node
 */
export async function connectPutNodeProxyWithPathRaw(
  requestParameters: ConnectPutNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling connectPutNodeProxyWithPath.'
    )
  }
  if (requestParameters.path === null || requestParameters.path === undefined) {
    throw new Error(
      'Required parameter requestParameters.path was null or undefined when calling connectPutNodeProxyWithPath.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.path2 !== undefined) {
    queryParameters['path'] = requestParameters.path2
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/proxy/{path}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'path'}}`, encodeURIComponent(String(requestParameters.path))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * connect PUT requests to proxy of Node
 */
export async function connectPutNodeProxyWithPath(
  requestParameters: ConnectPutNodeProxyWithPathRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await connectPutNodeProxyWithPathRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Namespace
 */
export async function createNamespaceRaw(
  requestParameters: CreateNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespace.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Namespace
 */
export async function createNamespace(
  requestParameters: CreateNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await createNamespaceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Binding
 */
export async function createNamespacedBindingRaw(
  requestParameters: CreateNamespacedBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Binding>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedBinding.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/bindings`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Binding
 */
export async function createNamespacedBinding(
  requestParameters: CreateNamespacedBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Binding> {
  const response = await createNamespacedBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a ConfigMap
 */
export async function createNamespacedConfigMapRaw(
  requestParameters: CreateNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ConfigMap>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedConfigMap.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ConfigMap
 */
export async function createNamespacedConfigMap(
  requestParameters: CreateNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ConfigMap> {
  const response = await createNamespacedConfigMapRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create Endpoints
 */
export async function createNamespacedEndpointsRaw(
  requestParameters: CreateNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Endpoints>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedEndpoints.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create Endpoints
 */
export async function createNamespacedEndpoints(
  requestParameters: CreateNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Endpoints> {
  const response = await createNamespacedEndpointsRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create an Event
 */
export async function createNamespacedEventRaw(
  requestParameters: CreateNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Event>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedEvent.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/events`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create an Event
 */
export async function createNamespacedEvent(
  requestParameters: CreateNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Event> {
  const response = await createNamespacedEventRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a LimitRange
 */
export async function createNamespacedLimitRangeRaw(
  requestParameters: CreateNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1LimitRange>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedLimitRange.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a LimitRange
 */
export async function createNamespacedLimitRange(
  requestParameters: CreateNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1LimitRange> {
  const response = await createNamespacedLimitRangeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a PersistentVolumeClaim
 */
export async function createNamespacedPersistentVolumeClaimRaw(
  requestParameters: CreateNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaim>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPersistentVolumeClaim.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a PersistentVolumeClaim
 */
export async function createNamespacedPersistentVolumeClaim(
  requestParameters: CreateNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaim> {
  const response = await createNamespacedPersistentVolumeClaimRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * create a Pod
 */
export async function createNamespacedPodRaw(
  requestParameters: CreateNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Pod>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPod.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Pod
 */
export async function createNamespacedPod(
  requestParameters: CreateNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Pod> {
  const response = await createNamespacedPodRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create binding of a Pod
 */
export async function createNamespacedPodBindingRaw(
  requestParameters: CreateNamespacedPodBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Binding>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling createNamespacedPodBinding.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodBinding.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedPodBinding.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/binding`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create binding of a Pod
 */
export async function createNamespacedPodBinding(
  requestParameters: CreateNamespacedPodBindingRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Binding> {
  const response = await createNamespacedPodBindingRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create eviction of a Pod
 */
export async function createNamespacedPodEvictionRaw(
  requestParameters: CreateNamespacedPodEvictionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1Eviction>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling createNamespacedPodEviction.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodEviction.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedPodEviction.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/eviction`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create eviction of a Pod
 */
export async function createNamespacedPodEviction(
  requestParameters: CreateNamespacedPodEvictionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1Eviction> {
  const response = await createNamespacedPodEvictionRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a PodTemplate
 */
export async function createNamespacedPodTemplateRaw(
  requestParameters: CreateNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodTemplate>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedPodTemplate.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a PodTemplate
 */
export async function createNamespacedPodTemplate(
  requestParameters: CreateNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodTemplate> {
  const response = await createNamespacedPodTemplateRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a ReplicationController
 */
export async function createNamespacedReplicationControllerRaw(
  requestParameters: CreateNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationController>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedReplicationController.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ReplicationController
 */
export async function createNamespacedReplicationController(
  requestParameters: CreateNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationController> {
  const response = await createNamespacedReplicationControllerRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * create a ResourceQuota
 */
export async function createNamespacedResourceQuotaRaw(
  requestParameters: CreateNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuota>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedResourceQuota.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ResourceQuota
 */
export async function createNamespacedResourceQuota(
  requestParameters: CreateNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuota> {
  const response = await createNamespacedResourceQuotaRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Secret
 */
export async function createNamespacedSecretRaw(
  requestParameters: CreateNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Secret>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedSecret.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/secrets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Secret
 */
export async function createNamespacedSecret(
  requestParameters: CreateNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Secret> {
  const response = await createNamespacedSecretRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Service
 */
export async function createNamespacedServiceRaw(
  requestParameters: CreateNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Service>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedService.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedService.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Service
 */
export async function createNamespacedService(
  requestParameters: CreateNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Service> {
  const response = await createNamespacedServiceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a ServiceAccount
 */
export async function createNamespacedServiceAccountRaw(
  requestParameters: CreateNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceAccount>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedServiceAccount.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ServiceAccount
 */
export async function createNamespacedServiceAccount(
  requestParameters: CreateNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceAccount> {
  const response = await createNamespacedServiceAccountRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Node
 */
export async function createNodeRaw(
  requestParameters: CreateNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Node>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Node
 */
export async function createNode(
  requestParameters: CreateNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Node> {
  const response = await createNodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a PersistentVolume
 */
export async function createPersistentVolumeRaw(
  requestParameters: CreatePersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolume>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createPersistentVolume.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a PersistentVolume
 */
export async function createPersistentVolume(
  requestParameters: CreatePersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolume> {
  const response = await createPersistentVolumeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of ConfigMap
 */
export async function deleteCollectionNamespacedConfigMapRaw(
  requestParameters: DeleteCollectionNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ConfigMap
 */
export async function deleteCollectionNamespacedConfigMap(
  requestParameters: DeleteCollectionNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedConfigMapRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Endpoints
 */
export async function deleteCollectionNamespacedEndpointsRaw(
  requestParameters: DeleteCollectionNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Endpoints
 */
export async function deleteCollectionNamespacedEndpoints(
  requestParameters: DeleteCollectionNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedEndpointsRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Event
 */
export async function deleteCollectionNamespacedEventRaw(
  requestParameters: DeleteCollectionNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/events`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Event
 */
export async function deleteCollectionNamespacedEvent(
  requestParameters: DeleteCollectionNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedEventRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of LimitRange
 */
export async function deleteCollectionNamespacedLimitRangeRaw(
  requestParameters: DeleteCollectionNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of LimitRange
 */
export async function deleteCollectionNamespacedLimitRange(
  requestParameters: DeleteCollectionNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedLimitRangeRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of PersistentVolumeClaim
 */
export async function deleteCollectionNamespacedPersistentVolumeClaimRaw(
  requestParameters: DeleteCollectionNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of PersistentVolumeClaim
 */
export async function deleteCollectionNamespacedPersistentVolumeClaim(
  requestParameters: DeleteCollectionNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedPersistentVolumeClaimRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Pod
 */
export async function deleteCollectionNamespacedPodRaw(
  requestParameters: DeleteCollectionNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Pod
 */
export async function deleteCollectionNamespacedPod(
  requestParameters: DeleteCollectionNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedPodRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of PodTemplate
 */
export async function deleteCollectionNamespacedPodTemplateRaw(
  requestParameters: DeleteCollectionNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of PodTemplate
 */
export async function deleteCollectionNamespacedPodTemplate(
  requestParameters: DeleteCollectionNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedPodTemplateRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of ReplicationController
 */
export async function deleteCollectionNamespacedReplicationControllerRaw(
  requestParameters: DeleteCollectionNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ReplicationController
 */
export async function deleteCollectionNamespacedReplicationController(
  requestParameters: DeleteCollectionNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedReplicationControllerRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of ResourceQuota
 */
export async function deleteCollectionNamespacedResourceQuotaRaw(
  requestParameters: DeleteCollectionNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ResourceQuota
 */
export async function deleteCollectionNamespacedResourceQuota(
  requestParameters: DeleteCollectionNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedResourceQuotaRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Secret
 */
export async function deleteCollectionNamespacedSecretRaw(
  requestParameters: DeleteCollectionNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/secrets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Secret
 */
export async function deleteCollectionNamespacedSecret(
  requestParameters: DeleteCollectionNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedSecretRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of ServiceAccount
 */
export async function deleteCollectionNamespacedServiceAccountRaw(
  requestParameters: DeleteCollectionNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ServiceAccount
 */
export async function deleteCollectionNamespacedServiceAccount(
  requestParameters: DeleteCollectionNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedServiceAccountRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Node
 */
export async function deleteCollectionNodeRaw(
  requestParameters: DeleteCollectionNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Node
 */
export async function deleteCollectionNode(
  requestParameters: DeleteCollectionNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of PersistentVolume
 */
export async function deleteCollectionPersistentVolumeRaw(
  requestParameters: DeleteCollectionPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of PersistentVolume
 */
export async function deleteCollectionPersistentVolume(
  requestParameters: DeleteCollectionPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionPersistentVolumeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a Namespace
 */
export async function deleteNamespaceRaw(
  requestParameters: DeleteNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespace.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Namespace
 */
export async function deleteNamespace(
  requestParameters: DeleteNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespaceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a ConfigMap
 */
export async function deleteNamespacedConfigMapRaw(
  requestParameters: DeleteNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedConfigMap.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ConfigMap
 */
export async function deleteNamespacedConfigMap(
  requestParameters: DeleteNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedConfigMapRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete Endpoints
 */
export async function deleteNamespacedEndpointsRaw(
  requestParameters: DeleteNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedEndpoints.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete Endpoints
 */
export async function deleteNamespacedEndpoints(
  requestParameters: DeleteNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedEndpointsRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete an Event
 */
export async function deleteNamespacedEventRaw(
  requestParameters: DeleteNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedEvent.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete an Event
 */
export async function deleteNamespacedEvent(
  requestParameters: DeleteNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedEventRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a LimitRange
 */
export async function deleteNamespacedLimitRangeRaw(
  requestParameters: DeleteNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedLimitRange.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a LimitRange
 */
export async function deleteNamespacedLimitRange(
  requestParameters: DeleteNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedLimitRangeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a PersistentVolumeClaim
 */
export async function deleteNamespacedPersistentVolumeClaimRaw(
  requestParameters: DeleteNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPersistentVolumeClaim.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a PersistentVolumeClaim
 */
export async function deleteNamespacedPersistentVolumeClaim(
  requestParameters: DeleteNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedPersistentVolumeClaimRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete a Pod
 */
export async function deleteNamespacedPodRaw(
  requestParameters: DeleteNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPod.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Pod
 */
export async function deleteNamespacedPod(
  requestParameters: DeleteNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedPodRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a PodTemplate
 */
export async function deleteNamespacedPodTemplateRaw(
  requestParameters: DeleteNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedPodTemplate.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a PodTemplate
 */
export async function deleteNamespacedPodTemplate(
  requestParameters: DeleteNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedPodTemplateRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a ReplicationController
 */
export async function deleteNamespacedReplicationControllerRaw(
  requestParameters: DeleteNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedReplicationController.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ReplicationController
 */
export async function deleteNamespacedReplicationController(
  requestParameters: DeleteNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedReplicationControllerRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete a ResourceQuota
 */
export async function deleteNamespacedResourceQuotaRaw(
  requestParameters: DeleteNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedResourceQuota.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ResourceQuota
 */
export async function deleteNamespacedResourceQuota(
  requestParameters: DeleteNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedResourceQuotaRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a Secret
 */
export async function deleteNamespacedSecretRaw(
  requestParameters: DeleteNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedSecret.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Secret
 */
export async function deleteNamespacedSecret(
  requestParameters: DeleteNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedSecretRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a Service
 */
export async function deleteNamespacedServiceRaw(
  requestParameters: DeleteNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedService.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedService.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Service
 */
export async function deleteNamespacedService(
  requestParameters: DeleteNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedServiceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a ServiceAccount
 */
export async function deleteNamespacedServiceAccountRaw(
  requestParameters: DeleteNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedServiceAccount.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ServiceAccount
 */
export async function deleteNamespacedServiceAccount(
  requestParameters: DeleteNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedServiceAccountRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a Node
 */
export async function deleteNodeRaw(
  requestParameters: DeleteNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Node
 */
export async function deleteNode(
  requestParameters: DeleteNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a PersistentVolume
 */
export async function deletePersistentVolumeRaw(
  requestParameters: DeletePersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deletePersistentVolume.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a PersistentVolume
 */
export async function deletePersistentVolume(
  requestParameters: DeletePersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deletePersistentVolumeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * get available resources
 */
export async function getAPIResourcesRaw(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1APIResourceList>> {
  const queryParameters: HTTPQuery = {}
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * get available resources
 */
export async function getAPIResources(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1APIResourceList> {
  const response = await getAPIResourcesRaw(...requestOptsArray)
  return await response.value()
}

/**
 * list objects of kind ComponentStatus
 */
export async function watchListComponentStatus(
  requestParameters: ListComponentStatusRequest,
  callback: (event: KubeEvent<ItemType<V1ComponentStatusList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ComponentStatusList>>(
    callback,
    {
      path: `/api/v1/componentstatuses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list objects of kind ComponentStatus
 */
export async function listComponentStatusRaw(
  requestParameters: ListComponentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ComponentStatusList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/componentstatuses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list objects of kind ComponentStatus
 */
export async function listComponentStatus(
  requestParameters: ListComponentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ComponentStatusList> {
  const response = await listComponentStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ConfigMap
 */
export async function watchListConfigMapForAllNamespaces(
  requestParameters: ListConfigMapForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1ConfigMapList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ConfigMapList>>(
    callback,
    {
      path: `/api/v1/configmaps`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ConfigMap
 */
export async function listConfigMapForAllNamespacesRaw(
  requestParameters: ListConfigMapForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ConfigMapList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/configmaps`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ConfigMap
 */
export async function listConfigMapForAllNamespaces(
  requestParameters: ListConfigMapForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ConfigMapList> {
  const response = await listConfigMapForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Endpoints
 */
export async function watchListEndpointsForAllNamespaces(
  requestParameters: ListEndpointsForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1EndpointsList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1EndpointsList>>(
    callback,
    {
      path: `/api/v1/endpoints`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Endpoints
 */
export async function listEndpointsForAllNamespacesRaw(
  requestParameters: ListEndpointsForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1EndpointsList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/endpoints`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Endpoints
 */
export async function listEndpointsForAllNamespaces(
  requestParameters: ListEndpointsForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1EndpointsList> {
  const response = await listEndpointsForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Event
 */
export async function watchListEventForAllNamespaces(
  requestParameters: ListEventForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1EventList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1EventList>>(
    callback,
    {
      path: `/api/v1/events`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Event
 */
export async function listEventForAllNamespacesRaw(
  requestParameters: ListEventForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1EventList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/events`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Event
 */
export async function listEventForAllNamespaces(
  requestParameters: ListEventForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1EventList> {
  const response = await listEventForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind LimitRange
 */
export async function watchListLimitRangeForAllNamespaces(
  requestParameters: ListLimitRangeForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1LimitRangeList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1LimitRangeList>>(
    callback,
    {
      path: `/api/v1/limitranges`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind LimitRange
 */
export async function listLimitRangeForAllNamespacesRaw(
  requestParameters: ListLimitRangeForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1LimitRangeList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/limitranges`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind LimitRange
 */
export async function listLimitRangeForAllNamespaces(
  requestParameters: ListLimitRangeForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1LimitRangeList> {
  const response = await listLimitRangeForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Namespace
 */
export async function watchListNamespace(
  requestParameters: ListNamespaceRequest,
  callback: (event: KubeEvent<ItemType<V1NamespaceList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1NamespaceList>>(
    callback,
    {
      path: `/api/v1/namespaces`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Namespace
 */
export async function listNamespaceRaw(
  requestParameters: ListNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1NamespaceList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Namespace
 */
export async function listNamespace(
  requestParameters: ListNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1NamespaceList> {
  const response = await listNamespaceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ConfigMap
 */
export async function watchListNamespacedConfigMap(
  requestParameters: ListNamespacedConfigMapRequest,
  callback: (event: KubeEvent<ItemType<V1ConfigMapList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ConfigMapList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ConfigMap
 */
export async function listNamespacedConfigMapRaw(
  requestParameters: ListNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ConfigMapList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/configmaps`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ConfigMap
 */
export async function listNamespacedConfigMap(
  requestParameters: ListNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ConfigMapList> {
  const response = await listNamespacedConfigMapRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Endpoints
 */
export async function watchListNamespacedEndpoints(
  requestParameters: ListNamespacedEndpointsRequest,
  callback: (event: KubeEvent<ItemType<V1EndpointsList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1EndpointsList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Endpoints
 */
export async function listNamespacedEndpointsRaw(
  requestParameters: ListNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1EndpointsList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/endpoints`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Endpoints
 */
export async function listNamespacedEndpoints(
  requestParameters: ListNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1EndpointsList> {
  const response = await listNamespacedEndpointsRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Event
 */
export async function watchListNamespacedEvent(
  requestParameters: ListNamespacedEventRequest,
  callback: (event: KubeEvent<ItemType<V1EventList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1EventList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/events`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Event
 */
export async function listNamespacedEventRaw(
  requestParameters: ListNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1EventList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/events`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Event
 */
export async function listNamespacedEvent(
  requestParameters: ListNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1EventList> {
  const response = await listNamespacedEventRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind LimitRange
 */
export async function watchListNamespacedLimitRange(
  requestParameters: ListNamespacedLimitRangeRequest,
  callback: (event: KubeEvent<ItemType<V1LimitRangeList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1LimitRangeList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind LimitRange
 */
export async function listNamespacedLimitRangeRaw(
  requestParameters: ListNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1LimitRangeList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/limitranges`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind LimitRange
 */
export async function listNamespacedLimitRange(
  requestParameters: ListNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1LimitRangeList> {
  const response = await listNamespacedLimitRangeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind PersistentVolumeClaim
 */
export async function watchListNamespacedPersistentVolumeClaim(
  requestParameters: ListNamespacedPersistentVolumeClaimRequest,
  callback: (event: KubeEvent<ItemType<V1PersistentVolumeClaimList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1PersistentVolumeClaimList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind PersistentVolumeClaim
 */
export async function listNamespacedPersistentVolumeClaimRaw(
  requestParameters: ListNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaimList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind PersistentVolumeClaim
 */
export async function listNamespacedPersistentVolumeClaim(
  requestParameters: ListNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaimList> {
  const response = await listNamespacedPersistentVolumeClaimRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind Pod
 */
export async function watchListNamespacedPod(
  requestParameters: ListNamespacedPodRequest,
  callback: (event: KubeEvent<ItemType<V1PodList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1PodList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/pods`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Pod
 */
export async function listNamespacedPodRaw(
  requestParameters: ListNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Pod
 */
export async function listNamespacedPod(
  requestParameters: ListNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodList> {
  const response = await listNamespacedPodRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind PodTemplate
 */
export async function watchListNamespacedPodTemplate(
  requestParameters: ListNamespacedPodTemplateRequest,
  callback: (event: KubeEvent<ItemType<V1PodTemplateList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1PodTemplateList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind PodTemplate
 */
export async function listNamespacedPodTemplateRaw(
  requestParameters: ListNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodTemplateList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind PodTemplate
 */
export async function listNamespacedPodTemplate(
  requestParameters: ListNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodTemplateList> {
  const response = await listNamespacedPodTemplateRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ReplicationController
 */
export async function watchListNamespacedReplicationController(
  requestParameters: ListNamespacedReplicationControllerRequest,
  callback: (event: KubeEvent<ItemType<V1ReplicationControllerList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ReplicationControllerList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ReplicationController
 */
export async function listNamespacedReplicationControllerRaw(
  requestParameters: ListNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationControllerList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ReplicationController
 */
export async function listNamespacedReplicationController(
  requestParameters: ListNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationControllerList> {
  const response = await listNamespacedReplicationControllerRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind ResourceQuota
 */
export async function watchListNamespacedResourceQuota(
  requestParameters: ListNamespacedResourceQuotaRequest,
  callback: (event: KubeEvent<ItemType<V1ResourceQuotaList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ResourceQuotaList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ResourceQuota
 */
export async function listNamespacedResourceQuotaRaw(
  requestParameters: ListNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuotaList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ResourceQuota
 */
export async function listNamespacedResourceQuota(
  requestParameters: ListNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuotaList> {
  const response = await listNamespacedResourceQuotaRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Secret
 */
export async function watchListNamespacedSecret(
  requestParameters: ListNamespacedSecretRequest,
  callback: (event: KubeEvent<ItemType<V1SecretList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1SecretList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/secrets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Secret
 */
export async function listNamespacedSecretRaw(
  requestParameters: ListNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1SecretList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/secrets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Secret
 */
export async function listNamespacedSecret(
  requestParameters: ListNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1SecretList> {
  const response = await listNamespacedSecretRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Service
 */
export async function watchListNamespacedService(
  requestParameters: ListNamespacedServiceRequest,
  callback: (event: KubeEvent<ItemType<V1ServiceList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedService.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ServiceList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/services`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Service
 */
export async function listNamespacedServiceRaw(
  requestParameters: ListNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedService.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Service
 */
export async function listNamespacedService(
  requestParameters: ListNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceList> {
  const response = await listNamespacedServiceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ServiceAccount
 */
export async function watchListNamespacedServiceAccount(
  requestParameters: ListNamespacedServiceAccountRequest,
  callback: (event: KubeEvent<ItemType<V1ServiceAccountList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ServiceAccountList>>(
    callback,
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ServiceAccount
 */
export async function listNamespacedServiceAccountRaw(
  requestParameters: ListNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceAccountList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ServiceAccount
 */
export async function listNamespacedServiceAccount(
  requestParameters: ListNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceAccountList> {
  const response = await listNamespacedServiceAccountRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Node
 */
export async function watchListNode(
  requestParameters: ListNodeRequest,
  callback: (event: KubeEvent<ItemType<V1NodeList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1NodeList>>(
    callback,
    {
      path: `/api/v1/nodes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Node
 */
export async function listNodeRaw(
  requestParameters: ListNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1NodeList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Node
 */
export async function listNode(
  requestParameters: ListNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1NodeList> {
  const response = await listNodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind PersistentVolume
 */
export async function watchListPersistentVolume(
  requestParameters: ListPersistentVolumeRequest,
  callback: (event: KubeEvent<ItemType<V1PersistentVolumeList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1PersistentVolumeList>>(
    callback,
    {
      path: `/api/v1/persistentvolumes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind PersistentVolume
 */
export async function listPersistentVolumeRaw(
  requestParameters: ListPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind PersistentVolume
 */
export async function listPersistentVolume(
  requestParameters: ListPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeList> {
  const response = await listPersistentVolumeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind PersistentVolumeClaim
 */
export async function watchListPersistentVolumeClaimForAllNamespaces(
  requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1PersistentVolumeClaimList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1PersistentVolumeClaimList>>(
    callback,
    {
      path: `/api/v1/persistentvolumeclaims`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind PersistentVolumeClaim
 */
export async function listPersistentVolumeClaimForAllNamespacesRaw(
  requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaimList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumeclaims`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind PersistentVolumeClaim
 */
export async function listPersistentVolumeClaimForAllNamespaces(
  requestParameters: ListPersistentVolumeClaimForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaimList> {
  const response = await listPersistentVolumeClaimForAllNamespacesRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind Pod
 */
export async function watchListPodForAllNamespaces(
  requestParameters: ListPodForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1PodList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1PodList>>(
    callback,
    {
      path: `/api/v1/pods`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Pod
 */
export async function listPodForAllNamespacesRaw(
  requestParameters: ListPodForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/pods`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Pod
 */
export async function listPodForAllNamespaces(
  requestParameters: ListPodForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodList> {
  const response = await listPodForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind PodTemplate
 */
export async function watchListPodTemplateForAllNamespaces(
  requestParameters: ListPodTemplateForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1PodTemplateList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1PodTemplateList>>(
    callback,
    {
      path: `/api/v1/podtemplates`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind PodTemplate
 */
export async function listPodTemplateForAllNamespacesRaw(
  requestParameters: ListPodTemplateForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodTemplateList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/podtemplates`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind PodTemplate
 */
export async function listPodTemplateForAllNamespaces(
  requestParameters: ListPodTemplateForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodTemplateList> {
  const response = await listPodTemplateForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ReplicationController
 */
export async function watchListReplicationControllerForAllNamespaces(
  requestParameters: ListReplicationControllerForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1ReplicationControllerList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ReplicationControllerList>>(
    callback,
    {
      path: `/api/v1/replicationcontrollers`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ReplicationController
 */
export async function listReplicationControllerForAllNamespacesRaw(
  requestParameters: ListReplicationControllerForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationControllerList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/replicationcontrollers`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ReplicationController
 */
export async function listReplicationControllerForAllNamespaces(
  requestParameters: ListReplicationControllerForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationControllerList> {
  const response = await listReplicationControllerForAllNamespacesRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind ResourceQuota
 */
export async function watchListResourceQuotaForAllNamespaces(
  requestParameters: ListResourceQuotaForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1ResourceQuotaList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ResourceQuotaList>>(
    callback,
    {
      path: `/api/v1/resourcequotas`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ResourceQuota
 */
export async function listResourceQuotaForAllNamespacesRaw(
  requestParameters: ListResourceQuotaForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuotaList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/resourcequotas`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ResourceQuota
 */
export async function listResourceQuotaForAllNamespaces(
  requestParameters: ListResourceQuotaForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuotaList> {
  const response = await listResourceQuotaForAllNamespacesRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind Secret
 */
export async function watchListSecretForAllNamespaces(
  requestParameters: ListSecretForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1SecretList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1SecretList>>(
    callback,
    {
      path: `/api/v1/secrets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Secret
 */
export async function listSecretForAllNamespacesRaw(
  requestParameters: ListSecretForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1SecretList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/secrets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Secret
 */
export async function listSecretForAllNamespaces(
  requestParameters: ListSecretForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1SecretList> {
  const response = await listSecretForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ServiceAccount
 */
export async function watchListServiceAccountForAllNamespaces(
  requestParameters: ListServiceAccountForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1ServiceAccountList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ServiceAccountList>>(
    callback,
    {
      path: `/api/v1/serviceaccounts`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ServiceAccount
 */
export async function listServiceAccountForAllNamespacesRaw(
  requestParameters: ListServiceAccountForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceAccountList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/serviceaccounts`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ServiceAccount
 */
export async function listServiceAccountForAllNamespaces(
  requestParameters: ListServiceAccountForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceAccountList> {
  const response = await listServiceAccountForAllNamespacesRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind Service
 */
export async function watchListServiceForAllNamespaces(
  requestParameters: ListServiceForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1ServiceList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ServiceList>>(
    callback,
    {
      path: `/api/v1/services`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Service
 */
export async function listServiceForAllNamespacesRaw(
  requestParameters: ListServiceForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/services`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Service
 */
export async function listServiceForAllNamespaces(
  requestParameters: ListServiceForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceList> {
  const response = await listServiceForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Namespace
 */
export async function patchNamespaceRaw(
  requestParameters: PatchNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespace.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespace.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Namespace
 */
export async function patchNamespace(
  requestParameters: PatchNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await patchNamespaceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Namespace
 */
export async function patchNamespaceStatusRaw(
  requestParameters: PatchNamespaceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespaceStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespaceStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Namespace
 */
export async function patchNamespaceStatus(
  requestParameters: PatchNamespaceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await patchNamespaceStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ConfigMap
 */
export async function patchNamespacedConfigMapRaw(
  requestParameters: PatchNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ConfigMap>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedConfigMap.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedConfigMap.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ConfigMap
 */
export async function patchNamespacedConfigMap(
  requestParameters: PatchNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ConfigMap> {
  const response = await patchNamespacedConfigMapRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Endpoints
 */
export async function patchNamespacedEndpointsRaw(
  requestParameters: PatchNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Endpoints>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedEndpoints.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedEndpoints.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Endpoints
 */
export async function patchNamespacedEndpoints(
  requestParameters: PatchNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Endpoints> {
  const response = await patchNamespacedEndpointsRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Event
 */
export async function patchNamespacedEventRaw(
  requestParameters: PatchNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Event>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedEvent.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedEvent.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Event
 */
export async function patchNamespacedEvent(
  requestParameters: PatchNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Event> {
  const response = await patchNamespacedEventRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified LimitRange
 */
export async function patchNamespacedLimitRangeRaw(
  requestParameters: PatchNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1LimitRange>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedLimitRange.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedLimitRange.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified LimitRange
 */
export async function patchNamespacedLimitRange(
  requestParameters: PatchNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1LimitRange> {
  const response = await patchNamespacedLimitRangeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified PersistentVolumeClaim
 */
export async function patchNamespacedPersistentVolumeClaimRaw(
  requestParameters: PatchNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaim>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPersistentVolumeClaim.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPersistentVolumeClaim.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified PersistentVolumeClaim
 */
export async function patchNamespacedPersistentVolumeClaim(
  requestParameters: PatchNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaim> {
  const response = await patchNamespacedPersistentVolumeClaimRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update status of the specified PersistentVolumeClaim
 */
export async function patchNamespacedPersistentVolumeClaimStatusRaw(
  requestParameters: PatchNamespacedPersistentVolumeClaimStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaim>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified PersistentVolumeClaim
 */
export async function patchNamespacedPersistentVolumeClaimStatus(
  requestParameters: PatchNamespacedPersistentVolumeClaimStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaim> {
  const response = await patchNamespacedPersistentVolumeClaimStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update the specified Pod
 */
export async function patchNamespacedPodRaw(
  requestParameters: PatchNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Pod>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPod.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPod.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Pod
 */
export async function patchNamespacedPod(
  requestParameters: PatchNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Pod> {
  const response = await patchNamespacedPodRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Pod
 */
export async function patchNamespacedPodStatusRaw(
  requestParameters: PatchNamespacedPodStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Pod>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPodStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPodStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPodStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Pod
 */
export async function patchNamespacedPodStatus(
  requestParameters: PatchNamespacedPodStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Pod> {
  const response = await patchNamespacedPodStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified PodTemplate
 */
export async function patchNamespacedPodTemplateRaw(
  requestParameters: PatchNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodTemplate>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedPodTemplate.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedPodTemplate.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified PodTemplate
 */
export async function patchNamespacedPodTemplate(
  requestParameters: PatchNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodTemplate> {
  const response = await patchNamespacedPodTemplateRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ReplicationController
 */
export async function patchNamespacedReplicationControllerRaw(
  requestParameters: PatchNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationController>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationController.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationController.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ReplicationController
 */
export async function patchNamespacedReplicationController(
  requestParameters: PatchNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationController> {
  const response = await patchNamespacedReplicationControllerRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update scale of the specified ReplicationController
 */
export async function patchNamespacedReplicationControllerScaleRaw(
  requestParameters: PatchNamespacedReplicationControllerScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update scale of the specified ReplicationController
 */
export async function patchNamespacedReplicationControllerScale(
  requestParameters: PatchNamespacedReplicationControllerScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await patchNamespacedReplicationControllerScaleRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update status of the specified ReplicationController
 */
export async function patchNamespacedReplicationControllerStatusRaw(
  requestParameters: PatchNamespacedReplicationControllerStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationController>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicationControllerStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicationControllerStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicationControllerStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified ReplicationController
 */
export async function patchNamespacedReplicationControllerStatus(
  requestParameters: PatchNamespacedReplicationControllerStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationController> {
  const response = await patchNamespacedReplicationControllerStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update the specified ResourceQuota
 */
export async function patchNamespacedResourceQuotaRaw(
  requestParameters: PatchNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuota>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedResourceQuota.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedResourceQuota.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ResourceQuota
 */
export async function patchNamespacedResourceQuota(
  requestParameters: PatchNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuota> {
  const response = await patchNamespacedResourceQuotaRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified ResourceQuota
 */
export async function patchNamespacedResourceQuotaStatusRaw(
  requestParameters: PatchNamespacedResourceQuotaStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuota>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedResourceQuotaStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedResourceQuotaStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedResourceQuotaStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified ResourceQuota
 */
export async function patchNamespacedResourceQuotaStatus(
  requestParameters: PatchNamespacedResourceQuotaStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuota> {
  const response = await patchNamespacedResourceQuotaStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update the specified Secret
 */
export async function patchNamespacedSecretRaw(
  requestParameters: PatchNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Secret>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedSecret.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedSecret.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Secret
 */
export async function patchNamespacedSecret(
  requestParameters: PatchNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Secret> {
  const response = await patchNamespacedSecretRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Service
 */
export async function patchNamespacedServiceRaw(
  requestParameters: PatchNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Service>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedService.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedService.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedService.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Service
 */
export async function patchNamespacedService(
  requestParameters: PatchNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Service> {
  const response = await patchNamespacedServiceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ServiceAccount
 */
export async function patchNamespacedServiceAccountRaw(
  requestParameters: PatchNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceAccount>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedServiceAccount.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedServiceAccount.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ServiceAccount
 */
export async function patchNamespacedServiceAccount(
  requestParameters: PatchNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceAccount> {
  const response = await patchNamespacedServiceAccountRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Service
 */
export async function patchNamespacedServiceStatusRaw(
  requestParameters: PatchNamespacedServiceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Service>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedServiceStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedServiceStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedServiceStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Service
 */
export async function patchNamespacedServiceStatus(
  requestParameters: PatchNamespacedServiceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Service> {
  const response = await patchNamespacedServiceStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Node
 */
export async function patchNodeRaw(
  requestParameters: PatchNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Node>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNode.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Node
 */
export async function patchNode(
  requestParameters: PatchNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Node> {
  const response = await patchNodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Node
 */
export async function patchNodeStatusRaw(
  requestParameters: PatchNodeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Node>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNodeStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNodeStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Node
 */
export async function patchNodeStatus(
  requestParameters: PatchNodeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Node> {
  const response = await patchNodeStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified PersistentVolume
 */
export async function patchPersistentVolumeRaw(
  requestParameters: PatchPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolume>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchPersistentVolume.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchPersistentVolume.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified PersistentVolume
 */
export async function patchPersistentVolume(
  requestParameters: PatchPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolume> {
  const response = await patchPersistentVolumeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified PersistentVolume
 */
export async function patchPersistentVolumeStatusRaw(
  requestParameters: PatchPersistentVolumeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolume>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchPersistentVolumeStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchPersistentVolumeStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified PersistentVolume
 */
export async function patchPersistentVolumeStatus(
  requestParameters: PatchPersistentVolumeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolume> {
  const response = await patchPersistentVolumeStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ComponentStatus
 */
export async function readComponentStatusRaw(
  requestParameters: ReadComponentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ComponentStatus>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readComponentStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/componentstatuses/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ComponentStatus
 */
export async function readComponentStatus(
  requestParameters: ReadComponentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ComponentStatus> {
  const response = await readComponentStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Namespace
 */
export async function readNamespaceRaw(
  requestParameters: ReadNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespace.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Namespace
 */
export async function readNamespace(
  requestParameters: ReadNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await readNamespaceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Namespace
 */
export async function readNamespaceStatusRaw(
  requestParameters: ReadNamespaceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespaceStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Namespace
 */
export async function readNamespaceStatus(
  requestParameters: ReadNamespaceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await readNamespaceStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ConfigMap
 */
export async function readNamespacedConfigMapRaw(
  requestParameters: ReadNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ConfigMap>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedConfigMap.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ConfigMap
 */
export async function readNamespacedConfigMap(
  requestParameters: ReadNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ConfigMap> {
  const response = await readNamespacedConfigMapRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Endpoints
 */
export async function readNamespacedEndpointsRaw(
  requestParameters: ReadNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Endpoints>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedEndpoints.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Endpoints
 */
export async function readNamespacedEndpoints(
  requestParameters: ReadNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Endpoints> {
  const response = await readNamespacedEndpointsRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Event
 */
export async function readNamespacedEventRaw(
  requestParameters: ReadNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Event>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedEvent.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Event
 */
export async function readNamespacedEvent(
  requestParameters: ReadNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Event> {
  const response = await readNamespacedEventRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified LimitRange
 */
export async function readNamespacedLimitRangeRaw(
  requestParameters: ReadNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1LimitRange>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedLimitRange.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified LimitRange
 */
export async function readNamespacedLimitRange(
  requestParameters: ReadNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1LimitRange> {
  const response = await readNamespacedLimitRangeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified PersistentVolumeClaim
 */
export async function readNamespacedPersistentVolumeClaimRaw(
  requestParameters: ReadNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaim>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedPersistentVolumeClaim.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified PersistentVolumeClaim
 */
export async function readNamespacedPersistentVolumeClaim(
  requestParameters: ReadNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaim> {
  const response = await readNamespacedPersistentVolumeClaimRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * read status of the specified PersistentVolumeClaim
 */
export async function readNamespacedPersistentVolumeClaimStatusRaw(
  requestParameters: ReadNamespacedPersistentVolumeClaimStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaim>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified PersistentVolumeClaim
 */
export async function readNamespacedPersistentVolumeClaimStatus(
  requestParameters: ReadNamespacedPersistentVolumeClaimStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaim> {
  const response = await readNamespacedPersistentVolumeClaimStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * read the specified Pod
 */
export async function readNamespacedPodRaw(
  requestParameters: ReadNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Pod>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedPod.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Pod
 */
export async function readNamespacedPod(
  requestParameters: ReadNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Pod> {
  const response = await readNamespacedPodRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read log of the specified Pod
 */
export async function readNamespacedPodLogRaw(
  requestParameters: ReadNamespacedPodLogRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<string>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedPodLog.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodLog.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.container !== undefined) {
    queryParameters['container'] = requestParameters.container
  }
  if (requestParameters.follow !== undefined) {
    queryParameters['follow'] = requestParameters.follow
  }
  if (requestParameters.limitBytes !== undefined) {
    queryParameters['limitBytes'] = requestParameters.limitBytes
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.previous !== undefined) {
    queryParameters['previous'] = requestParameters.previous
  }
  if (requestParameters.sinceSeconds !== undefined) {
    queryParameters['sinceSeconds'] = requestParameters.sinceSeconds
  }
  if (requestParameters.tailLines !== undefined) {
    queryParameters['tailLines'] = requestParameters.tailLines
  }
  if (requestParameters.timestamps !== undefined) {
    queryParameters['timestamps'] = requestParameters.timestamps
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/log`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new StringApiResponse(response)
}

/**
 * read log of the specified Pod
 */
export async function readNamespacedPodLog(
  requestParameters: ReadNamespacedPodLogRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<string> {
  const response = await readNamespacedPodLogRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Pod
 */
export async function readNamespacedPodStatusRaw(
  requestParameters: ReadNamespacedPodStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Pod>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedPodStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Pod
 */
export async function readNamespacedPodStatus(
  requestParameters: ReadNamespacedPodStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Pod> {
  const response = await readNamespacedPodStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified PodTemplate
 */
export async function readNamespacedPodTemplateRaw(
  requestParameters: ReadNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodTemplate>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedPodTemplate.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified PodTemplate
 */
export async function readNamespacedPodTemplate(
  requestParameters: ReadNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodTemplate> {
  const response = await readNamespacedPodTemplateRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ReplicationController
 */
export async function readNamespacedReplicationControllerRaw(
  requestParameters: ReadNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationController>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationController.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ReplicationController
 */
export async function readNamespacedReplicationController(
  requestParameters: ReadNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationController> {
  const response = await readNamespacedReplicationControllerRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * read scale of the specified ReplicationController
 */
export async function readNamespacedReplicationControllerScaleRaw(
  requestParameters: ReadNamespacedReplicationControllerScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read scale of the specified ReplicationController
 */
export async function readNamespacedReplicationControllerScale(
  requestParameters: ReadNamespacedReplicationControllerScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await readNamespacedReplicationControllerScaleRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * read status of the specified ReplicationController
 */
export async function readNamespacedReplicationControllerStatusRaw(
  requestParameters: ReadNamespacedReplicationControllerStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationController>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicationControllerStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicationControllerStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified ReplicationController
 */
export async function readNamespacedReplicationControllerStatus(
  requestParameters: ReadNamespacedReplicationControllerStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationController> {
  const response = await readNamespacedReplicationControllerStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * read the specified ResourceQuota
 */
export async function readNamespacedResourceQuotaRaw(
  requestParameters: ReadNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuota>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedResourceQuota.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ResourceQuota
 */
export async function readNamespacedResourceQuota(
  requestParameters: ReadNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuota> {
  const response = await readNamespacedResourceQuotaRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified ResourceQuota
 */
export async function readNamespacedResourceQuotaStatusRaw(
  requestParameters: ReadNamespacedResourceQuotaStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuota>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedResourceQuotaStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedResourceQuotaStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified ResourceQuota
 */
export async function readNamespacedResourceQuotaStatus(
  requestParameters: ReadNamespacedResourceQuotaStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuota> {
  const response = await readNamespacedResourceQuotaStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * read the specified Secret
 */
export async function readNamespacedSecretRaw(
  requestParameters: ReadNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Secret>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedSecret.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Secret
 */
export async function readNamespacedSecret(
  requestParameters: ReadNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Secret> {
  const response = await readNamespacedSecretRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Service
 */
export async function readNamespacedServiceRaw(
  requestParameters: ReadNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Service>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedService.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedService.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Service
 */
export async function readNamespacedService(
  requestParameters: ReadNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Service> {
  const response = await readNamespacedServiceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ServiceAccount
 */
export async function readNamespacedServiceAccountRaw(
  requestParameters: ReadNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceAccount>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedServiceAccount.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ServiceAccount
 */
export async function readNamespacedServiceAccount(
  requestParameters: ReadNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceAccount> {
  const response = await readNamespacedServiceAccountRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Service
 */
export async function readNamespacedServiceStatusRaw(
  requestParameters: ReadNamespacedServiceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Service>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedServiceStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedServiceStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Service
 */
export async function readNamespacedServiceStatus(
  requestParameters: ReadNamespacedServiceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Service> {
  const response = await readNamespacedServiceStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Node
 */
export async function readNodeRaw(
  requestParameters: ReadNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Node>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Node
 */
export async function readNode(
  requestParameters: ReadNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Node> {
  const response = await readNodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Node
 */
export async function readNodeStatusRaw(
  requestParameters: ReadNodeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Node>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNodeStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Node
 */
export async function readNodeStatus(
  requestParameters: ReadNodeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Node> {
  const response = await readNodeStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified PersistentVolume
 */
export async function readPersistentVolumeRaw(
  requestParameters: ReadPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolume>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readPersistentVolume.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified PersistentVolume
 */
export async function readPersistentVolume(
  requestParameters: ReadPersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolume> {
  const response = await readPersistentVolumeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified PersistentVolume
 */
export async function readPersistentVolumeStatusRaw(
  requestParameters: ReadPersistentVolumeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolume>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readPersistentVolumeStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified PersistentVolume
 */
export async function readPersistentVolumeStatus(
  requestParameters: ReadPersistentVolumeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolume> {
  const response = await readPersistentVolumeStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Namespace
 */
export async function replaceNamespaceRaw(
  requestParameters: ReplaceNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespace.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespace.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Namespace
 */
export async function replaceNamespace(
  requestParameters: ReplaceNamespaceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await replaceNamespaceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace finalize of the specified Namespace
 */
export async function replaceNamespaceFinalizeRaw(
  requestParameters: ReplaceNamespaceFinalizeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespaceFinalize.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespaceFinalize.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}/finalize`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace finalize of the specified Namespace
 */
export async function replaceNamespaceFinalize(
  requestParameters: ReplaceNamespaceFinalizeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await replaceNamespaceFinalizeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Namespace
 */
export async function replaceNamespaceStatusRaw(
  requestParameters: ReplaceNamespaceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Namespace>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespaceStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespaceStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Namespace
 */
export async function replaceNamespaceStatus(
  requestParameters: ReplaceNamespaceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Namespace> {
  const response = await replaceNamespaceStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified ConfigMap
 */
export async function replaceNamespacedConfigMapRaw(
  requestParameters: ReplaceNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ConfigMap>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedConfigMap.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedConfigMap.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedConfigMap.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/configmaps/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ConfigMap
 */
export async function replaceNamespacedConfigMap(
  requestParameters: ReplaceNamespacedConfigMapRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ConfigMap> {
  const response = await replaceNamespacedConfigMapRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Endpoints
 */
export async function replaceNamespacedEndpointsRaw(
  requestParameters: ReplaceNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Endpoints>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedEndpoints.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedEndpoints.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedEndpoints.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/endpoints/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Endpoints
 */
export async function replaceNamespacedEndpoints(
  requestParameters: ReplaceNamespacedEndpointsRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Endpoints> {
  const response = await replaceNamespacedEndpointsRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Event
 */
export async function replaceNamespacedEventRaw(
  requestParameters: ReplaceNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Event>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedEvent.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedEvent.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedEvent.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/events/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Event
 */
export async function replaceNamespacedEvent(
  requestParameters: ReplaceNamespacedEventRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Event> {
  const response = await replaceNamespacedEventRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified LimitRange
 */
export async function replaceNamespacedLimitRangeRaw(
  requestParameters: ReplaceNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1LimitRange>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedLimitRange.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedLimitRange.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedLimitRange.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/limitranges/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified LimitRange
 */
export async function replaceNamespacedLimitRange(
  requestParameters: ReplaceNamespacedLimitRangeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1LimitRange> {
  const response = await replaceNamespacedLimitRangeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified PersistentVolumeClaim
 */
export async function replaceNamespacedPersistentVolumeClaimRaw(
  requestParameters: ReplaceNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaim>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPersistentVolumeClaim.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaim.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPersistentVolumeClaim.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified PersistentVolumeClaim
 */
export async function replaceNamespacedPersistentVolumeClaim(
  requestParameters: ReplaceNamespacedPersistentVolumeClaimRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaim> {
  const response = await replaceNamespacedPersistentVolumeClaimRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace status of the specified PersistentVolumeClaim
 */
export async function replaceNamespacedPersistentVolumeClaimStatusRaw(
  requestParameters: ReplaceNamespacedPersistentVolumeClaimStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolumeClaim>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified PersistentVolumeClaim
 */
export async function replaceNamespacedPersistentVolumeClaimStatus(
  requestParameters: ReplaceNamespacedPersistentVolumeClaimStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolumeClaim> {
  const response = await replaceNamespacedPersistentVolumeClaimStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified Pod
 */
export async function replaceNamespacedPodRaw(
  requestParameters: ReplaceNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Pod>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPod.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPod.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPod.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Pod
 */
export async function replaceNamespacedPod(
  requestParameters: ReplaceNamespacedPodRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Pod> {
  const response = await replaceNamespacedPodRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Pod
 */
export async function replaceNamespacedPodStatusRaw(
  requestParameters: ReplaceNamespacedPodStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Pod>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPodStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPodStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPodStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/pods/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Pod
 */
export async function replaceNamespacedPodStatus(
  requestParameters: ReplaceNamespacedPodStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Pod> {
  const response = await replaceNamespacedPodStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified PodTemplate
 */
export async function replaceNamespacedPodTemplateRaw(
  requestParameters: ReplaceNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PodTemplate>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedPodTemplate.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedPodTemplate.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedPodTemplate.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified PodTemplate
 */
export async function replaceNamespacedPodTemplate(
  requestParameters: ReplaceNamespacedPodTemplateRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PodTemplate> {
  const response = await replaceNamespacedPodTemplateRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified ReplicationController
 */
export async function replaceNamespacedReplicationControllerRaw(
  requestParameters: ReplaceNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationController>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationController.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationController.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationController.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ReplicationController
 */
export async function replaceNamespacedReplicationController(
  requestParameters: ReplaceNamespacedReplicationControllerRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationController> {
  const response = await replaceNamespacedReplicationControllerRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace scale of the specified ReplicationController
 */
export async function replaceNamespacedReplicationControllerScaleRaw(
  requestParameters: ReplaceNamespacedReplicationControllerScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace scale of the specified ReplicationController
 */
export async function replaceNamespacedReplicationControllerScale(
  requestParameters: ReplaceNamespacedReplicationControllerScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await replaceNamespacedReplicationControllerScaleRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace status of the specified ReplicationController
 */
export async function replaceNamespacedReplicationControllerStatusRaw(
  requestParameters: ReplaceNamespacedReplicationControllerStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicationController>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicationControllerStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicationControllerStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicationControllerStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified ReplicationController
 */
export async function replaceNamespacedReplicationControllerStatus(
  requestParameters: ReplaceNamespacedReplicationControllerStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicationController> {
  const response = await replaceNamespacedReplicationControllerStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified ResourceQuota
 */
export async function replaceNamespacedResourceQuotaRaw(
  requestParameters: ReplaceNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuota>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedResourceQuota.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedResourceQuota.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedResourceQuota.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ResourceQuota
 */
export async function replaceNamespacedResourceQuota(
  requestParameters: ReplaceNamespacedResourceQuotaRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuota> {
  const response = await replaceNamespacedResourceQuotaRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified ResourceQuota
 */
export async function replaceNamespacedResourceQuotaStatusRaw(
  requestParameters: ReplaceNamespacedResourceQuotaStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ResourceQuota>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedResourceQuotaStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedResourceQuotaStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedResourceQuotaStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified ResourceQuota
 */
export async function replaceNamespacedResourceQuotaStatus(
  requestParameters: ReplaceNamespacedResourceQuotaStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ResourceQuota> {
  const response = await replaceNamespacedResourceQuotaStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified Secret
 */
export async function replaceNamespacedSecretRaw(
  requestParameters: ReplaceNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Secret>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedSecret.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedSecret.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedSecret.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/secrets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Secret
 */
export async function replaceNamespacedSecret(
  requestParameters: ReplaceNamespacedSecretRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Secret> {
  const response = await replaceNamespacedSecretRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Service
 */
export async function replaceNamespacedServiceRaw(
  requestParameters: ReplaceNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Service>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedService.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedService.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedService.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Service
 */
export async function replaceNamespacedService(
  requestParameters: ReplaceNamespacedServiceRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Service> {
  const response = await replaceNamespacedServiceRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified ServiceAccount
 */
export async function replaceNamespacedServiceAccountRaw(
  requestParameters: ReplaceNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ServiceAccount>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedServiceAccount.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedServiceAccount.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedServiceAccount.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ServiceAccount
 */
export async function replaceNamespacedServiceAccount(
  requestParameters: ReplaceNamespacedServiceAccountRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ServiceAccount> {
  const response = await replaceNamespacedServiceAccountRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Service
 */
export async function replaceNamespacedServiceStatusRaw(
  requestParameters: ReplaceNamespacedServiceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Service>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedServiceStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedServiceStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedServiceStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/namespaces/{namespace}/services/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Service
 */
export async function replaceNamespacedServiceStatus(
  requestParameters: ReplaceNamespacedServiceStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Service> {
  const response = await replaceNamespacedServiceStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Node
 */
export async function replaceNodeRaw(
  requestParameters: ReplaceNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Node>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNode.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Node
 */
export async function replaceNode(
  requestParameters: ReplaceNodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Node> {
  const response = await replaceNodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Node
 */
export async function replaceNodeStatusRaw(
  requestParameters: ReplaceNodeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Node>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNodeStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNodeStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/nodes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Node
 */
export async function replaceNodeStatus(
  requestParameters: ReplaceNodeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Node> {
  const response = await replaceNodeStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified PersistentVolume
 */
export async function replacePersistentVolumeRaw(
  requestParameters: ReplacePersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolume>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replacePersistentVolume.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replacePersistentVolume.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified PersistentVolume
 */
export async function replacePersistentVolume(
  requestParameters: ReplacePersistentVolumeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolume> {
  const response = await replacePersistentVolumeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified PersistentVolume
 */
export async function replacePersistentVolumeStatusRaw(
  requestParameters: ReplacePersistentVolumeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1PersistentVolume>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replacePersistentVolumeStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replacePersistentVolumeStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/api/v1/persistentvolumes/{name}/status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified PersistentVolume
 */
export async function replacePersistentVolumeStatus(
  requestParameters: ReplacePersistentVolumeStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1PersistentVolume> {
  const response = await replacePersistentVolumeStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}
