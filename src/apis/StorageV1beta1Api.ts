// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.14.11
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  RequestOpts,
  HTTPHeaders,
  HTTPQuery,
  ApiResponse,
  StringApiResponse,
  JSONApiResponse,
  ItemType,
  KubeEvent,
  request,
  requestStream
} from '../runtime'
import V1APIResourceList from '../models/V1APIResourceList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Status from '../models/V1Status'
import V1beta1CSIDriver from '../models/V1beta1CSIDriver'
import V1beta1CSIDriverList from '../models/V1beta1CSIDriverList'
import V1beta1CSINode from '../models/V1beta1CSINode'
import V1beta1CSINodeList from '../models/V1beta1CSINodeList'
import V1beta1StorageClass from '../models/V1beta1StorageClass'
import V1beta1StorageClassList from '../models/V1beta1StorageClassList'
import V1beta1VolumeAttachment from '../models/V1beta1VolumeAttachment'
import V1beta1VolumeAttachmentList from '../models/V1beta1VolumeAttachmentList'

interface CreateCSIDriverRequest {
  body: V1beta1CSIDriver
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateCSINodeRequest {
  body: V1beta1CSINode
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateStorageClassRequest {
  body: V1beta1StorageClass
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateVolumeAttachmentRequest {
  body: V1beta1VolumeAttachment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface DeleteCSIDriverRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteCSINodeRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteCollectionCSIDriverRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionCSINodeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionStorageClassRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionVolumeAttachmentRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteStorageClassRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteVolumeAttachmentRequest {
  name: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface ListCSIDriverRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListCSINodeRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListStorageClassRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListVolumeAttachmentRequest {
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface PatchCSIDriverRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchCSINodeRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchStorageClassRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchVolumeAttachmentRequest {
  name: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface ReadCSIDriverRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadCSINodeRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadStorageClassRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadVolumeAttachmentRequest {
  name: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReplaceCSIDriverRequest {
  name: string
  body: V1beta1CSIDriver
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceCSINodeRequest {
  name: string
  body: V1beta1CSINode
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceStorageClassRequest {
  name: string
  body: V1beta1StorageClass
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceVolumeAttachmentRequest {
  name: string
  body: V1beta1VolumeAttachment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

/**
 * create a CSIDriver
 */
export async function createCSIDriverRaw(
  requestParameters: CreateCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSIDriver>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createCSIDriver.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a CSIDriver
 */
export async function createCSIDriver(
  requestParameters: CreateCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSIDriver> {
  const response = await createCSIDriverRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a CSINode
 */
export async function createCSINodeRaw(
  requestParameters: CreateCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSINode>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createCSINode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a CSINode
 */
export async function createCSINode(
  requestParameters: CreateCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSINode> {
  const response = await createCSINodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a StorageClass
 */
export async function createStorageClassRaw(
  requestParameters: CreateStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1StorageClass>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createStorageClass.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a StorageClass
 */
export async function createStorageClass(
  requestParameters: CreateStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1StorageClass> {
  const response = await createStorageClassRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a VolumeAttachment
 */
export async function createVolumeAttachmentRaw(
  requestParameters: CreateVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1VolumeAttachment>> {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createVolumeAttachment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a VolumeAttachment
 */
export async function createVolumeAttachment(
  requestParameters: CreateVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1VolumeAttachment> {
  const response = await createVolumeAttachmentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a CSIDriver
 */
export async function deleteCSIDriverRaw(
  requestParameters: DeleteCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteCSIDriver.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a CSIDriver
 */
export async function deleteCSIDriver(
  requestParameters: DeleteCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCSIDriverRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a CSINode
 */
export async function deleteCSINodeRaw(
  requestParameters: DeleteCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteCSINode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a CSINode
 */
export async function deleteCSINode(
  requestParameters: DeleteCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCSINodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of CSIDriver
 */
export async function deleteCollectionCSIDriverRaw(
  requestParameters: DeleteCollectionCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of CSIDriver
 */
export async function deleteCollectionCSIDriver(
  requestParameters: DeleteCollectionCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionCSIDriverRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of CSINode
 */
export async function deleteCollectionCSINodeRaw(
  requestParameters: DeleteCollectionCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of CSINode
 */
export async function deleteCollectionCSINode(
  requestParameters: DeleteCollectionCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionCSINodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of StorageClass
 */
export async function deleteCollectionStorageClassRaw(
  requestParameters: DeleteCollectionStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of StorageClass
 */
export async function deleteCollectionStorageClass(
  requestParameters: DeleteCollectionStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionStorageClassRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of VolumeAttachment
 */
export async function deleteCollectionVolumeAttachmentRaw(
  requestParameters: DeleteCollectionVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments`,
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of VolumeAttachment
 */
export async function deleteCollectionVolumeAttachment(
  requestParameters: DeleteCollectionVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionVolumeAttachmentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a StorageClass
 */
export async function deleteStorageClassRaw(
  requestParameters: DeleteStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteStorageClass.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a StorageClass
 */
export async function deleteStorageClass(
  requestParameters: DeleteStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteStorageClassRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a VolumeAttachment
 */
export async function deleteVolumeAttachmentRaw(
  requestParameters: DeleteVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteVolumeAttachment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a VolumeAttachment
 */
export async function deleteVolumeAttachment(
  requestParameters: DeleteVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteVolumeAttachmentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * get available resources
 */
export async function getAPIResourcesRaw(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1APIResourceList>> {
  const queryParameters: HTTPQuery = {}
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * get available resources
 */
export async function getAPIResources(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1APIResourceList> {
  const response = await getAPIResourcesRaw(...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind CSIDriver
 */
export async function watchListCSIDriver(
  requestParameters: ListCSIDriverRequest,
  callback: (event: KubeEvent<ItemType<V1beta1CSIDriverList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1CSIDriverList>>(
    callback,
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind CSIDriver
 */
export async function listCSIDriverRaw(
  requestParameters: ListCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSIDriverList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind CSIDriver
 */
export async function listCSIDriver(
  requestParameters: ListCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSIDriverList> {
  const response = await listCSIDriverRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind CSINode
 */
export async function watchListCSINode(
  requestParameters: ListCSINodeRequest,
  callback: (event: KubeEvent<ItemType<V1beta1CSINodeList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1CSINodeList>>(
    callback,
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind CSINode
 */
export async function listCSINodeRaw(
  requestParameters: ListCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSINodeList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind CSINode
 */
export async function listCSINode(
  requestParameters: ListCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSINodeList> {
  const response = await listCSINodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind StorageClass
 */
export async function watchListStorageClass(
  requestParameters: ListStorageClassRequest,
  callback: (event: KubeEvent<ItemType<V1beta1StorageClassList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1StorageClassList>>(
    callback,
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind StorageClass
 */
export async function listStorageClassRaw(
  requestParameters: ListStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1StorageClassList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind StorageClass
 */
export async function listStorageClass(
  requestParameters: ListStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1StorageClassList> {
  const response = await listStorageClassRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind VolumeAttachment
 */
export async function watchListVolumeAttachment(
  requestParameters: ListVolumeAttachmentRequest,
  callback: (event: KubeEvent<ItemType<V1beta1VolumeAttachmentList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1beta1VolumeAttachmentList>>(
    callback,
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind VolumeAttachment
 */
export async function listVolumeAttachmentRaw(
  requestParameters: ListVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1VolumeAttachmentList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind VolumeAttachment
 */
export async function listVolumeAttachment(
  requestParameters: ListVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1VolumeAttachmentList> {
  const response = await listVolumeAttachmentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified CSIDriver
 */
export async function patchCSIDriverRaw(
  requestParameters: PatchCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSIDriver>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchCSIDriver.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchCSIDriver.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified CSIDriver
 */
export async function patchCSIDriver(
  requestParameters: PatchCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSIDriver> {
  const response = await patchCSIDriverRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified CSINode
 */
export async function patchCSINodeRaw(
  requestParameters: PatchCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSINode>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchCSINode.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchCSINode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified CSINode
 */
export async function patchCSINode(
  requestParameters: PatchCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSINode> {
  const response = await patchCSINodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified StorageClass
 */
export async function patchStorageClassRaw(
  requestParameters: PatchStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1StorageClass>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchStorageClass.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchStorageClass.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified StorageClass
 */
export async function patchStorageClass(
  requestParameters: PatchStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1StorageClass> {
  const response = await patchStorageClassRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified VolumeAttachment
 */
export async function patchVolumeAttachmentRaw(
  requestParameters: PatchVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1VolumeAttachment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchVolumeAttachment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchVolumeAttachment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified VolumeAttachment
 */
export async function patchVolumeAttachment(
  requestParameters: PatchVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1VolumeAttachment> {
  const response = await patchVolumeAttachmentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified CSIDriver
 */
export async function readCSIDriverRaw(
  requestParameters: ReadCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSIDriver>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readCSIDriver.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified CSIDriver
 */
export async function readCSIDriver(
  requestParameters: ReadCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSIDriver> {
  const response = await readCSIDriverRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified CSINode
 */
export async function readCSINodeRaw(
  requestParameters: ReadCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSINode>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readCSINode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified CSINode
 */
export async function readCSINode(
  requestParameters: ReadCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSINode> {
  const response = await readCSINodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified StorageClass
 */
export async function readStorageClassRaw(
  requestParameters: ReadStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1StorageClass>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readStorageClass.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified StorageClass
 */
export async function readStorageClass(
  requestParameters: ReadStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1StorageClass> {
  const response = await readStorageClassRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified VolumeAttachment
 */
export async function readVolumeAttachmentRaw(
  requestParameters: ReadVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1VolumeAttachment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readVolumeAttachment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified VolumeAttachment
 */
export async function readVolumeAttachment(
  requestParameters: ReadVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1VolumeAttachment> {
  const response = await readVolumeAttachmentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified CSIDriver
 */
export async function replaceCSIDriverRaw(
  requestParameters: ReplaceCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSIDriver>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceCSIDriver.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceCSIDriver.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csidrivers/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified CSIDriver
 */
export async function replaceCSIDriver(
  requestParameters: ReplaceCSIDriverRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSIDriver> {
  const response = await replaceCSIDriverRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified CSINode
 */
export async function replaceCSINodeRaw(
  requestParameters: ReplaceCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1CSINode>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceCSINode.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceCSINode.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/csinodes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified CSINode
 */
export async function replaceCSINode(
  requestParameters: ReplaceCSINodeRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1CSINode> {
  const response = await replaceCSINodeRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified StorageClass
 */
export async function replaceStorageClassRaw(
  requestParameters: ReplaceStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1StorageClass>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceStorageClass.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceStorageClass.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/storageclasses/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified StorageClass
 */
export async function replaceStorageClass(
  requestParameters: ReplaceStorageClassRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1StorageClass> {
  const response = await replaceStorageClassRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified VolumeAttachment
 */
export async function replaceVolumeAttachmentRaw(
  requestParameters: ReplaceVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1beta1VolumeAttachment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceVolumeAttachment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceVolumeAttachment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/storage.k8s.io/v1beta1/volumeattachments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(requestParameters.name))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified VolumeAttachment
 */
export async function replaceVolumeAttachment(
  requestParameters: ReplaceVolumeAttachmentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1beta1VolumeAttachment> {
  const response = await replaceVolumeAttachmentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}
