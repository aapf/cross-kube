// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.14.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import V1APIResourceList from '../models/V1APIResourceList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Status from '../models/V1Status'
import V1beta2ControllerRevision from '../models/V1beta2ControllerRevision'
import V1beta2ControllerRevisionList from '../models/V1beta2ControllerRevisionList'
import V1beta2DaemonSet from '../models/V1beta2DaemonSet'
import V1beta2DaemonSetList from '../models/V1beta2DaemonSetList'
import V1beta2Deployment from '../models/V1beta2Deployment'
import V1beta2DeploymentList from '../models/V1beta2DeploymentList'
import V1beta2ReplicaSet from '../models/V1beta2ReplicaSet'
import V1beta2ReplicaSetList from '../models/V1beta2ReplicaSetList'
import V1beta2Scale from '../models/V1beta2Scale'
import V1beta2StatefulSet from '../models/V1beta2StatefulSet'
import V1beta2StatefulSetList from '../models/V1beta2StatefulSetList'

interface CreateNamespacedControllerRevisionRequest {
  namespace: string
  body: V1beta2ControllerRevision
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDaemonSetRequest {
  namespace: string
  body: V1beta2DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDeploymentRequest {
  namespace: string
  body: V1beta2Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedReplicaSetRequest {
  namespace: string
  body: V1beta2ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedStatefulSetRequest {
  namespace: string
  body: V1beta2StatefulSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface DeleteCollectionNamespacedControllerRevisionRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedStatefulSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedStatefulSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface ListControllerRevisionForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListDaemonSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListDeploymentForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedControllerRevisionRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedStatefulSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListReplicaSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListStatefulSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface PatchNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedStatefulSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedStatefulSetScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedStatefulSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface ReadNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedStatefulSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedStatefulSetScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedStatefulSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReplaceNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  body: V1beta2ControllerRevision
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: V1beta2DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: V1beta2DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: V1beta2Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: V1beta2Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: V1beta2Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: V1beta2ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: V1beta2Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: V1beta2ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedStatefulSetRequest {
  name: string
  namespace: string
  body: V1beta2StatefulSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedStatefulSetScaleRequest {
  name: string
  namespace: string
  body: V1beta2Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedStatefulSetStatusRequest {
  name: string
  namespace: string
  body: V1beta2StatefulSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

/**
 *
 */
export default class AppsV1beta2Api extends runtime.BaseAPI {
  /**
   * create a ControllerRevision
   */
  async createNamespacedControllerRevisionRaw(
    requestParameters: CreateNamespacedControllerRevisionRequest
  ): Promise<runtime.ApiResponse<V1beta2ControllerRevision>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedControllerRevision.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a ControllerRevision
   */
  async createNamespacedControllerRevision(
    requestParameters: CreateNamespacedControllerRevisionRequest
  ): Promise<V1beta2ControllerRevision> {
    const response = await this.createNamespacedControllerRevisionRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a DaemonSet
   */
  async createNamespacedDaemonSetRaw(
    requestParameters: CreateNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSet>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDaemonSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a DaemonSet
   */
  async createNamespacedDaemonSet(
    requestParameters: CreateNamespacedDaemonSetRequest
  ): Promise<V1beta2DaemonSet> {
    const response = await this.createNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a Deployment
   */
  async createNamespacedDeploymentRaw(
    requestParameters: CreateNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1beta2Deployment>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDeployment.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a Deployment
   */
  async createNamespacedDeployment(
    requestParameters: CreateNamespacedDeploymentRequest
  ): Promise<V1beta2Deployment> {
    const response = await this.createNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a ReplicaSet
   */
  async createNamespacedReplicaSetRaw(
    requestParameters: CreateNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSet>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedReplicaSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a ReplicaSet
   */
  async createNamespacedReplicaSet(
    requestParameters: CreateNamespacedReplicaSetRequest
  ): Promise<V1beta2ReplicaSet> {
    const response = await this.createNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * create a StatefulSet
   */
  async createNamespacedStatefulSetRaw(
    requestParameters: CreateNamespacedStatefulSetRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSet>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedStatefulSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling createNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * create a StatefulSet
   */
  async createNamespacedStatefulSet(
    requestParameters: CreateNamespacedStatefulSetRequest
  ): Promise<V1beta2StatefulSet> {
    const response = await this.createNamespacedStatefulSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of ControllerRevision
   */
  async deleteCollectionNamespacedControllerRevisionRaw(
    requestParameters: DeleteCollectionNamespacedControllerRevisionRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of ControllerRevision
   */
  async deleteCollectionNamespacedControllerRevision(
    requestParameters: DeleteCollectionNamespacedControllerRevisionRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedControllerRevisionRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of DaemonSet
   */
  async deleteCollectionNamespacedDaemonSetRaw(
    requestParameters: DeleteCollectionNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of DaemonSet
   */
  async deleteCollectionNamespacedDaemonSet(
    requestParameters: DeleteCollectionNamespacedDaemonSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of Deployment
   */
  async deleteCollectionNamespacedDeploymentRaw(
    requestParameters: DeleteCollectionNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of Deployment
   */
  async deleteCollectionNamespacedDeployment(
    requestParameters: DeleteCollectionNamespacedDeploymentRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of ReplicaSet
   */
  async deleteCollectionNamespacedReplicaSetRaw(
    requestParameters: DeleteCollectionNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of ReplicaSet
   */
  async deleteCollectionNamespacedReplicaSet(
    requestParameters: DeleteCollectionNamespacedReplicaSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete collection of StatefulSet
   */
  async deleteCollectionNamespacedStatefulSetRaw(
    requestParameters: DeleteCollectionNamespacedStatefulSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete collection of StatefulSet
   */
  async deleteCollectionNamespacedStatefulSet(
    requestParameters: DeleteCollectionNamespacedStatefulSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteCollectionNamespacedStatefulSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a ControllerRevision
   */
  async deleteNamespacedControllerRevisionRaw(
    requestParameters: DeleteNamespacedControllerRevisionRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedControllerRevision.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a ControllerRevision
   */
  async deleteNamespacedControllerRevision(
    requestParameters: DeleteNamespacedControllerRevisionRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedControllerRevisionRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a DaemonSet
   */
  async deleteNamespacedDaemonSetRaw(
    requestParameters: DeleteNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a DaemonSet
   */
  async deleteNamespacedDaemonSet(
    requestParameters: DeleteNamespacedDaemonSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a Deployment
   */
  async deleteNamespacedDeploymentRaw(
    requestParameters: DeleteNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a Deployment
   */
  async deleteNamespacedDeployment(
    requestParameters: DeleteNamespacedDeploymentRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a ReplicaSet
   */
  async deleteNamespacedReplicaSetRaw(
    requestParameters: DeleteNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a ReplicaSet
   */
  async deleteNamespacedReplicaSet(
    requestParameters: DeleteNamespacedReplicaSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete a StatefulSet
   */
  async deleteNamespacedStatefulSetRaw(
    requestParameters: DeleteNamespacedStatefulSetRequest
  ): Promise<runtime.ApiResponse<V1Status>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedStatefulSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.gracePeriodSeconds !== undefined) {
      queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
    }
    if (requestParameters.orphanDependents !== undefined) {
      queryParameters['orphanDependents'] = requestParameters.orphanDependents
    }
    if (requestParameters.propagationPolicy !== undefined) {
      queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * delete a StatefulSet
   */
  async deleteNamespacedStatefulSet(
    requestParameters: DeleteNamespacedStatefulSetRequest
  ): Promise<V1Status> {
    const response = await this.deleteNamespacedStatefulSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * get available resources
   */
  async getAPIResourcesRaw(): Promise<runtime.ApiResponse<V1APIResourceList>> {
    const queryParameters: runtime.HTTPQuery = {}
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * get available resources
   */
  async getAPIResources(): Promise<V1APIResourceList> {
    const response = await this.getAPIResourcesRaw()
    return await response.value()
  }

  /**
   * list or watch objects of kind ControllerRevision
   */
  async watchListControllerRevisionForAllNamespaces(
    requestParameters: ListControllerRevisionForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2ControllerRevisionList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2ControllerRevisionList>>(
      {
        path: `/apis/apps/v1beta2/controllerrevisions`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ControllerRevision
   */
  async listControllerRevisionForAllNamespacesRaw(
    requestParameters: ListControllerRevisionForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta2ControllerRevisionList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/controllerrevisions`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ControllerRevision
   */
  async listControllerRevisionForAllNamespaces(
    requestParameters: ListControllerRevisionForAllNamespacesRequest
  ): Promise<V1beta2ControllerRevisionList> {
    const response = await this.listControllerRevisionForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async watchListDaemonSetForAllNamespaces(
    requestParameters: ListDaemonSetForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2DaemonSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2DaemonSetList>>(
      {
        path: `/apis/apps/v1beta2/daemonsets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listDaemonSetForAllNamespacesRaw(
    requestParameters: ListDaemonSetForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSetList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/daemonsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listDaemonSetForAllNamespaces(
    requestParameters: ListDaemonSetForAllNamespacesRequest
  ): Promise<V1beta2DaemonSetList> {
    const response = await this.listDaemonSetForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Deployment
   */
  async watchListDeploymentForAllNamespaces(
    requestParameters: ListDeploymentForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2DeploymentList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2DeploymentList>>(
      {
        path: `/apis/apps/v1beta2/deployments`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listDeploymentForAllNamespacesRaw(
    requestParameters: ListDeploymentForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta2DeploymentList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/deployments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listDeploymentForAllNamespaces(
    requestParameters: ListDeploymentForAllNamespacesRequest
  ): Promise<V1beta2DeploymentList> {
    const response = await this.listDeploymentForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ControllerRevision
   */
  async watchListNamespacedControllerRevision(
    requestParameters: ListNamespacedControllerRevisionRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2ControllerRevisionList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2ControllerRevisionList>>(
      {
        path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ControllerRevision
   */
  async listNamespacedControllerRevisionRaw(
    requestParameters: ListNamespacedControllerRevisionRequest
  ): Promise<runtime.ApiResponse<V1beta2ControllerRevisionList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ControllerRevision
   */
  async listNamespacedControllerRevision(
    requestParameters: ListNamespacedControllerRevisionRequest
  ): Promise<V1beta2ControllerRevisionList> {
    const response = await this.listNamespacedControllerRevisionRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async watchListNamespacedDaemonSet(
    requestParameters: ListNamespacedDaemonSetRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2DaemonSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2DaemonSetList>>(
      {
        path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listNamespacedDaemonSetRaw(
    requestParameters: ListNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSetList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind DaemonSet
   */
  async listNamespacedDaemonSet(
    requestParameters: ListNamespacedDaemonSetRequest
  ): Promise<V1beta2DaemonSetList> {
    const response = await this.listNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind Deployment
   */
  async watchListNamespacedDeployment(
    requestParameters: ListNamespacedDeploymentRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2DeploymentList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2DeploymentList>>(
      {
        path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listNamespacedDeploymentRaw(
    requestParameters: ListNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1beta2DeploymentList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind Deployment
   */
  async listNamespacedDeployment(
    requestParameters: ListNamespacedDeploymentRequest
  ): Promise<V1beta2DeploymentList> {
    const response = await this.listNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async watchListNamespacedReplicaSet(
    requestParameters: ListNamespacedReplicaSetRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2ReplicaSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2ReplicaSetList>>(
      {
        path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listNamespacedReplicaSetRaw(
    requestParameters: ListNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSetList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listNamespacedReplicaSet(
    requestParameters: ListNamespacedReplicaSetRequest
  ): Promise<V1beta2ReplicaSetList> {
    const response = await this.listNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind StatefulSet
   */
  async watchListNamespacedStatefulSet(
    requestParameters: ListNamespacedStatefulSetRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2StatefulSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2StatefulSetList>>(
      {
        path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets`.replace(
          `{${'namespace'}}`,
          encodeURIComponent(String(requestParameters.namespace))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind StatefulSet
   */
  async listNamespacedStatefulSetRaw(
    requestParameters: ListNamespacedStatefulSetRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSetList>> {
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind StatefulSet
   */
  async listNamespacedStatefulSet(
    requestParameters: ListNamespacedStatefulSetRequest
  ): Promise<V1beta2StatefulSetList> {
    const response = await this.listNamespacedStatefulSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async watchListReplicaSetForAllNamespaces(
    requestParameters: ListReplicaSetForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2ReplicaSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2ReplicaSetList>>(
      {
        path: `/apis/apps/v1beta2/replicasets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listReplicaSetForAllNamespacesRaw(
    requestParameters: ListReplicaSetForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSetList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/replicasets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind ReplicaSet
   */
  async listReplicaSetForAllNamespaces(
    requestParameters: ListReplicaSetForAllNamespacesRequest
  ): Promise<V1beta2ReplicaSetList> {
    const response = await this.listReplicaSetForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * list or watch objects of kind StatefulSet
   */
  async watchListStatefulSetForAllNamespaces(
    requestParameters: ListStatefulSetForAllNamespacesRequest,
    callback: (event: runtime.KubeEvent<runtime.ItemType<V1beta2StatefulSetList>>) => void,
    signal?: AbortSignal
  ): Promise<void> {
    const queryParameters: runtime.HTTPQuery = { watch: true }
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    await this.requestStream<runtime.ItemType<V1beta2StatefulSetList>>(
      {
        path: `/apis/apps/v1beta2/statefulsets`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
        signal
      },
      callback
    )
  }

  /**
   * list or watch objects of kind StatefulSet
   */
  async listStatefulSetForAllNamespacesRaw(
    requestParameters: ListStatefulSetForAllNamespacesRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSetList>> {
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters._continue !== undefined) {
      queryParameters['continue'] = requestParameters._continue
    }
    if (requestParameters.fieldSelector !== undefined) {
      queryParameters['fieldSelector'] = requestParameters.fieldSelector
    }
    if (requestParameters.labelSelector !== undefined) {
      queryParameters['labelSelector'] = requestParameters.labelSelector
    }
    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.resourceVersion !== undefined) {
      queryParameters['resourceVersion'] = requestParameters.resourceVersion
    }
    if (requestParameters.timeoutSeconds !== undefined) {
      queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/statefulsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * list or watch objects of kind StatefulSet
   */
  async listStatefulSetForAllNamespaces(
    requestParameters: ListStatefulSetForAllNamespacesRequest
  ): Promise<V1beta2StatefulSetList> {
    const response = await this.listStatefulSetForAllNamespacesRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified ControllerRevision
   */
  async patchNamespacedControllerRevisionRaw(
    requestParameters: PatchNamespacedControllerRevisionRequest
  ): Promise<runtime.ApiResponse<V1beta2ControllerRevision>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedControllerRevision.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedControllerRevision.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified ControllerRevision
   */
  async patchNamespacedControllerRevision(
    requestParameters: PatchNamespacedControllerRevisionRequest
  ): Promise<V1beta2ControllerRevision> {
    const response = await this.patchNamespacedControllerRevisionRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified DaemonSet
   */
  async patchNamespacedDaemonSetRaw(
    requestParameters: PatchNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified DaemonSet
   */
  async patchNamespacedDaemonSet(
    requestParameters: PatchNamespacedDaemonSetRequest
  ): Promise<V1beta2DaemonSet> {
    const response = await this.patchNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified DaemonSet
   */
  async patchNamespacedDaemonSetStatusRaw(
    requestParameters: PatchNamespacedDaemonSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified DaemonSet
   */
  async patchNamespacedDaemonSetStatus(
    requestParameters: PatchNamespacedDaemonSetStatusRequest
  ): Promise<V1beta2DaemonSet> {
    const response = await this.patchNamespacedDaemonSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified Deployment
   */
  async patchNamespacedDeploymentRaw(
    requestParameters: PatchNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1beta2Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeployment.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified Deployment
   */
  async patchNamespacedDeployment(
    requestParameters: PatchNamespacedDeploymentRequest
  ): Promise<V1beta2Deployment> {
    const response = await this.patchNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update scale of the specified Deployment
   */
  async patchNamespacedDeploymentScaleRaw(
    requestParameters: PatchNamespacedDeploymentScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update scale of the specified Deployment
   */
  async patchNamespacedDeploymentScale(
    requestParameters: PatchNamespacedDeploymentScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.patchNamespacedDeploymentScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified Deployment
   */
  async patchNamespacedDeploymentStatusRaw(
    requestParameters: PatchNamespacedDeploymentStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified Deployment
   */
  async patchNamespacedDeploymentStatus(
    requestParameters: PatchNamespacedDeploymentStatusRequest
  ): Promise<V1beta2Deployment> {
    const response = await this.patchNamespacedDeploymentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified ReplicaSet
   */
  async patchNamespacedReplicaSetRaw(
    requestParameters: PatchNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified ReplicaSet
   */
  async patchNamespacedReplicaSet(
    requestParameters: PatchNamespacedReplicaSetRequest
  ): Promise<V1beta2ReplicaSet> {
    const response = await this.patchNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update scale of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetScaleRaw(
    requestParameters: PatchNamespacedReplicaSetScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update scale of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetScale(
    requestParameters: PatchNamespacedReplicaSetScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.patchNamespacedReplicaSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetStatusRaw(
    requestParameters: PatchNamespacedReplicaSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified ReplicaSet
   */
  async patchNamespacedReplicaSetStatus(
    requestParameters: PatchNamespacedReplicaSetStatusRequest
  ): Promise<V1beta2ReplicaSet> {
    const response = await this.patchNamespacedReplicaSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update the specified StatefulSet
   */
  async patchNamespacedStatefulSetRaw(
    requestParameters: PatchNamespacedStatefulSetRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedStatefulSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedStatefulSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update the specified StatefulSet
   */
  async patchNamespacedStatefulSet(
    requestParameters: PatchNamespacedStatefulSetRequest
  ): Promise<V1beta2StatefulSet> {
    const response = await this.patchNamespacedStatefulSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update scale of the specified StatefulSet
   */
  async patchNamespacedStatefulSetScaleRaw(
    requestParameters: PatchNamespacedStatefulSetScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedStatefulSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedStatefulSetScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedStatefulSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update scale of the specified StatefulSet
   */
  async patchNamespacedStatefulSetScale(
    requestParameters: PatchNamespacedStatefulSetScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.patchNamespacedStatefulSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * partially update status of the specified StatefulSet
   */
  async patchNamespacedStatefulSetStatusRaw(
    requestParameters: PatchNamespacedStatefulSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling patchNamespacedStatefulSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedStatefulSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling patchNamespacedStatefulSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    if (requestParameters.force !== undefined) {
      queryParameters['force'] = requestParameters.force
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * partially update status of the specified StatefulSet
   */
  async patchNamespacedStatefulSetStatus(
    requestParameters: PatchNamespacedStatefulSetStatusRequest
  ): Promise<V1beta2StatefulSet> {
    const response = await this.patchNamespacedStatefulSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ControllerRevision
   */
  async readNamespacedControllerRevisionRaw(
    requestParameters: ReadNamespacedControllerRevisionRequest
  ): Promise<runtime.ApiResponse<V1beta2ControllerRevision>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedControllerRevision.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ControllerRevision
   */
  async readNamespacedControllerRevision(
    requestParameters: ReadNamespacedControllerRevisionRequest
  ): Promise<V1beta2ControllerRevision> {
    const response = await this.readNamespacedControllerRevisionRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified DaemonSet
   */
  async readNamespacedDaemonSetRaw(
    requestParameters: ReadNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified DaemonSet
   */
  async readNamespacedDaemonSet(
    requestParameters: ReadNamespacedDaemonSetRequest
  ): Promise<V1beta2DaemonSet> {
    const response = await this.readNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified DaemonSet
   */
  async readNamespacedDaemonSetStatusRaw(
    requestParameters: ReadNamespacedDaemonSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified DaemonSet
   */
  async readNamespacedDaemonSetStatus(
    requestParameters: ReadNamespacedDaemonSetStatusRequest
  ): Promise<V1beta2DaemonSet> {
    const response = await this.readNamespacedDaemonSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified Deployment
   */
  async readNamespacedDeploymentRaw(
    requestParameters: ReadNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1beta2Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified Deployment
   */
  async readNamespacedDeployment(
    requestParameters: ReadNamespacedDeploymentRequest
  ): Promise<V1beta2Deployment> {
    const response = await this.readNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * read scale of the specified Deployment
   */
  async readNamespacedDeploymentScaleRaw(
    requestParameters: ReadNamespacedDeploymentScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read scale of the specified Deployment
   */
  async readNamespacedDeploymentScale(
    requestParameters: ReadNamespacedDeploymentScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.readNamespacedDeploymentScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified Deployment
   */
  async readNamespacedDeploymentStatusRaw(
    requestParameters: ReadNamespacedDeploymentStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified Deployment
   */
  async readNamespacedDeploymentStatus(
    requestParameters: ReadNamespacedDeploymentStatusRequest
  ): Promise<V1beta2Deployment> {
    const response = await this.readNamespacedDeploymentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified ReplicaSet
   */
  async readNamespacedReplicaSetRaw(
    requestParameters: ReadNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified ReplicaSet
   */
  async readNamespacedReplicaSet(
    requestParameters: ReadNamespacedReplicaSetRequest
  ): Promise<V1beta2ReplicaSet> {
    const response = await this.readNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * read scale of the specified ReplicaSet
   */
  async readNamespacedReplicaSetScaleRaw(
    requestParameters: ReadNamespacedReplicaSetScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read scale of the specified ReplicaSet
   */
  async readNamespacedReplicaSetScale(
    requestParameters: ReadNamespacedReplicaSetScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.readNamespacedReplicaSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified ReplicaSet
   */
  async readNamespacedReplicaSetStatusRaw(
    requestParameters: ReadNamespacedReplicaSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified ReplicaSet
   */
  async readNamespacedReplicaSetStatus(
    requestParameters: ReadNamespacedReplicaSetStatusRequest
  ): Promise<V1beta2ReplicaSet> {
    const response = await this.readNamespacedReplicaSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * read the specified StatefulSet
   */
  async readNamespacedStatefulSetRaw(
    requestParameters: ReadNamespacedStatefulSetRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedStatefulSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.exact !== undefined) {
      queryParameters['exact'] = requestParameters.exact
    }
    if (requestParameters._export !== undefined) {
      queryParameters['export'] = requestParameters._export
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read the specified StatefulSet
   */
  async readNamespacedStatefulSet(
    requestParameters: ReadNamespacedStatefulSetRequest
  ): Promise<V1beta2StatefulSet> {
    const response = await this.readNamespacedStatefulSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * read scale of the specified StatefulSet
   */
  async readNamespacedStatefulSetScaleRaw(
    requestParameters: ReadNamespacedStatefulSetScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedStatefulSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedStatefulSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read scale of the specified StatefulSet
   */
  async readNamespacedStatefulSetScale(
    requestParameters: ReadNamespacedStatefulSetScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.readNamespacedStatefulSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * read status of the specified StatefulSet
   */
  async readNamespacedStatefulSetStatusRaw(
    requestParameters: ReadNamespacedStatefulSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling readNamespacedStatefulSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedStatefulSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * read status of the specified StatefulSet
   */
  async readNamespacedStatefulSetStatus(
    requestParameters: ReadNamespacedStatefulSetStatusRequest
  ): Promise<V1beta2StatefulSet> {
    const response = await this.readNamespacedStatefulSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified ControllerRevision
   */
  async replaceNamespacedControllerRevisionRaw(
    requestParameters: ReplaceNamespacedControllerRevisionRequest
  ): Promise<runtime.ApiResponse<V1beta2ControllerRevision>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedControllerRevision.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedControllerRevision.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedControllerRevision.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified ControllerRevision
   */
  async replaceNamespacedControllerRevision(
    requestParameters: ReplaceNamespacedControllerRevisionRequest
  ): Promise<V1beta2ControllerRevision> {
    const response = await this.replaceNamespacedControllerRevisionRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified DaemonSet
   */
  async replaceNamespacedDaemonSetRaw(
    requestParameters: ReplaceNamespacedDaemonSetRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified DaemonSet
   */
  async replaceNamespacedDaemonSet(
    requestParameters: ReplaceNamespacedDaemonSetRequest
  ): Promise<V1beta2DaemonSet> {
    const response = await this.replaceNamespacedDaemonSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified DaemonSet
   */
  async replaceNamespacedDaemonSetStatusRaw(
    requestParameters: ReplaceNamespacedDaemonSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2DaemonSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified DaemonSet
   */
  async replaceNamespacedDaemonSetStatus(
    requestParameters: ReplaceNamespacedDaemonSetStatusRequest
  ): Promise<V1beta2DaemonSet> {
    const response = await this.replaceNamespacedDaemonSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified Deployment
   */
  async replaceNamespacedDeploymentRaw(
    requestParameters: ReplaceNamespacedDeploymentRequest
  ): Promise<runtime.ApiResponse<V1beta2Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeployment.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeployment.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeployment.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified Deployment
   */
  async replaceNamespacedDeployment(
    requestParameters: ReplaceNamespacedDeploymentRequest
  ): Promise<V1beta2Deployment> {
    const response = await this.replaceNamespacedDeploymentRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace scale of the specified Deployment
   */
  async replaceNamespacedDeploymentScaleRaw(
    requestParameters: ReplaceNamespacedDeploymentScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace scale of the specified Deployment
   */
  async replaceNamespacedDeploymentScale(
    requestParameters: ReplaceNamespacedDeploymentScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.replaceNamespacedDeploymentScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified Deployment
   */
  async replaceNamespacedDeploymentStatusRaw(
    requestParameters: ReplaceNamespacedDeploymentStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2Deployment>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified Deployment
   */
  async replaceNamespacedDeploymentStatus(
    requestParameters: ReplaceNamespacedDeploymentStatusRequest
  ): Promise<V1beta2Deployment> {
    const response = await this.replaceNamespacedDeploymentStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetRaw(
    requestParameters: ReplaceNamespacedReplicaSetRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified ReplicaSet
   */
  async replaceNamespacedReplicaSet(
    requestParameters: ReplaceNamespacedReplicaSetRequest
  ): Promise<V1beta2ReplicaSet> {
    const response = await this.replaceNamespacedReplicaSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace scale of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetScaleRaw(
    requestParameters: ReplaceNamespacedReplicaSetScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace scale of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetScale(
    requestParameters: ReplaceNamespacedReplicaSetScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.replaceNamespacedReplicaSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetStatusRaw(
    requestParameters: ReplaceNamespacedReplicaSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2ReplicaSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified ReplicaSet
   */
  async replaceNamespacedReplicaSetStatus(
    requestParameters: ReplaceNamespacedReplicaSetStatusRequest
  ): Promise<V1beta2ReplicaSet> {
    const response = await this.replaceNamespacedReplicaSetStatusRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace the specified StatefulSet
   */
  async replaceNamespacedStatefulSetRaw(
    requestParameters: ReplaceNamespacedStatefulSetRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedStatefulSet.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedStatefulSet.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedStatefulSet.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace the specified StatefulSet
   */
  async replaceNamespacedStatefulSet(
    requestParameters: ReplaceNamespacedStatefulSetRequest
  ): Promise<V1beta2StatefulSet> {
    const response = await this.replaceNamespacedStatefulSetRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace scale of the specified StatefulSet
   */
  async replaceNamespacedStatefulSetScaleRaw(
    requestParameters: ReplaceNamespacedStatefulSetScaleRequest
  ): Promise<runtime.ApiResponse<V1beta2Scale>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedStatefulSetScale.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedStatefulSetScale.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedStatefulSetScale.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace scale of the specified StatefulSet
   */
  async replaceNamespacedStatefulSetScale(
    requestParameters: ReplaceNamespacedStatefulSetScaleRequest
  ): Promise<V1beta2Scale> {
    const response = await this.replaceNamespacedStatefulSetScaleRaw(requestParameters)
    return await response.value()
  }

  /**
   * replace status of the specified StatefulSet
   */
  async replaceNamespacedStatefulSetStatusRaw(
    requestParameters: ReplaceNamespacedStatefulSetStatusRequest
  ): Promise<runtime.ApiResponse<V1beta2StatefulSet>> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new Error(
        'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedStatefulSetStatus.'
      )
    }
    if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
      throw new Error(
        'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedStatefulSetStatus.'
      )
    }
    if (requestParameters.body === null || requestParameters.body === undefined) {
      throw new Error(
        'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedStatefulSetStatus.'
      )
    }
    const queryParameters: runtime.HTTPQuery = {}
    if (requestParameters.pretty !== undefined) {
      queryParameters['pretty'] = requestParameters.pretty
    }
    if (requestParameters.dryRun !== undefined) {
      queryParameters['dryRun'] = requestParameters.dryRun
    }
    if (requestParameters.fieldManager !== undefined) {
      queryParameters['fieldManager'] = requestParameters.fieldManager
    }
    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    })
    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * replace status of the specified StatefulSet
   */
  async replaceNamespacedStatefulSetStatus(
    requestParameters: ReplaceNamespacedStatefulSetStatusRequest
  ): Promise<V1beta2StatefulSet> {
    const response = await this.replaceNamespacedStatefulSetStatusRaw(requestParameters)
    return await response.value()
  }
}
