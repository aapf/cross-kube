// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.14.11
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  RequestOpts,
  HTTPHeaders,
  HTTPQuery,
  ApiResponse,
  StringApiResponse,
  JSONApiResponse,
  ItemType,
  KubeEvent,
  request,
  requestStream
} from '../runtime'
import V1APIResourceList from '../models/V1APIResourceList'
import V1ControllerRevision from '../models/V1ControllerRevision'
import V1ControllerRevisionList from '../models/V1ControllerRevisionList'
import V1DaemonSet from '../models/V1DaemonSet'
import V1DaemonSetList from '../models/V1DaemonSetList'
import V1DeleteOptions from '../models/V1DeleteOptions'
import V1Deployment from '../models/V1Deployment'
import V1DeploymentList from '../models/V1DeploymentList'
import V1ReplicaSet from '../models/V1ReplicaSet'
import V1ReplicaSetList from '../models/V1ReplicaSetList'
import V1Scale from '../models/V1Scale'
import V1StatefulSet from '../models/V1StatefulSet'
import V1StatefulSetList from '../models/V1StatefulSetList'
import V1Status from '../models/V1Status'

interface CreateNamespacedControllerRevisionRequest {
  namespace: string
  body: V1ControllerRevision
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDaemonSetRequest {
  namespace: string
  body: V1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedDeploymentRequest {
  namespace: string
  body: V1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedReplicaSetRequest {
  namespace: string
  body: V1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface CreateNamespacedStatefulSetRequest {
  namespace: string
  body: V1StatefulSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface DeleteCollectionNamespacedControllerRevisionRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteCollectionNamespacedStatefulSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface DeleteNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface DeleteNamespacedStatefulSetRequest {
  name: string
  namespace: string
  pretty?: string
  dryRun?: string
  gracePeriodSeconds?: number
  orphanDependents?: boolean
  propagationPolicy?: string
  body?: V1DeleteOptions
}

interface ListControllerRevisionForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListDaemonSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListDeploymentForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedControllerRevisionRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDaemonSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedDeploymentRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedReplicaSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListNamespacedStatefulSetRequest {
  namespace: string
  pretty?: string
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListReplicaSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface ListStatefulSetForAllNamespacesRequest {
  _continue?: string
  fieldSelector?: string
  labelSelector?: string
  limit?: number
  pretty?: string
  resourceVersion?: string
  timeoutSeconds?: number
}

interface PatchNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedStatefulSetRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedStatefulSetScaleRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface PatchNamespacedStatefulSetStatusRequest {
  name: string
  namespace: string
  body: object
  pretty?: string
  dryRun?: string
  fieldManager?: string
  force?: boolean
}

interface ReadNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDaemonSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicaSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedStatefulSetRequest {
  name: string
  namespace: string
  pretty?: string
  exact?: boolean
  _export?: boolean
}

interface ReadNamespacedStatefulSetScaleRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReadNamespacedStatefulSetStatusRequest {
  name: string
  namespace: string
  pretty?: string
}

interface ReplaceNamespacedControllerRevisionRequest {
  name: string
  namespace: string
  body: V1ControllerRevision
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDaemonSetRequest {
  name: string
  namespace: string
  body: V1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDaemonSetStatusRequest {
  name: string
  namespace: string
  body: V1DaemonSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentRequest {
  name: string
  namespace: string
  body: V1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentScaleRequest {
  name: string
  namespace: string
  body: V1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedDeploymentStatusRequest {
  name: string
  namespace: string
  body: V1Deployment
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetRequest {
  name: string
  namespace: string
  body: V1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetScaleRequest {
  name: string
  namespace: string
  body: V1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedReplicaSetStatusRequest {
  name: string
  namespace: string
  body: V1ReplicaSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedStatefulSetRequest {
  name: string
  namespace: string
  body: V1StatefulSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedStatefulSetScaleRequest {
  name: string
  namespace: string
  body: V1Scale
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

interface ReplaceNamespacedStatefulSetStatusRequest {
  name: string
  namespace: string
  body: V1StatefulSet
  pretty?: string
  dryRun?: string
  fieldManager?: string
}

/**
 * create a ControllerRevision
 */
export async function createNamespacedControllerRevisionRaw(
  requestParameters: CreateNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ControllerRevision>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedControllerRevision.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ControllerRevision
 */
export async function createNamespacedControllerRevision(
  requestParameters: CreateNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ControllerRevision> {
  const response = await createNamespacedControllerRevisionRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * create a DaemonSet
 */
export async function createNamespacedDaemonSetRaw(
  requestParameters: CreateNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSet>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDaemonSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a DaemonSet
 */
export async function createNamespacedDaemonSet(
  requestParameters: CreateNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSet> {
  const response = await createNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a Deployment
 */
export async function createNamespacedDeploymentRaw(
  requestParameters: CreateNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Deployment>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedDeployment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a Deployment
 */
export async function createNamespacedDeployment(
  requestParameters: CreateNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Deployment> {
  const response = await createNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a ReplicaSet
 */
export async function createNamespacedReplicaSetRaw(
  requestParameters: CreateNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSet>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedReplicaSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a ReplicaSet
 */
export async function createNamespacedReplicaSet(
  requestParameters: CreateNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSet> {
  const response = await createNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * create a StatefulSet
 */
export async function createNamespacedStatefulSetRaw(
  requestParameters: CreateNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSet>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling createNamespacedStatefulSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling createNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * create a StatefulSet
 */
export async function createNamespacedStatefulSet(
  requestParameters: CreateNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSet> {
  const response = await createNamespacedStatefulSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete collection of ControllerRevision
 */
export async function deleteCollectionNamespacedControllerRevisionRaw(
  requestParameters: DeleteCollectionNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ControllerRevision
 */
export async function deleteCollectionNamespacedControllerRevision(
  requestParameters: DeleteCollectionNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedControllerRevisionRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of DaemonSet
 */
export async function deleteCollectionNamespacedDaemonSetRaw(
  requestParameters: DeleteCollectionNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of DaemonSet
 */
export async function deleteCollectionNamespacedDaemonSet(
  requestParameters: DeleteCollectionNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedDaemonSetRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of Deployment
 */
export async function deleteCollectionNamespacedDeploymentRaw(
  requestParameters: DeleteCollectionNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of Deployment
 */
export async function deleteCollectionNamespacedDeployment(
  requestParameters: DeleteCollectionNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedDeploymentRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of ReplicaSet
 */
export async function deleteCollectionNamespacedReplicaSetRaw(
  requestParameters: DeleteCollectionNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of ReplicaSet
 */
export async function deleteCollectionNamespacedReplicaSet(
  requestParameters: DeleteCollectionNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedReplicaSetRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete collection of StatefulSet
 */
export async function deleteCollectionNamespacedStatefulSetRaw(
  requestParameters: DeleteCollectionNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteCollectionNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete collection of StatefulSet
 */
export async function deleteCollectionNamespacedStatefulSet(
  requestParameters: DeleteCollectionNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteCollectionNamespacedStatefulSetRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete a ControllerRevision
 */
export async function deleteNamespacedControllerRevisionRaw(
  requestParameters: DeleteNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedControllerRevision.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ControllerRevision
 */
export async function deleteNamespacedControllerRevision(
  requestParameters: DeleteNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedControllerRevisionRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * delete a DaemonSet
 */
export async function deleteNamespacedDaemonSetRaw(
  requestParameters: DeleteNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a DaemonSet
 */
export async function deleteNamespacedDaemonSet(
  requestParameters: DeleteNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a Deployment
 */
export async function deleteNamespacedDeploymentRaw(
  requestParameters: DeleteNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a Deployment
 */
export async function deleteNamespacedDeployment(
  requestParameters: DeleteNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a ReplicaSet
 */
export async function deleteNamespacedReplicaSetRaw(
  requestParameters: DeleteNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a ReplicaSet
 */
export async function deleteNamespacedReplicaSet(
  requestParameters: DeleteNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * delete a StatefulSet
 */
export async function deleteNamespacedStatefulSetRaw(
  requestParameters: DeleteNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Status>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling deleteNamespacedStatefulSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.gracePeriodSeconds !== undefined) {
    queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds
  }
  if (requestParameters.orphanDependents !== undefined) {
    queryParameters['orphanDependents'] = requestParameters.orphanDependents
  }
  if (requestParameters.propagationPolicy !== undefined) {
    queryParameters['propagationPolicy'] = requestParameters.propagationPolicy
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * delete a StatefulSet
 */
export async function deleteNamespacedStatefulSet(
  requestParameters: DeleteNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Status> {
  const response = await deleteNamespacedStatefulSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * get available resources
 */
export async function getAPIResourcesRaw(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1APIResourceList>> {
  const queryParameters: HTTPQuery = {}
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * get available resources
 */
export async function getAPIResources(
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1APIResourceList> {
  const response = await getAPIResourcesRaw(...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ControllerRevision
 */
export async function watchListControllerRevisionForAllNamespaces(
  requestParameters: ListControllerRevisionForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1ControllerRevisionList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ControllerRevisionList>>(
    callback,
    {
      path: `/apis/apps/v1/controllerrevisions`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ControllerRevision
 */
export async function listControllerRevisionForAllNamespacesRaw(
  requestParameters: ListControllerRevisionForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ControllerRevisionList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/controllerrevisions`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ControllerRevision
 */
export async function listControllerRevisionForAllNamespaces(
  requestParameters: ListControllerRevisionForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ControllerRevisionList> {
  const response = await listControllerRevisionForAllNamespacesRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function watchListDaemonSetForAllNamespaces(
  requestParameters: ListDaemonSetForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1DaemonSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1DaemonSetList>>(
    callback,
    {
      path: `/apis/apps/v1/daemonsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listDaemonSetForAllNamespacesRaw(
  requestParameters: ListDaemonSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSetList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/daemonsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listDaemonSetForAllNamespaces(
  requestParameters: ListDaemonSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSetList> {
  const response = await listDaemonSetForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Deployment
 */
export async function watchListDeploymentForAllNamespaces(
  requestParameters: ListDeploymentForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1DeploymentList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1DeploymentList>>(
    callback,
    {
      path: `/apis/apps/v1/deployments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Deployment
 */
export async function listDeploymentForAllNamespacesRaw(
  requestParameters: ListDeploymentForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DeploymentList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/deployments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Deployment
 */
export async function listDeploymentForAllNamespaces(
  requestParameters: ListDeploymentForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DeploymentList> {
  const response = await listDeploymentForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ControllerRevision
 */
export async function watchListNamespacedControllerRevision(
  requestParameters: ListNamespacedControllerRevisionRequest,
  callback: (event: KubeEvent<ItemType<V1ControllerRevisionList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ControllerRevisionList>>(
    callback,
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ControllerRevision
 */
export async function listNamespacedControllerRevisionRaw(
  requestParameters: ListNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ControllerRevisionList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ControllerRevision
 */
export async function listNamespacedControllerRevision(
  requestParameters: ListNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ControllerRevisionList> {
  const response = await listNamespacedControllerRevisionRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function watchListNamespacedDaemonSet(
  requestParameters: ListNamespacedDaemonSetRequest,
  callback: (event: KubeEvent<ItemType<V1DaemonSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1DaemonSetList>>(
    callback,
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listNamespacedDaemonSetRaw(
  requestParameters: ListNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSetList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind DaemonSet
 */
export async function listNamespacedDaemonSet(
  requestParameters: ListNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSetList> {
  const response = await listNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind Deployment
 */
export async function watchListNamespacedDeployment(
  requestParameters: ListNamespacedDeploymentRequest,
  callback: (event: KubeEvent<ItemType<V1DeploymentList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1DeploymentList>>(
    callback,
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind Deployment
 */
export async function listNamespacedDeploymentRaw(
  requestParameters: ListNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DeploymentList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind Deployment
 */
export async function listNamespacedDeployment(
  requestParameters: ListNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DeploymentList> {
  const response = await listNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function watchListNamespacedReplicaSet(
  requestParameters: ListNamespacedReplicaSetRequest,
  callback: (event: KubeEvent<ItemType<V1ReplicaSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ReplicaSetList>>(
    callback,
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listNamespacedReplicaSetRaw(
  requestParameters: ListNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSetList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listNamespacedReplicaSet(
  requestParameters: ListNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSetList> {
  const response = await listNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind StatefulSet
 */
export async function watchListNamespacedStatefulSet(
  requestParameters: ListNamespacedStatefulSetRequest,
  callback: (event: KubeEvent<ItemType<V1StatefulSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1StatefulSetList>>(
    callback,
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind StatefulSet
 */
export async function listNamespacedStatefulSetRaw(
  requestParameters: ListNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSetList>> {
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling listNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets`.replace(
        `{${'namespace'}}`,
        encodeURIComponent(String(requestParameters.namespace))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind StatefulSet
 */
export async function listNamespacedStatefulSet(
  requestParameters: ListNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSetList> {
  const response = await listNamespacedStatefulSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function watchListReplicaSetForAllNamespaces(
  requestParameters: ListReplicaSetForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1ReplicaSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1ReplicaSetList>>(
    callback,
    {
      path: `/apis/apps/v1/replicasets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listReplicaSetForAllNamespacesRaw(
  requestParameters: ListReplicaSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSetList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/replicasets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind ReplicaSet
 */
export async function listReplicaSetForAllNamespaces(
  requestParameters: ListReplicaSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSetList> {
  const response = await listReplicaSetForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * list or watch objects of kind StatefulSet
 */
export async function watchListStatefulSetForAllNamespaces(
  requestParameters: ListStatefulSetForAllNamespacesRequest,
  callback: (event: KubeEvent<ItemType<V1StatefulSetList>>) => void,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<void> {
  const queryParameters: HTTPQuery = { watch: true }
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  await requestStream<ItemType<V1StatefulSetList>>(
    callback,
    {
      path: `/apis/apps/v1/statefulsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
}

/**
 * list or watch objects of kind StatefulSet
 */
export async function listStatefulSetForAllNamespacesRaw(
  requestParameters: ListStatefulSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSetList>> {
  const queryParameters: HTTPQuery = {}
  if (requestParameters._continue !== undefined) {
    queryParameters['continue'] = requestParameters._continue
  }
  if (requestParameters.fieldSelector !== undefined) {
    queryParameters['fieldSelector'] = requestParameters.fieldSelector
  }
  if (requestParameters.labelSelector !== undefined) {
    queryParameters['labelSelector'] = requestParameters.labelSelector
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit
  }
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.resourceVersion !== undefined) {
    queryParameters['resourceVersion'] = requestParameters.resourceVersion
  }
  if (requestParameters.timeoutSeconds !== undefined) {
    queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/statefulsets`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * list or watch objects of kind StatefulSet
 */
export async function listStatefulSetForAllNamespaces(
  requestParameters: ListStatefulSetForAllNamespacesRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSetList> {
  const response = await listStatefulSetForAllNamespacesRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ControllerRevision
 */
export async function patchNamespacedControllerRevisionRaw(
  requestParameters: PatchNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ControllerRevision>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedControllerRevision.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedControllerRevision.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ControllerRevision
 */
export async function patchNamespacedControllerRevision(
  requestParameters: PatchNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ControllerRevision> {
  const response = await patchNamespacedControllerRevisionRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * partially update the specified DaemonSet
 */
export async function patchNamespacedDaemonSetRaw(
  requestParameters: PatchNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified DaemonSet
 */
export async function patchNamespacedDaemonSet(
  requestParameters: PatchNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSet> {
  const response = await patchNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified DaemonSet
 */
export async function patchNamespacedDaemonSetStatusRaw(
  requestParameters: PatchNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDaemonSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified DaemonSet
 */
export async function patchNamespacedDaemonSetStatus(
  requestParameters: PatchNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSet> {
  const response = await patchNamespacedDaemonSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified Deployment
 */
export async function patchNamespacedDeploymentRaw(
  requestParameters: PatchNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeployment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified Deployment
 */
export async function patchNamespacedDeployment(
  requestParameters: PatchNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Deployment> {
  const response = await patchNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update scale of the specified Deployment
 */
export async function patchNamespacedDeploymentScaleRaw(
  requestParameters: PatchNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update scale of the specified Deployment
 */
export async function patchNamespacedDeploymentScale(
  requestParameters: PatchNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await patchNamespacedDeploymentScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified Deployment
 */
export async function patchNamespacedDeploymentStatusRaw(
  requestParameters: PatchNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedDeploymentStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified Deployment
 */
export async function patchNamespacedDeploymentStatus(
  requestParameters: PatchNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Deployment> {
  const response = await patchNamespacedDeploymentStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetRaw(
  requestParameters: PatchNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified ReplicaSet
 */
export async function patchNamespacedReplicaSet(
  requestParameters: PatchNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSet> {
  const response = await patchNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update scale of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetScaleRaw(
  requestParameters: PatchNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update scale of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetScale(
  requestParameters: PatchNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await patchNamespacedReplicaSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetStatusRaw(
  requestParameters: PatchNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedReplicaSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified ReplicaSet
 */
export async function patchNamespacedReplicaSetStatus(
  requestParameters: PatchNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSet> {
  const response = await patchNamespacedReplicaSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update the specified StatefulSet
 */
export async function patchNamespacedStatefulSetRaw(
  requestParameters: PatchNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedStatefulSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedStatefulSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update the specified StatefulSet
 */
export async function patchNamespacedStatefulSet(
  requestParameters: PatchNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSet> {
  const response = await patchNamespacedStatefulSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update scale of the specified StatefulSet
 */
export async function patchNamespacedStatefulSetScaleRaw(
  requestParameters: PatchNamespacedStatefulSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedStatefulSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedStatefulSetScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedStatefulSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update scale of the specified StatefulSet
 */
export async function patchNamespacedStatefulSetScale(
  requestParameters: PatchNamespacedStatefulSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await patchNamespacedStatefulSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * partially update status of the specified StatefulSet
 */
export async function patchNamespacedStatefulSetStatusRaw(
  requestParameters: PatchNamespacedStatefulSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling patchNamespacedStatefulSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling patchNamespacedStatefulSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling patchNamespacedStatefulSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  if (requestParameters.force !== undefined) {
    queryParameters['force'] = requestParameters.force
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body as any
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * partially update status of the specified StatefulSet
 */
export async function patchNamespacedStatefulSetStatus(
  requestParameters: PatchNamespacedStatefulSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSet> {
  const response = await patchNamespacedStatefulSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ControllerRevision
 */
export async function readNamespacedControllerRevisionRaw(
  requestParameters: ReadNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ControllerRevision>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedControllerRevision.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ControllerRevision
 */
export async function readNamespacedControllerRevision(
  requestParameters: ReadNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ControllerRevision> {
  const response = await readNamespacedControllerRevisionRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified DaemonSet
 */
export async function readNamespacedDaemonSetRaw(
  requestParameters: ReadNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified DaemonSet
 */
export async function readNamespacedDaemonSet(
  requestParameters: ReadNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSet> {
  const response = await readNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified DaemonSet
 */
export async function readNamespacedDaemonSetStatusRaw(
  requestParameters: ReadNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDaemonSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified DaemonSet
 */
export async function readNamespacedDaemonSetStatus(
  requestParameters: ReadNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSet> {
  const response = await readNamespacedDaemonSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified Deployment
 */
export async function readNamespacedDeploymentRaw(
  requestParameters: ReadNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified Deployment
 */
export async function readNamespacedDeployment(
  requestParameters: ReadNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Deployment> {
  const response = await readNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read scale of the specified Deployment
 */
export async function readNamespacedDeploymentScaleRaw(
  requestParameters: ReadNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read scale of the specified Deployment
 */
export async function readNamespacedDeploymentScale(
  requestParameters: ReadNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await readNamespacedDeploymentScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified Deployment
 */
export async function readNamespacedDeploymentStatusRaw(
  requestParameters: ReadNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedDeploymentStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified Deployment
 */
export async function readNamespacedDeploymentStatus(
  requestParameters: ReadNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Deployment> {
  const response = await readNamespacedDeploymentStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified ReplicaSet
 */
export async function readNamespacedReplicaSetRaw(
  requestParameters: ReadNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified ReplicaSet
 */
export async function readNamespacedReplicaSet(
  requestParameters: ReadNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSet> {
  const response = await readNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read scale of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetScaleRaw(
  requestParameters: ReadNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read scale of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetScale(
  requestParameters: ReadNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await readNamespacedReplicaSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetStatusRaw(
  requestParameters: ReadNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedReplicaSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified ReplicaSet
 */
export async function readNamespacedReplicaSetStatus(
  requestParameters: ReadNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSet> {
  const response = await readNamespacedReplicaSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read the specified StatefulSet
 */
export async function readNamespacedStatefulSetRaw(
  requestParameters: ReadNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedStatefulSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.exact !== undefined) {
    queryParameters['exact'] = requestParameters.exact
  }
  if (requestParameters._export !== undefined) {
    queryParameters['export'] = requestParameters._export
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read the specified StatefulSet
 */
export async function readNamespacedStatefulSet(
  requestParameters: ReadNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSet> {
  const response = await readNamespacedStatefulSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read scale of the specified StatefulSet
 */
export async function readNamespacedStatefulSetScaleRaw(
  requestParameters: ReadNamespacedStatefulSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedStatefulSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedStatefulSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read scale of the specified StatefulSet
 */
export async function readNamespacedStatefulSetScale(
  requestParameters: ReadNamespacedStatefulSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await readNamespacedStatefulSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * read status of the specified StatefulSet
 */
export async function readNamespacedStatefulSetStatusRaw(
  requestParameters: ReadNamespacedStatefulSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling readNamespacedStatefulSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling readNamespacedStatefulSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * read status of the specified StatefulSet
 */
export async function readNamespacedStatefulSetStatus(
  requestParameters: ReadNamespacedStatefulSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSet> {
  const response = await readNamespacedStatefulSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified ControllerRevision
 */
export async function replaceNamespacedControllerRevisionRaw(
  requestParameters: ReplaceNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ControllerRevision>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedControllerRevision.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedControllerRevision.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedControllerRevision.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ControllerRevision
 */
export async function replaceNamespacedControllerRevision(
  requestParameters: ReplaceNamespacedControllerRevisionRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ControllerRevision> {
  const response = await replaceNamespacedControllerRevisionRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified DaemonSet
 */
export async function replaceNamespacedDaemonSetRaw(
  requestParameters: ReplaceNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified DaemonSet
 */
export async function replaceNamespacedDaemonSet(
  requestParameters: ReplaceNamespacedDaemonSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSet> {
  const response = await replaceNamespacedDaemonSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified DaemonSet
 */
export async function replaceNamespacedDaemonSetStatusRaw(
  requestParameters: ReplaceNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1DaemonSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDaemonSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified DaemonSet
 */
export async function replaceNamespacedDaemonSetStatus(
  requestParameters: ReplaceNamespacedDaemonSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1DaemonSet> {
  const response = await replaceNamespacedDaemonSetStatusRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace the specified Deployment
 */
export async function replaceNamespacedDeploymentRaw(
  requestParameters: ReplaceNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeployment.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeployment.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeployment.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified Deployment
 */
export async function replaceNamespacedDeployment(
  requestParameters: ReplaceNamespacedDeploymentRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Deployment> {
  const response = await replaceNamespacedDeploymentRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace scale of the specified Deployment
 */
export async function replaceNamespacedDeploymentScaleRaw(
  requestParameters: ReplaceNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace scale of the specified Deployment
 */
export async function replaceNamespacedDeploymentScale(
  requestParameters: ReplaceNamespacedDeploymentScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await replaceNamespacedDeploymentScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified Deployment
 */
export async function replaceNamespacedDeploymentStatusRaw(
  requestParameters: ReplaceNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Deployment>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedDeploymentStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedDeploymentStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified Deployment
 */
export async function replaceNamespacedDeploymentStatus(
  requestParameters: ReplaceNamespacedDeploymentStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Deployment> {
  const response = await replaceNamespacedDeploymentStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetRaw(
  requestParameters: ReplaceNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSet(
  requestParameters: ReplaceNamespacedReplicaSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSet> {
  const response = await replaceNamespacedReplicaSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace scale of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetScaleRaw(
  requestParameters: ReplaceNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace scale of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetScale(
  requestParameters: ReplaceNamespacedReplicaSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await replaceNamespacedReplicaSetScaleRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace status of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetStatusRaw(
  requestParameters: ReplaceNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1ReplicaSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedReplicaSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified ReplicaSet
 */
export async function replaceNamespacedReplicaSetStatus(
  requestParameters: ReplaceNamespacedReplicaSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1ReplicaSet> {
  const response = await replaceNamespacedReplicaSetStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace the specified StatefulSet
 */
export async function replaceNamespacedStatefulSetRaw(
  requestParameters: ReplaceNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedStatefulSet.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedStatefulSet.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedStatefulSet.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace the specified StatefulSet
 */
export async function replaceNamespacedStatefulSet(
  requestParameters: ReplaceNamespacedStatefulSetRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSet> {
  const response = await replaceNamespacedStatefulSetRaw(requestParameters, ...requestOptsArray)
  return await response.value()
}

/**
 * replace scale of the specified StatefulSet
 */
export async function replaceNamespacedStatefulSetScaleRaw(
  requestParameters: ReplaceNamespacedStatefulSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1Scale>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedStatefulSetScale.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedStatefulSetScale.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedStatefulSetScale.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace scale of the specified StatefulSet
 */
export async function replaceNamespacedStatefulSetScale(
  requestParameters: ReplaceNamespacedStatefulSetScaleRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1Scale> {
  const response = await replaceNamespacedStatefulSetScaleRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}

/**
 * replace status of the specified StatefulSet
 */
export async function replaceNamespacedStatefulSetStatusRaw(
  requestParameters: ReplaceNamespacedStatefulSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<ApiResponse<V1StatefulSet>> {
  if (requestParameters.name === null || requestParameters.name === undefined) {
    throw new Error(
      'Required parameter requestParameters.name was null or undefined when calling replaceNamespacedStatefulSetStatus.'
    )
  }
  if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
    throw new Error(
      'Required parameter requestParameters.namespace was null or undefined when calling replaceNamespacedStatefulSetStatus.'
    )
  }
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new Error(
      'Required parameter requestParameters.body was null or undefined when calling replaceNamespacedStatefulSetStatus.'
    )
  }
  const queryParameters: HTTPQuery = {}
  if (requestParameters.pretty !== undefined) {
    queryParameters['pretty'] = requestParameters.pretty
  }
  if (requestParameters.dryRun !== undefined) {
    queryParameters['dryRun'] = requestParameters.dryRun
  }
  if (requestParameters.fieldManager !== undefined) {
    queryParameters['fieldManager'] = requestParameters.fieldManager
  }
  const headerParameters: HTTPHeaders = {}

  const response = await request(
    {
      path: `/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status`
        .replace(`{${'name'}}`, encodeURIComponent(String(requestParameters.name)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(requestParameters.namespace))),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    },
    ...requestOptsArray
  )
  return new JSONApiResponse<any>(response)
}

/**
 * replace status of the specified StatefulSet
 */
export async function replaceNamespacedStatefulSetStatus(
  requestParameters: ReplaceNamespacedStatefulSetStatusRequest,
  ...requestOptsArray: Partial<RequestOpts>[]
): Promise<V1StatefulSet> {
  const response = await replaceNamespacedStatefulSetStatusRaw(
    requestParameters,
    ...requestOptsArray
  )
  return await response.value()
}
