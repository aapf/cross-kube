# cross-kube

JavaScript/TypeScript client library for Kubernetes which works with both browsers and Node.js.

This library is especially useful if your web server and Kubernetes API server are integrated with [OIDC](https://openid.net/connect/) signle sign-on.

### Fetch

cross-kube uses [Fetch](https://fetch.spec.whatwg.org/) and [WHATWG Streams](https://streams.spec.whatwg.org/) to communicate with Kubernetes API. You need polyfills to support legacy browsers (see the later section this doc).

The following libraries are used internally:

* in browser:
  * [fetch-readablestream](https://github.com/jonnyreeves/fetch-readablestream): A compatibility layer of [WHATWG Streams](https://streams.spec.whatwg.org/) 
* in Node.js:
  * [node-fetch](https://www.npmjs.com/package/node-fetch): `fetch()` for Node.js

### Importing Models/APIs

cross-kube provides only ES modules which will normally be processed by bundlers (Webpack, Rollup.js, etc) or TypeScript compiler (tsc). To import cross-kube directly from browsers and Node.js, you have to generate a UMD bundle by modifying [rollup.config.ts](rollup.config.ts) and execute `yarn build` manually.

Because the code of models and APIs (`src/models/` and `src/apis/`) are generated by Kubernetes API spec, they are huge. To avoid enlarging the resulting JavaScript bundle and to reduce burden on development tools, the top `index.js` does not include them. You have to import them from each module one by one.

Example:

```ts
import V1Pod from 'cross-kube/lib/models/V1Pod'
import CoreV1Api from 'cross-kube/lib/apis/CoreV1Api'
```

Since models are TypeScript interfaces (not classes), you can import them from `cross-kube/lib/modules` without enlarging the JavaScript bundle:

```ts
import { V1Pod, V1Service } from 'cross-kube/lib/models'
```

## Installation

```sh
$ npm install cross-kube
```

## Example Code in TypeScript

### List all pods

```ts
import CoreV1Api from 'cross-kube/lib/apis/CoreV1Api'

const api = new CoreV1Api('http://localhost:4000')
api.listNamespacedPod({ namespace: 'default' }).then(podList => {
  console.log(podList)
})
```

### Watch all pods

Watch methods receives HTTP 1.1 chunks from Kubernetes API and invoke a callback function for each event.

```ts
import CoreV1Api from 'cross-kube/lib/apis/CoreV1Api'
// import AbortController from 'abort-controller' // Node.js requires this

const api = new CoreV1Api('http://localhost:4000')
const ac = new AbortController()

// Receive events until receiving an abort signal or server-side timeout
api.watchNamespacedPod({ namespace: 'default', signal: ac.signal }, event => {
  console.log(event)
}).then(() => ({}))

// Abort after 10 seconds
setTimeout(() => {
  ac.abort()
}, 10000)
```

### Create a namespace

```ts
import V1Namespace from 'cross-kube/lib/models/V1Namespace'
import CoreV1Api from 'cross-kube/lib/apis/CoreV1Api'

const api = new CoreV1Api('http://localhost:4000')
const namespace: V1Namespace = {
  metadata: {
    name: 'test'
  }
}
api.createNamespace({ body: namespace }).then((res => {
  console.log('Created namespace', res)
})
```

## Polyfills

Browsers must have [TextEncoder](https://caniuse.com/#search=textencoder) and [ReadableStream](https://caniuse.com/#search=streams) to use this library. You need polyfills to support legacy browsers.

Here is an example code injecting [fast-text-encoding](https://www.npmjs.com/package/fast-text-encoding) and [web-streams-polyfill](https://www.npmjs.com/package/web-streams-polyfill) using [loadjs](https://www.npmjs.com/package/loadjs).

```js
import loadjs from 'loadjs'

async injectPolyfills() => {
  if (!('TextEncoder' in window)) {
    console.log('Loading fast-text-encoding')
    await loadjs('fast-text-encoding.js', {
      returnPromise: true
    })
  }
  if (!('ReadableStream' in window)) {
    console.log('Loading web-streams-polyfill')
    await loadjs('web-streams-polyfill.js', {
      returnPromise: true
    })
  }
}

// call the above function from your code
```
